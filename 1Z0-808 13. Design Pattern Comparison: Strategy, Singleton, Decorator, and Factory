Design Pattern Comparison: Strategy, Singleton, Decorator, and Factory

================ 01. Strategy Design Pattern ================
Purpose: Encapsulates algorithms and makes them interchangeable.
When to Use:
When you need to choose between different algorithms at runtime.
When you want to avoid tight coupling between the client and the algorithm.

Example:
interface SortingStrategy {
    void sort(int[] array);
}

class BubbleSortStrategy implements SortingStrategy {
    // ...
}

class QuickSortStrategy implements SortingStrategy {
    // ...
}

class Sorter {
    private SortingStrategy strategy;

    public Sorter(SortingStrategy strategy) {
        this.strategy = strategy;
    }

    public void sort(int[] array) {
        strategy.sort(array);   

    }
}


================ 02. Singleton Design Pattern ================
Purpose: Ensures a class has only one instance and provides a global point of access to it.
When to Use:
When you need to control the number of instances of a class.
When you need a global point of access to a shared resource.

Example:
Java
class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return   
 instance;
    }
}


================ 03. Decorator Design Pattern ================
Purpose: Adds new responsibilities to objects dynamically.
When to Use:
When you need to add behavior to objects without modifying their existing code.
When you want to provide different implementations of a behavior.

Example:
interface Beverage {
    double cost();
    String getDescription();
}

class Espresso implements Beverage {
    // ...
}

class Mocha extends Beverage {
    private Beverage beverage;

    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    // ...
}


================04. Factory Design Pattern ================
Purpose: Creates objects without specifying their exact class.
When to Use:
When you need to decouple the creation of objects from their usage.
When you want to provide different implementations of a product.

Example:
interface Shape {
    void draw();
}

class Circle implements Shape {
    // ...
}

class Rectangle implements Shape {
    // ...
}

class ShapeFactory {
    public Shape getShape(String shapeType) {
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE"))   
 {
            return new Rectangle();
        }
        return   
 null;
    }
}



----
