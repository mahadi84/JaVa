
01. What is Generic? Explain the purpose of generics and how they can be used to improve code reusability.
02. What is a Stream with examples of all three types?
03. What/WHY is Thread?  Explain the concept of multithreading and how to create and manage threads in Java.



====================01. Generics ==========================
How Generics Improve Code Reusability:

Generic Classes:  can work with --different data types. 
                  Ex: ArrayList<E>  is a generic class can store elements of any type E. 
                  This allows you to create lists of integers, strings, custom objects, or any other type without modifying the class itself.
Generic Methods: can operate on --different types of arguments. 
                  Ex: swap() a generic  method can be used to swap two elements of any type. 
                  This avoids the need to write separate swap methods for each data type.

Bounded Type Parameters: I can use bounded type parameters to restrict the types that can be used with a generic class or method. 
                  This allows you to ensure that the objects passed to the generic component have certain properties or methods.

    Example:
      class GenericClass<T>{
          private T data;
          public GenericClass(T t){
              this.data = t;
          }
          public T getData(){
              return data;
          }    
      }
      
      public class InnerGenericClass {
          public static void main(String[] args) {
              GenericClass<Integer>  tInt = new GenericClass<>(10);
              GenericClass<String>  tInt1 = new GenericClass<>("Bismillah");
              System.out.println(tInt.getData());
              System.out.println(tInt1.getData());              
          }
      }



==================== 02. What is Stream? ===========================

-Stream processes the Collection like Filtering, Sorting, Mapping

Example:
    import java.util.Arrays;
    import java.util.List;
    
    public class StreamExample {
        public static void main(String[] args){
            List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
            numbers.stream().filter(n -> n % 2 == 0).forEach(n -> System.out.println(n));        
     // Output: [2,4,6]
        }



##### 01. Filtering:
Purpose: Selects elements from a stream based on a specified condition.
Syntax: stream.filter(predicate)

Example:
  List<Person> people = Arrays.asList(
  new Person("Alice", 30),
  new Person("Bob", 25),
  new Person("Charlie", 35)
  );
  
  List<Person> adults = people.stream()
  .filter(p -> p.getAge() >= 18)
  .collect(Collectors.toList());
  System.out.println(adults); // Output: [Alice, Bob, Charlie]

##### 02. Sorting:
Purpose: Arranges elements in a stream according to a specified comparator.
Syntax: stream.sorted(comparator) or stream.sorted() (for natural ordering)

Example:
  List<Person> sortedPeople = people.stream()
  .sorted(Comparator.comparing(Person::getName))
  .collect(Collectors.toList());  
  System.out.println(sortedPeople); // Output: [Alice, Bob, Charlie]

##### 03. Mapping:
Purpose: Transforms elements in a stream to a different type. *`java List<String> names = people.stream() .map(Person::getName) .collect(Collectors.toList());
System.out.println(names); // Output: [Alice, Bob, Charlie]

##### Combined Example:
  List<String> adultNames = people.stream()
          .filter(p -> p.getAge() >= 18)
          .sorted(Comparator.comparing(Person::getName))
          .map(Person::getName)
          .collect(Collectors.toList());
  
  System.out.println(adultNames); // Output: [Alice, Bob, Charlie]

#######Key Points:
Intermediate operations: filter, sorted, and map are intermediate operations that create a new stream. They don't produce a final result.
Terminal operations: collect(Collectors.toList()) is a terminal operation that consumes the stream and produces a final result (a list in this case).
Pipelines: Multiple operations can be chained together in a pipeline to perform complex transformations.
Readability: Using streams can improve code readability and maintainability by expressing operations in a declarative style.




==================== 02. What are Threads and Multithreading? ===========================
Thread: --Concurrent Execution of multiple tasks within a single program.
        --Breaking down tasks into smaller, independent subtasks.
        --Executing these subtasks concurrently on multiple cores.
              -perform parallel
              -Shared resources
              -Lightweight

Multithreading: Concurrent Execution of two or more threads within a single program

########## Why Thread?
A) Multi-threaded Game Development:
  -Handling game logic, graphics rendering, and input processing simultaneously.
  -Creating smooth and responsive gameplay.
    Examples: Online multiplayer games, real-time strategy games.

B) Asynchronous Programming:
  -Executing long-running tasks without blocking the main thread.
  -Updating the user interface while performing background tasks.
  -Preventing the application from freezing.
     Examples: File I/O operations, network communication, database queries.

C) Server-Side Applications:
  -Handling multiple client requests simultaneously.Processing incoming data and sending responses efficiently.
    Examples: Web servers, database servers, chat servers.

#######Thread Synchronization:
  -Mechanisms to prevent race conditions(attempts to perform two or more operations at the same time) and ensure data consistency,
  -It uses synchronized blocks or methods, wait() and notify() methods, or ReentrantLock.

########## Creating Threads:---
        There are two primary ways to create threads in Java:

        01. Extending the Thread class:
        -------------------------------
        class MyThread extends Thread {
            public void run() {
                // Thread's execution code
            }
        }

        
        02. Implementing the Runnable interface:
        ----------------------------------------
        class MyTask implements Runnable {
            public void run() {
                // Thread's execution code
            }
        }

    ######## Example:
                public class MultithreadedExample {
                    public static void main(String[] args) {
                        Runnable task = () -> {
                            for (int i = 0; i < 5; i++) {
                                System.out.println("Thread: " + Thread.currentThread().getName() + ", Iteration: " + i);
                            }
                        };
        
                        Thread thread1 = new Thread(task, "Thread 1");
                        Thread thread2 = new Thread(task, "Thread 2");
                        Thread thread3 = new Thread(task, "Thread 3");
                
                        thread1.start();
                        thread2.start();
                        thread3.start();
                    }
                }

########Managing Threads:
Starting a Thread: Call the start() method on the Thread object to start the thread's execution.
Stopping a Thread: While Java doesn't have a built-in method to stop a thread directly, you can use techniques like setting a flag or using interrupt() to signal the thread to stop.
Joining a Thread: Use the join() method to wait for a thread to finish its execution before continuing the main thread.
Synchronization: Use synchronization mechanisms like synchronized blocks or methods to ensure that multiple threads access shared resources safely.
Thread Pools: Use ExecutorService to manage a pool of threads efficiently and avoid creating and destroying threads for each task.





-
