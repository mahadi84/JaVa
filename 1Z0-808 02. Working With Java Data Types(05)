Date: 1-2Aug-2024(Thursday-Friday)


=======================Chapter:02 Working With Java Data Types(05) =========

01. Declare and initialize variables (including casting of primitive data types)
02. Differentiate between object reference variables and primitive variables
03. Know how to read or write to object fields
04. Explain an Object's Lifecycle (creation, "dereference by reassignment" and garbage collection)
05. Develop code that uses wrapper classes such as Boolean, Double, and Integer  

=======================================

-----------01. Declare and initialize variables (including casting of primitive data types)---------------------

* What is a variable?
* What are the different data types in Java?
* What is the difference between implicit and explicit casting?
* How do you declare and initialize a variable?
* What are the rules for naming variables?


######## Understanding Variables ################
    * A variable is a named storage location that holds a value.
    * In Java, variables must be declared before use.
    * The data type of a variable determines the type of data it can hold.

######## Primitive Data Types ################
Java has eight primitive data types:
    > byte: 8-bit signed integer (-128 to 127)
    > short: 16-bit signed integer (-32768 to 32767)
    > int: 32-bit signed integer (-2147483648 to 2147483647)
    > long: 64-bit signed integer (-9223372036854775808 to 9223372036854775807)
    > float: 32-bit single-precision floating-point number
    > double: 64-bit double-precision floating-point number
    > char: 16-bit Unicode character
    > boolean: true or false

######## Declaration and Initialization 
**Declaration:** Specifies the data type and name of the variable.
    int age;
    double salary;
    char initial;
    boolean isStudent;

**Initialization:** Assigns a value to the variable.
    int age = 25;
    double salary = 45000.50;
    char initial = 'A';
    boolean isStudent = true;

######## Casting Primitive Data Types ################
    * Casting is converting a value from one data type to another.
    * Implicit casting (widening) happens automatically for compatible types (e.g., int to double).
    * Explicit casting (narrowing) requires a cast operator to prevent data loss.

        int num = 10;
        double d = num; // Implicit casting (int to double)

        double pi = 3.14159;
        int i = (int) pi; // Explicit casting (double to int, potential data loss)

######## Important Considerations ################
    * Variable names must start with a letter, underscore (_), or dollar sign ($).
    * Variable names are case-sensitive.
    * Keywords cannot be used as variable names.
    * Use meaningful variable names to improve code readability.
    * Initialize variables before using them to avoid errors.

######## Example 
    public class VariableExample {
        public static void main(String[] args) {
            byte age = 25;
            short population = 32767;
            int salary = 50000;
            long worldPopulation = 7000000000L; // L suffix for long
            float pi = 3.14159f; // f suffix for float
            double gravity = 9.8;
            char initial = 'J';
            boolean isEmployed = true;

            // Casting example
            int x = (int) 3.14; // x will be 3
        }
    }







-----------02. Differentiate between object reference variables and primitive variables-------------------------

## Object Reference Variables vs Primitive in Java

####### Object Reference Variables ##########
    * Store references (memory addresses) to objects.
    * Objects are instances of classes.
    * Data types are class names (e.g., `String`, `Integer`, `ArrayList`).
    * Occupy variable-size memory locations.
    * References are copied when assigned, but the underlying object is not.
    * Access object's properties and methods using the dot operator (.).

####### Primitive Variables  #######
    * Store simple values directly.
    * Data types include: `byte`, `short`, `int`, `long`, `float`, `double`, `char`, and `boolean`.
    * Occupy fixed-size memory locations.
    * Values are copied when assigned to another variable.
    * No methods or properties associated with them.



**Example:**
    String name = "Alice"; // Object reference variable
    String anotherName = name; // Both variables refer to the same object

    int x = 10; // Primitive variable
    int y = x; // Copies the value 10 to y

    name = "Bob"; // Changes the reference to a new object, but anotherName still points to "Alice"
    x = 20; // Changes the value of x, but y remains 10


### Key Differences #######

    Feature     | Primitive Variables           | Object Reference Variables 
    ---------------------------------------------------------------------------
    Storage     | Direct value storage          | Reference to object location 
    Data Types  | Built-in types                | Class names 
    Memory      | Fixed size                    | Variable size 
    Assignment  | Value copying                 | Reference copying 
    Operations  | Basic arithmetic, comparison  | Object methods and properties 

### Additional Points for 1Z0-808 #######
    > Null values:** Object reference variables can be assigned `null` to indicate that they don't refer to any object. Primitive variables cannot be null.
    > Wrapper classes:** Primitive types have corresponding wrapper classes (e.g., `Integer`, `Double`) that allow them to be treated as objects.
    > Autoboxing and unboxing:** Java automatically converts between primitive types and their wrapper classes.
    > Memory management:** Primitive variables are managed by the JVM, while object memory is managed by the garbage collector.



-----------03. Know how to read or write to object fields-------------------------

Understanding Object Fields: Before diving into reading and writing, it's essential to grasp the concept of object fields.

Fields: are variables declared within a class. They represent the data associated with an object.
Object: is an instance of a class. It holds the values of its fields.


######### Accessing Object Fields ##########

There are primarily two ways to access object fields:

1. Direct Access (Using Dot Operator)
    This method is straightforward but has limitations due to encapsulation.
    It's suitable for public fields.
        class Person {
            public String name;
            int age; // Default access (package-private)
        }

        public class Main {
            public static void main(String[] args) {
                Person person = new Person();
                person.name = "Alice"; // Direct access to public field
                // person.age = 30; // Error: age is not public
            }
        }


2. Using Accessor Methods (Getters and Setters)
    This is the preferred approach for encapsulating data and providing controlled access.
    It allows you to validate input and perform additional logic.

        class Person {
            private String name;
            private int age;

            public String getName() {
                return name;
            }

            public void setName(String name) {
                this.name = name;
            }

            public int getAge() {
                return age;
            }

            public   
        void setAge(int age) {
                if (age >= 0) {
                    this.age    = age;
                } else {
                    // Handle invalid age
                }
            }
        }

        public class Main {
            public static void main(String[] args) {
                Person person = new Person();
                person.setName("Bob");
                person.setAge(25);
                System.out.println(person.getName());
                System.out.println(person.getAge());
            }
        }


######## Key Points ##########
    Encapsulation: Protect data integrity by using private fields and providing public getters and setters.
    Readability: Well-named getters and setters improve code clarity.
    Flexibility: Accessor methods can be used for complex logic or validation.
    Direct Access: Use with caution, especially for public fields.

### Additional Considerations
    Static Fields: Fields declared as static belong to the class itself, not instances.
    Transient Fields: Fields marked as transient are not serialized.
    Volatile Fields: Fields marked as volatile ensure visibility across threads.





-----------04. Explain an Object's Lifecycle (creation, "dereference by reassignment" and garbage collection)---


######## Creation ########
    An object is created using the `new` keyword followed by the constructor of the class. The constructor initializes the object's state.
    String name = new String("Alice");

    * The `new String("Alice")` part creates a new `String` object in the heap memory.
    * The `name` variable holds a reference to this object.

######## Dereference by Reassignment ########
    Dereferencing means breaking the link between a reference variable and the object it points to. This usually happens through reassignment.
    name = "Bob";

    * A new `String` object "Bob" is created.
    * The `name` variable now points to this new object.
    * The old "Alice" object is no longer referenced by any variable.

######## Garbage Collection ########
    Java employs automatic garbage collection to reclaim memory occupied by objects that are no longer in use.

    * The garbage collector periodically scans the heap for objects that are unreachable. 
    * An object becomes unreachable when there are no active references to it.
    * Once an object is determined to be garbage, its memory is reclaimed for future use.

######## Key Points: #######

    * Objects live in the heap memory.
    * Reference variables hold addresses of objects.
    * Assigning a new value to a reference variable doesn't destroy the old object but breaks the link.
    * Garbage collection is automatic, but its timing is unpredictable.

    **Example:**

    public class ObjectLifecycle {
        public static void main(String[] args) {
            String name1 = new String("Alice"); // Object creation
            String name2 = name1; // Both references point to the same object

            name1 = "Bob"; // Dereference of "Alice" object

            // At this point, the "Alice" object is eligible for garbage collection
        }
    }


######## Important Notes:**
* While `System.gc()` can be used to suggest garbage collection, it's not guaranteed to run immediately.
* The `finalize()` method is called before garbage collection, but its use is generally discouraged.
* Understanding object lifetimes is crucial for preventing memory leaks.





-----------05. Develop code that uses wrapper classes such as Boolean, Double, and Integer ---------------------

########  Using Wrapper Classes in Java ###### 
Wrapper classes in Java provide a way to convert primitive data types into objects. 
This is essential for using primitive data types in collections, as collections can only store objects.

#########  Example: Using Boolean, Double, and Integer ############ 

import java.util.ArrayList;

public class WrapperClassExample {
    public static void main(String[] args) {
        // Creating wrapper class objects
        Boolean boolValue = true;
        Double doubleValue = 3.14;
        Integer intValue = 10;

        // Using wrapper class methods
        System.out.println("Boolean value: " + boolValue);
        System.out.println("Double value: " + doubleValue);
        System.out.println("Integer value: " + intValue);

        // Autoboxing and unboxing
        int primitiveInt = intValue; // Unboxing
        Double primitiveDouble = doubleValue; // Unboxing

        // Using wrapper classes in collections
        ArrayList<Integer> numbers = new ArrayList<>();
        numbers.add(intValue);
        numbers.add(20); // Autoboxing

        System.out.println("Numbers: " + numbers);
    }
}
```

#########  Explanation: ###### 
    1. **Creating wrapper class objects:** We create objects of `Boolean`, `Double`, and `Integer` wrapper classes to hold primitive values.
    2. **Using wrapper class methods:** We can use methods provided by wrapper classes like `toString()` to convert values to strings.
    3. **Autoboxing and unboxing:** Java automatically converts between primitive types and their corresponding wrapper classes. This is called autoboxing and unboxing.
    4. **Using wrapper classes in collections:** We can store wrapper class objects in collections like `ArrayList`.

### Additional Examples: ###### 
    **Parsing strings to primitive types:**
        String strInt = "123";
        int parsedInt = Integer.parseInt(strInt);

**Comparing wrapper objects:**
  Integer num1 = 10;
  Integer num2 = new Integer(10);
  System.out.println(num1 == num2); // False (different objects)
  System.out.println(num1.equals(num2)); // True (same value)

**Using wrapper class constants:**
  boolean isTrue = Boolean.TRUE;
  double pi = Double.PI;


###### Key Points: ###### 
    * Wrapper classes provide object representations of primitive data types.
    * Autoboxing and unboxing simplify the conversion between primitive types and wrapper objects.
    * Wrapper classes offer additional methods and utilities for working with primitive values.
    * Use wrapper classes when you need to store primitive values in collections or when you need to use object-oriented features with primitive values.


######  Additional Considerations
    Null values: Wrapper classes can hold null values, unlike primitive types.
    Performance: While autoboxing and unboxing are convenient, they can have a slight performance impact compared to using primitive types directly.
    Caching: Some wrapper classes (like Integer and Byte) have a cache for commonly used values to optimize performance.




---

