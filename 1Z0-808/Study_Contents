
==================================================================================
 OCA(1Z0-808) Oracle Certified Associate Java SE 8 Programmer I Study Guide Exam
=================================================================================


############# Chapter 1 Java Building Blocks 1 ##########################

    - Understanding the Java Class Structure 2
    - Fields and Methods 2
    - Comments 4
    - Classes vs. Files 5
    - Writing a main() Method 6
    - Understanding Package Declarations and Imports 9
    - Wildcards 10
    - Redundant Imports 11
    - Naming Conflicts 12
    - Creating a New Package 13
    - Code Formatting on the Exam 16
    - Creating Objects 16
    - Constructors 17
    - Reading and Writing Object Fields 18
    - Instance Initializer Blocks 18
    - Order of Initialization 19
    - Distinguishing Between Object References and Primitives 20
    - Primitive Types 20
    - Reference Types 24
    - Key Differences 25
    - Declaring and Initializing Variables 25
    - Declaring Multiple Variables 26
    - Identifiers 27
    - Understanding Default Initialization of Variables 29
    - Local Variables 29
    - Instance and Class Variables 30
    - Understanding Variable Scope 31
    - Ordering Elements in a Class 34
    - Destroying Objects 36
    - Garbage Collection 36
    - finalize() 38
    - Benefits of Java 39
    - Summary 40
    - Exam Essentials 41
    - Review Questions 42xvi Contents


############# Chapter 2 Operators and Statements 51 ##########################

    - Understanding Java Operators 52
    - Working with Binary Arithmetic Operators 53
    - Arithmetic Operators 53
    - Numeric Promotion 55
    - Working with Unary Operators 57
    - Logical Complement and Negation Operators 57
    - Increment and Decrement Operators 58
    - Using Additional Binary Operators 60
    - Assignment Operators 60
    - Compound Assignment Operators 62
    - Relational Operators 63
    - Logical Operators 64
    - Equality Operators 65
    - Understanding Java Statements 66
    - The if-then Statement 67
    - The if-then-else Statement 68
    - The switch Statement 72
    - The while Statement 76
    - The do-while Statement 78
    - The for Statement 80
    - Understanding Advanced Flow Control 86
    - Nested Loops 87
    - Adding Optional Labels 87
    - The break Statement 88
    - The continue Statement 90
    - Summary 92
    - Exam Essentials 92
    - Review Questions 94


############# Chapter 3 Core Java APIs 101 ##########################

    - Creating and Manipulating Strings 102
        > String fundamental class > with new without new
    - Concatenation 102
        > 1+2+"c"    > String s= "1"; s+="2"; s+=3; 
        > String s1= "1"; String s2= s1.concat("2");  s2.concat("3"); OUTPUT:12
    - Immutability 104
        > String is non-changeable, make non-larger or non-smaller
    - The String Pool 105
        > location in java virtual machine that collect all strings > garbage collectible 
    - Important String Methods 105
        01. charAt() 02. indexOf() 03. lastIndexOf() 04. substring()
        05. replace() 06. concat() 07. contains() 08. equals() 09. equalsIgnoreCase()
        10. startsWith()  11. endsWith()  12. toUpperCase() 13. toLowerCase()
        14. toCharArray()  15. valueOf()
    - Method Chaining 110
        > String a= "abc"; String b= a.toUpperCase(); b= b.replace("B", "2").replace('C', '3');
    - Using the StringBuilder Class 111
        >Mutable
        > StringBuilder sb = new StringBuilder("start"); sb.append("+middle"); 
        > StringBuilder same = sb.append("+end"); // "start+middle+end"
    - Mutability and Chaining 112
    - Creating a StringBuilder 113
        >StringBuilder sb1 = new StringBuilder(); StringBuilder sb2 = new StringBuilder("animal"); StringBuilder sb3 = new StringBuilder(10);
    - Important StringBuilder Methods 114
        01. charAt() 02. indexOf() 03. lastIndexOf() 04. substring()
        05. append() 06. insert() 07. delete() 08. deleteCharAt() 09. reverse() 10. toString()
    - StringBuilder vs. StringBuffer 117
        > newer-older >faster-slower
    - Understanding Equality 117
        > String x = "Hello World"; String z = " Hello World".trim(); 
        > System.out.println(x == z); // false > System.out.println(x.equals(z)); // true
    - Understanding Java Arrays 119
        > Special variable > store multiple same type of data
    - Creating an Array of Primitives 119
        > int[] iA= new int[1];  //[tray icon, indicate an array]      
    - Creating an Array with Reference Variables 121
        > String [] bugs = { "cricket", "beetle", "ladybug" };
        > String [] alias = bugs;
          >System.out.println(bugs.equals(alias)); // true
          >System.out.println(bugs.toString()); // [Ljava.lang.String;@160bc7c0
       > Object[] objects= bugs;
       > String[] againStrings = (String[]) objects;
    - Using an Array 123
       > String[] birds = new String[6]; System.out.println(birds.length); //print all 6 elements of the array are null.
    - Sorting 124
       > Unsorted array, A surprise—this result isn’t predictable
       > String[] strings = { "10", "9", "100" }; Arrays.sort(strings); //outputs 10 100 9.
    - Searching 125
      > int[] numbers = {2,4,6,8}; 
      > System.out.println(Arrays.binarySearch(numbers, 2)); // 0
      > System.out.println(Arrays.binarySearch(numbers, 1)); // -1
    - Varargs 126
    - Multidimensional Arrays 126
        > int[] iA= new int[1];  //[tray icon, indicate an array]
        > char[][] cA2= {{'A', 'B', 'C'}, {'D', 'E', 'F'}}; //table with 2 rows and 3 columns
        > char[][] cA= new char[no_of_rows][no_of_cols];
        > int[][][] building = new int[no_of_floors][no_of_rows][no_of_column/rooms]; 
    - Understanding an ArrayList 129
    - Creating an ArrayList 129
    - Using an ArrayList 130
         01. add()  02. get() 03.set() 04. size() and  isEmpty() 
         05. remove() 06. removeOf()  07. clear()  08. contains()  09. equals()
    - Wrapper Classes 134
    - Autoboxing 136
    - Converting Between array and List 136
    - Sorting 138
    - Working with Dates and Times 138
    - Creating Dates and Times 138
    - Manipulating Dates and Times 142
    - Working with Periods 145
    - Formatting Dates and Times 148
    - Parsing Dates and Times 151
    - Summary 151
    - Exam Essentials 152
    - Review Questions 153


############# Chapter 4 Methods and Encapsulation 165 ##########################

    - Designing Methods 166
    - Optional Specifiers 168
       > static, abstract, final, synchronized, native, strictfp
    - Return Type 169
       > void return nothing but not restict.
    - Method Name 170
       > start with _, &,  A-Z, a-z
    - Parameter List 171
    - Optional Exception List 171
    - Method Body 171
    - Working with Varargs 172
       > only parameter works these two ways: 01. walk1(int... nums) 02. walk2(int start, int... nums)
       > nums.length of walk2(1), walk2(1, 2), walk2(1,2,3), walk2(1, new int[] {4,5});
    - Applying Access Modifiers 173
       > private: only accessible within the same class
       > default(package-private): private and other classes in the same package
       > protected: default access and child classes
       > public: protected and classes in the other packages
    - Private Access 173
    - Default (Package Private) Access 175
       > Two different packages 1. Football and 2. Cricket, can access members to each other
    - Protected Access 176
       > Two different packages 1. Football and 2. Cricket can access members creating subclass to each other
    - Public Access 180
    - Designing Static Methods and Fields 181
        > count
    - Calling a Static Variable or Method 182
    - Static vs. Instance 183
       > static works inside instance block, does not work opposite
    - Static Variables 185
    - Static Initialization 186
    - Static Imports 187
    - Passing Data Among Methods 188
       > pass-by-value with example  > pass-by-reference with example stringBuilder() 
    - Overloading Methods 191
       > Everything other than the method signature/name can vary. example:(access modifiers, return type, parameter, exception).
       > must have a different type/no./sequence of parameters
       > varargs: fly(int... length) ex: fly(1,2,3) vs fly(int[] length) ex: fly(new int[] {1,2,3})
       > Autoboxing > Reference Types > Primitives
       > autoboxing and varargs come last when Java looks at overloaded methods.
    
    - Creating Constructors 196
       > special method, name as class name > no return type >when use this?
    - Default Constructor 197
       > included by java automatically but when?
    - Overloading Constructors 199
       > must have a different type/no./sequence of parameters
    - Final Fields 202
       > set value exactly once > while declaring or constructor
    - Order of Initialization 202
       > 4 rules(Super, Static(Variable, Block), Instance(Variable, Block), Constructor)
       > static method/object instantiate into instance block

    - Encapsulating Data 205
       > bundling data into the method  > making uncontrolled changes to my class
       > private data(properties) >public method( is(), get(), set(), update())
    - Creating Immutable Classes 207
       > another common technique like encapsulation
       > making classes immutable so they can not be changed at all
       > omit the setters, not getter  > constuctor  >only when object is constructed 
       > issue with stringBuilder() and how to stop get reference too > toString() example

    - Writing Simple Lambdas 208
       > functional programming  > anonymous method > data type 'boolean'
    - Lambda Example 209
       > find negative/positive number > String startwith NOT 'h' > age of panda greater 5years > animal can swim. (Code>Lambda_Code)
    - Lambda Syntax 211
       > (Animal a)-> {return a.canHop();} vs  a-> a.canHop();
       > print(()->true) 
       > print(a->a.startsWtih("test"));      > print((String a)->a.startsWtih("test"));
       > print((a,b)-> a.startsWith("test")); > print((String a, Sring b)-> a.startsWith("test"));
       > print((a,b)-> { int c =0; return 5; }

    - Predicates 214
       > what & why > functional interface > data type boolean > generics
       > Interface Predicate<T>{boolean test(T t);} > removeIf() >Arraylist<>()

    - Summary 215
    - Exam Essentials 216
    - Review Questions 218


############# Chapter 5 Class Design 233 ##########################

    - Introducing Class Inheritance 234
        > why >what Single/Multiple > No. of times extends a class
    - Extending a Class 235
        > how to Stop extending
    - Applying Class Access Modifiers 237
        > role of Default(package-private) in a file
    - Creating Java Objects 237
        > Object as Super Class/Object 
    - Defining Constructors 238
        > this() vs super() > default constructor > overloading 
        > understand compiler enhancement
        > non-argument/argument constructor in parent and child (Yes Vs Yes, No vs No, Yes vs No, No vs Yes)
        > reviewing 5-rules (
            -call with this() at first line, 
            -super() may not at first line, -no super()..? java will add non-argument one, 
            -If parent doesn’t have a no-argument constructor and the child doesn’t define any,  compiler will throw an error and try to insert a default no-argument
              constructor into the child class. 
            -If the parent doesn’t have a no-argument constructor, the compiler requires an explicit call to a parent constructor in each child constructor  ) 
        > calling constructor(this(),super())
    - Calling Inherited Class Members 244
        > directly/(optional)this(current and parent) vs super
    - Inheriting Methods 246
        > overriding and 4-rules for nonprivate method(Access Modifier(Same/Broader), Return type(Same/Coveriant), Signature(Same), Parameter(Same), Exception(No/Narrower/not-new)
        > overloading vs overriding
        > redeclaring private methods > hidding static method > overriding vs hidding
        > final keyword
    - Inheriting Variables 257
        > hidding 
    - Creating Abstract Classes 259
        > why? 
    - Defining an Abstract Class 260
        > can have only abstract method? > final, private, abstract keyword with method.
    - Creating a Concrete Class 262
    - Extending an Abstract Class 263
        > 5-rules for definition Abs. class ( cannot be instantiated, any number, including zero, of abstract and nonabstract methods, 
           not private/final,  inherits all of its abstract methods as its own abstract methods, first concrete class implements all abstract methods.)
        > 4-rules for definition Abs. method(defined in abstract classes only, non-private/no-final, not method body/implementation, same rules for overriding a method )
    - Implementing Interfaces 266
        > declare
    - Defining an Interface 267
        > 5-rules(cannot be instantiated, not required to have any methods,  not final, assumed to have public or default access, non-default methods are assumed abstract and public )
    - Inheriting an Interface 269
        > 2-rules(interface extends another interface, first concrete class must provide an implementation for all of the inherited abstract methods) 
        > class, interfaces and keywords
        > abstract methods and multiple interface
          ( method name = same, or same/different params/return type)
    - Interface Variables 273
        > assume always what?
    - Default Interface Methods 274
        > why?
        > 4-rules( only be declared within an interface ,must be marked with the default keyword,  not assumed to be static, final, or abstract, default method is assumed to be public)
        > default methods and multiple inheritance
             ( method name = same, or same/different params/return type
    - Static Interface Methods 278
        > 2-rules(static method is assumed to be public,  reference to the name of the interface must be used)
    - Understanding Polymorphism 279
        > defination & why? 
    - Object vs. Reference 281
        > 2-rules(object(properties exist within the object in memory.), reference(methods and variables areaccessible to the Java program)) 
        > parents' members also store in memory as obj?
    - Casting Objects 282
        > Grandparent, parent and child's property-access
        > 4-rules(super2sub explicite, sub2super, not-related compilation error, or exemption runtime, ) 
        > 2 examples of rule 4
    - Virtual Methods 284
    - Polymorphic Parameters 285
        > what,why and how with example? 
        > casting > creating method in parent/child/unrelated class
    - Polymorphism and Method Overriding 287

    - Summary 288
    - Exam Essentials 289
    - Review Questions 291


############# Chapter 6 Exceptions 299 ##########################

    - Understanding Exceptions 300
        > what
    - The Role of Exceptions 300
        > baby stand up itself > need help to stand up
    - Understanding Exception Types 302
        > object >throwable > check, uncheck & error
    - Throwing an Exception 304
        > throws vs throw
    - Using a try Statement 305
        > bracket 
    - Adding a finally Block 307
        > always execute  > try-catch-finally sequence
    - Catching Various Types of Exceptions 309
        > parent-child sequence
    - Throwing a Second Exception 311
        > parameter > free to declare any type
    - Recognizing Common Exception Types 313
    - Runtime Exceptions 314
        > unchecked(7examples) by JVM > program can not catch
    - Checked Exceptions 317
        > compile-time(2example) must handled > program can catch
    - Errors 317
        > 3 example by JVM > program can not catch
    - Calling Methods That Throw Exceptions 318
    - Subclasses 319
        > unreachable 
    - Printing an Exception 321
      > e > e.getMessage() > e.printStackTrace()

    - Summary 323
    - Exam Essentials 324
    - Review Questions 325
    - Appendix A Answers to Review Questions 333
