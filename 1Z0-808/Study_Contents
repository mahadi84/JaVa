
==================================================================================
 OCA(1Z0-808) Oracle Certified Associate Java SE 8 Programmer I Study Guide Exam
=================================================================================


############# Chapter 1 Java Building Blocks 1 ##########################

    - Understanding the Java Class Structure 2
    - Fields and Methods 2
    - Comments 4
    - Classes vs. Files 5
    - Writing a main() Method 6
    - Understanding Package Declarations and Imports 9
    - Wildcards 10
    - Redundant Imports 11
    - Naming Conflicts 12
    - Creating a New Package 13
    - Code Formatting on the Exam 16
    - Creating Objects 16
    - Constructors 17
    - Reading and Writing Object Fields 18
    - Instance Initializer Blocks 18
    - Order of Initialization 19
    - Distinguishing Between Object References and Primitives 20
    - Primitive Types 20
    - Reference Types 24
    - Key Differences 25
    - Declaring and Initializing Variables 25
    - Declaring Multiple Variables 26
    - Identifiers 27
    - Understanding Default Initialization of Variables 29
    - Local Variables 29
    - Instance and Class Variables 30
    - Understanding Variable Scope 31
    - Ordering Elements in a Class 34
    - Destroying Objects 36
    - Garbage Collection 36
    - finalize() 38
    - Benefits of Java 39
    - Summary 40
    - Exam Essentials 41
    - Review Questions 42xvi Contents


############# Chapter 2 Operators and Statements 51 ##########################

    - Understanding Java Operators 52
    - Working with Binary Arithmetic Operators 53
    - Arithmetic Operators 53
    - Numeric Promotion 55
    - Working with Unary Operators 57
    - Logical Complement and Negation Operators 57
    - Increment and Decrement Operators 58
    - Using Additional Binary Operators 60
    - Assignment Operators 60
    - Compound Assignment Operators 62
    - Relational Operators 63
    - Logical Operators 64
    - Equality Operators 65
    - Understanding Java Statements 66
    - The if-then Statement 67
    - The if-then-else Statement 68
    - The switch Statement 72
    - The while Statement 76
    - The do-while Statement 78
    - The for Statement 80
    - Understanding Advanced Flow Control 86
    - Nested Loops 87
    - Adding Optional Labels 87
    - The break Statement 88
    - The continue Statement 90
    - Summary 92
    - Exam Essentials 92
    - Review Questions 94


############# Chapter 3 Core Java APIs 101 ##########################

    - Creating and Manipulating Strings 102
    - Concatenation 102
    - Immutability 104
    - The String Pool 105
    - Important String Methods 105
    - Method Chaining 110
    - Using the StringBuilder Class 111
    - Mutability and Chaining 112
    - Creating a StringBuilder 113
    - Important StringBuilder Methods 114
    - StringBuilder vs. StringBuffer 117Contents xvii
    - Understanding Equality 117
    - Understanding Java Arrays 119
    - Creating an Array of Primitives 119
    - Creating an Array with Reference Variables 121
    - Using an Array 123
    - Sorting 124
    - Searching 125
    - Varargs 126
    - Multidimensional Arrays 126
    - Understanding an ArrayList 129
    - Creating an ArrayList 129
    - Using an ArrayList 130
    - Wrapper Classes 134
    - Autoboxing 136
    - Converting Between array and List 136
    - Sorting 138
    - Working with Dates and Times 138
    - Creating Dates and Times 138
    - Manipulating Dates and Times 142
    - Working with Periods 145
    - Formatting Dates and Times 148
    - Parsing Dates and Times 151
    - Summary 151
    - Exam Essentials 152
    - Review Questions 153


############# Chapter 4 Methods and Encapsulation 165 ##########################

    - Designing Methods 166
    - Optional Specifiers 168
       > static, abstract, final, synchronized, native, strictfp
    - Return Type 169
       > void return nothing but not restict.
    - Method Name 170
       > start with _, &,  A-Z, a-z
    - Parameter List 171
    - Optional Exception List 171
    - Method Body 171
    - Working with Varargs 172
       > only parameter works these two ways: 01. walk1(int... nums) 02. walk2(int start, int... nums)
       > nums.length of walk2(1), walk2(1, 2), walk2(1,2,3), walk2(1, new int[] {4,5});
    - Applying Access Modifiers 173
       > private: only accessible within the same class
       > default(package-private): private and other classes in the same package
       > protected: default access and child classes
       > public: protected and classes in the other packages
    - Private Access 173
    - Default (Package Private) Access 175
    - Protected Access 176
    - Public Access 180
    - Designing Static Methods and Fields 181
    - Calling a Static Variable or Method 182
        > count
    - Static vs. Instance 183
       > static works inside instance block, does not works opposite
    - Static Variables 185
    - Static Initialization 186
    - Static Imports 187
    - Passing Data Among Methods 188
       > pass-by-value with example  > pass-by-reference with example stringBuilder() 
    - Overloading Methods 191
       > Everything other than the method signature/name can vary. example:(access modifiers, return type, parameter, exception).
       > must have a different type/no./sequence of parameters
       > varargs: fly(int... length) ex: fly(1,2,3) vs fly(int[] length) ex: fly(new int[] {1,2,3})
       > Autoboxing > Reference Types > Primitives
       > autoboxing and varargs come last when Java looks at overloaded methods.
    
    - Creating Constructors 196
       > special method, name as class name > no return type >when use this?
    - Default Constructor 197
       > included by java automatically but when?
    - Overloading Constructors 199
       > must have a different type/no./sequence of parameters
    - Final Fields 202
       > set value exactly once > while declaring or constructor
    - Order of Initialization 202
       > 4 rules(Super, Static(Variable, Block), Instance(Variable, Block), Constructor)
       > static method/object instantiate into instance block
       > 

    - Encapsulating Data 205
       > bundling data into the method  > making uncontrolled changes to my class
       > private data(properties) >public method( is(), get(), set(), update())
    - Creating Immutable Classes 207
       > another common technique like encapsulation
       > making classes immutable so they can not be changed at all
       > omit the setters, not getter  > constuctor  >only when object is constructed 
       > issue with stringBuilder() and how to stop get reference too > toString() example

    - Writing Simple Lambdas 208
       > functional programming  > anonymous method > data type 'boolean'
    - Lambda Example 209
       > find negative/positive number > String startwith NOT 'h' > age of panda greater 5years > animal can swim. (Code>Lambda_Code)
    - Lambda Syntax 211
       > (Animal a)-> {return a.canHop();} vs  a-> a.canHop();
       > print(()->true) 
       > print(a->a.startsWtih("test"));      > print((String a)->a.startsWtih("test"));
       > print((a,b)-> a.startsWith("test")); > print((String a, Sring b)-> a.startsWith("test"));
       > print((a,b)-> { int c =0; return 5; }

    - Predicates 214
       > what & why > functional interface > data type boolean > generics
       > Interface Predicate<T>{boolean test(T t);} > removeIf() >Arraylist<>()

    - Summary 215
    - Exam Essentials 216
    - Review Questions 218


############# Chapter 5 Class Design 233 ##########################

    - Introducing Class Inheritance 234
        > why >what Single/Multiple > No. of times extends a class
    - Extending a Class 235
        > how to Stop extending
    - Applying Class Access Modifiers 237
        > role of Default(package-private) in a file
    - Creating Java Objects 237
        > Object as Super Class/Object 
    - Defining Constructors 238
        > this() vs super() > default constructor > overloading 
        > understand compiler enhancement
        > non-argument/argument constructor in parent and child (Yes Vs Yes, No vs No, Yes vs No, No vs Yes)
        > reviewing 5-rules > calling constructor
    - Calling Inherited Class Members 244
        > directly/(optional)this(current and parent) vs super
    - Inheriting Methods 246
        > overriding and 4-rules for nonprivate method > overloading vs overriding
        > redeclaring private methods > hidding static method > overriding vs hidding
        > final keyword
    - Inheriting Variables 257
        > hidding >
    - Creating Abstract Classes 259
        > why? 
    - Defining an Abstract Class 260
        > can have only abstract method? > final, private, abstract keyword with method.
    - Creating a Concrete Class 262
    - Extending an Abstract Class 263
        > 5-rules for definition Abs. class > 4-rules for definition Abs. method
    - Implementing Interfaces 266
        > declare
    - Defining an Interface 267
        > 5-rules
    - Inheriting an Interface 269
        > 2-rules > class, interfaces and keywords
        > abstract methods and multiple interface
          ( method name = same, or same/different params/return type)
    - Interface Variables 273
        > assume always what?
    - Default Interface Methods 274
        > why?
        > 4-rules
        > default methods and multiple inheritance
             ( method name = same, or same/different params/return type
    - Static Interface Methods 278
        > 2-rules
    - Understanding Polymorphism 279
        > defination & why? 
    - Object vs. Reference 281
        > 2-rules > parents members also store an obj?
    - Casting Objects 282
        > Grandparent, parent and child's property-access
        > 4-rules > 2 examples of rule 4
    - Virtual Methods 284
    - Polymorphic Parameters 285
        > what,why and how with example? 
        > casting > creating method in parent/child/unrelated class
    - Polymorphism and Method Overriding 287

    - Summary 288
    - Exam Essentials 289
    - Review Questions 291


############# Chapter 6 Exceptions 299 ##########################

    - Understanding Exceptions 300
      > what
    - The Role of Exceptions 300
      > baby stand up itself > need help to stand up
    - Understanding Exception Types 302
      > object >throwable > check, uncheck & error
    - Throwing an Exception 304
      > throws vs throw
    - Using a try Statement 305
      > bracket 
    - Adding a finally Block 307
      > always execute  > try-catch-finally sequence
    - Catching Various Types of Exceptions 309
      > parent-child sequence
    - Throwing a Second Exception 311
      > parameter > free to declare any type
    - Recognizing Common Exception Types 313
    - Runtime Exceptions 314
       > unchecked(7examples) by JVM > program can not catch
    - Checked Exceptions 317
        > compile-time(2example) must handled > program can catch
    - Errors 317
        > 3 example by JVM > program can not catch
    - Calling Methods That Throw Exceptions 318
    - Subclasses 319
      > unreachable 
    - Printing an Exception 321
      > e > e.getMessage() > e.printStackTrace()

    - Summary 323
    - Exam Essentials 324
    - Review Questions 325
    - Appendix A Answers to Review Questions 333
