
==================================================================================
 OCA(1Z0-808) Oracle Certified Associate Java SE 8 Programmer I Study Guide Exam
=================================================================================


############# Chapter 1 Java Building Blocks 1 ##########################

 - Understanding the Java Class Structure 2
    - Fields and Methods 2
    - Comments 4
         // comment until end of line OR  // // cat OR /* */ */
         /* Multiple Or /** Multiple
         * line comment
         */
    - Classes vs. Files 5
    - Writing a main() Method 6
    - Understanding Package Declarations and Imports 9
         > puts classes in packages. >logical groupings for classes.
    - Wildcards 10
         > import java.util.*; // imports java.util.Random among other things
         > compiler figures out what’s actually needed.
    - Redundant Imports 11
         > 'java.lang.' This package is special in that it is automatically imported.
         > how many of the imports do you  think are redundant?
            1: import java.lang.System;    2: import java.lang.*;
            3: import java.util.Random;    4: import java.util.*;
         > will compile without any issue
         
    - Naming Conflicts 12
         > When the class is found in multiple packages, Java gives you the compiler error:
         > implementations of java.util.Date and java.sql.Date
         > import java.util.*;   > import java.sql.*; // DOES NOT COMPILE
           >public class Conflicts { Date date;  // some more code } //compiler error:
         > What does Java do with “ties” for precedence?
           import java.util.Date;  import java.sql.Date;
          Ans: the compiler tells you: The import java.sql.Date collides with another import statement
    - Creating a New Package 13
         > packages to avoid naming conflicts and to reuse your code
         >C:\temp\packagea\ClassA.java
            package packagea;
            public class ClassA {    }
         >C:\temp\packageb\ClassB.java
            package packageb;
            import packagea.ClassA;
            public class ClassB {         
            ClassA a;
            }
    - Code Formatting on the Exam 16
    - Creating Objects 16
    - Constructors 17
    - Reading and Writing Object Fields 18
         >Swan mother = new Swan();
          mother.numberEggs = 1; // set variable
          System.out.println(mother.numberEggs); // read variable
    - Instance Initializer Blocks 18
    - Order of Initialization 19
         > Why below code DOES NOT COMPILE?
         { System.out.println(name); } // DOES NOT COMPILE
            private String name = "Fluffy";
         > What is the output of the following code? 
         public class Egg { public Egg() { number = 5; }
            public static void main(String[] args) {
            Egg egg = new Egg();
            System.out.println(egg.number);
            }
            private int number = 3;
            { number = 4; } 
         }
         
    - Distinguishing Between Object References and Primitives 20
    - Primitive Types 20
         > byte 8-bit(-2^7_to_2^7-1) integral value 123; short 16-bit; 
         > int 32-bit; long 64-bit; 
         > float 32-bit floating-point value 123.45f; 
         > double 64-bit floating-point value 123.456; 
         > boolean ; char 16-bit Unicode value 'a'

         > long max = 3123456789; // DOES NOT COMPILE
         > long max = 3123456789L; // now Java knows it is a long

         > double annoyingButLegal = 1_00_0.0_0; // this one compiles
         > double notByDecimal = 1000_.00; // DOES NOT COMPILE
    - Reference Types 24
         > A reference can be assigned to another object of the same type.
            String greeting = "How are you?";
         > A reference can be assigned to a new object using the new keyword.
            java.util.Date today=new java.util.Date();
         > An object in memory can be accessed only via a reference.

    - Key Differences 25
         > int value = null; // DOES NOT COMPILE > String s = null;
         > String reference = "hello";
            int len = reference.length();
            int bad = len.length(); // DOES NOT COMPILE
         > primitive name lowercase. classes name uppercase.
    - Declaring and Initializing Variables 25
         > int i1, i2, i3 = 0;> boolean b1, b2; > String s1 = "1", s2;   > double d1, double d2;
    - Declaring Multiple Variables 26
    - Identifiers 27
         > to name, including variables, methods, classes, and fields:
         > The name must begin with a letter or the symbol $ or _.
         > Subsequent characters may also be numbers.
         > You cannot use the same name as a Java reserved word. 
            Ex: __SStillOkbutKnotsonice$

    - Understanding Default Initialization of Variables 29
    - Local Variables 29
         > defined within a method, must be initialized before use
    - Instance and Class Variables 30
         > boolean false  >byte, short, int, long 0 (in the type’s bit-length)
         > float, double 0.0 (in the type’s bit-length) > char '\u0000' (NUL)
         > All object references (everything else) null
    - Understanding Variable Scope 31
         > Local variables—in scope from declaration to end of block
         > Instance variables—in scope from declaration until object garbage collected
         > Class variables—in scope from declaration until program ends
    - Ordering Elements in a Class 34
         > Package 
         > Import 
         > Class
         > Field declarations int value; No Anywhere inside a class
         > Method declarations void method() No Anywhere inside a class
    - Destroying Objects 36
         > objects are stored in program memory’s heap
         > eventually it will run out of memory.
         > a garbage collector to automatically look for objects that aren’t needed anymore.
    - Garbage Collection 36
         > System.gc() is not guaranteed to run
         > An object is no longer reachable when one of two situations occurs:
           >The object no longer has any references pointing to it.
           >All references to the object have gone out of scope.
         > object first becomes eligible for garbage collection:
           public class Scope {
               public static void main(String[] args) {
               String one, two;
               one = new String("a");
               two = new String("b");
               one = two;
               String three = one;
               one = null;
               } 
            }
         Ans: one,two,three = "b"
    - finalize() 38
         > might run zero or one time. twice=impossible.
            public class Finalizer {
               private static List objects = new ArrayList();
               protected void finalize() {
               objects.add(this); // Don't do this
               } 
            }
    - Benefits of Java 39
         > Object Oriented(allows for functional programming as well) > Encapsulation 
         > Platform Independent  > Robust > Simple > Secure
    
    - Summary 40
    - Exam Essentials 41
    - Review Questions 42


############# Chapter 2 Operators and Statements 51 ##########################

    - Understanding Java Operators 52
    - Working with Binary Arithmetic Operators 53
    - Arithmetic Operators 53
    - Numeric Promotion 55
    - Working with Unary Operators 57
    - Logical Complement and Negation Operators 57
    - Increment and Decrement Operators 58
    - Using Additional Binary Operators 60
    - Assignment Operators 60
    - Compound Assignment Operators 62
    - Relational Operators 63
    - Logical Operators 64
    - Equality Operators 65
    - Understanding Java Statements 66
    - The if-then Statement 67
    - The if-then-else Statement 68
    - The switch Statement 72
    - The while Statement 76
    - The do-while Statement 78
    - The for Statement 80
    - Understanding Advanced Flow Control 86
    - Nested Loops 87
    - Adding Optional Labels 87
    - The break Statement 88
    - The continue Statement 90
    - Summary 92
    - Exam Essentials 92
    - Review Questions 94


############# Chapter 3 Core Java APIs 101 ##########################

    - Creating and Manipulating Strings 102
        > String fundamental class > with new without new
    - Concatenation 102
        > 1+2+"c"    > String s= "1"; s+="2"; s+=3; 
        > String s1= "1"; String s2= s1.concat("2");  s2.concat("3"); OUTPUT:12
    - Immutability 104
        > String is non-changeable, make non-larger or non-smaller
    - The String Pool 105
        > location in java virtual machine that collect all strings > garbage collectible 
    - Important String Methods 105
        01. charAt() 02. indexOf() 03. lastIndexOf() 04. substring()
        05. replace() 06. concat() 07. contains() 08. equals() 09. equalsIgnoreCase()
        10. startsWith()  11. endsWith()  12. toUpperCase() 13. toLowerCase()
        14. toCharArray()  15. valueOf()
    - Method Chaining 110
        > String a= "abc"; String b= a.toUpperCase(); b= b.replace("B", "2").replace('C', '3');
    - Using the StringBuilder Class 111
        >Mutable
        > StringBuilder sb = new StringBuilder("start"); sb.append("+middle"); 
        > StringBuilder same = sb.append("+end"); // "start+middle+end"
    - Mutability and Chaining 112
    - Creating a StringBuilder 113
        >StringBuilder sb1 = new StringBuilder(); StringBuilder sb2 = new StringBuilder("animal"); StringBuilder sb3 = new StringBuilder(10);
    - Important StringBuilder Methods 114
        01. charAt() 02. indexOf() 03. lastIndexOf() 04. substring()
        05. append() 06. insert() 07. delete() 08. deleteCharAt() 09. reverse() 10. toString()
    - StringBuilder vs. StringBuffer 117
        > newer-older >faster-slower
    - Understanding Equality 117
        > String x = "Hello World"; String z = " Hello World".trim(); 
        > System.out.println(x == z); // false > System.out.println(x.equals(z)); // true
    - Understanding Java Arrays 119
        > Special variable > store multiple same type of data
    - Creating an Array of Primitives 119
        > int[] iA= new int[1];  //[tray icon, indicate an array]      
    - Creating an Array with Reference Variables 121
        > String [] bugs = { "cricket", "beetle", "ladybug" };
        > String [] alias = bugs;
          >System.out.println(bugs.equals(alias)); // true
          >System.out.println(bugs.toString()); // [Ljava.lang.String;@160bc7c0
       > Object[] objects= bugs;
       > String[] againStrings = (String[]) objects;
    - Using an Array 123
       > String[] birds = new String[6]; System.out.println(birds.length); //print all 6 elements of the array are null.
    - Sorting 124
       > Unsorted array, A surprise—this result isn’t predictable
       > String[] strings = { "10", "9", "100" }; Arrays.sort(strings); //outputs 10 100 9.
    - Searching 125
      > int[] numbers = {2,4,6,8}; 
      > System.out.println(Arrays.binarySearch(numbers, 2)); // 0
      > System.out.println(Arrays.binarySearch(numbers, 1)); // -1
    - Varargs 126
    - Multidimensional Arrays 126
        > int[] iA= new int[1];  //[tray icon, indicate an array]
        > char[][] cA2= {{'A', 'B', 'C'}, {'D', 'E', 'F'}}; //table with 2 rows and 3 columns
        > char[][] cA= new char[no_of_rows][no_of_cols];
        > int[][][] building = new int[no_of_floors][no_of_rows][no_of_column/rooms]; 
    - Understanding an ArrayList 129
    - Creating an ArrayList 129
    - Using an ArrayList 130
         01. add()  02. get() 03.set() 04. size() and  isEmpty() 
         05. remove() 06. removeOf()  07. clear()  08. contains()  09. equals()
    - Wrapper Classes 134
       > Each 8 primitive type has a wrapper class
       >Example of constructing
         > new Boolean(true),new Byte((byte) 1),new Short((short) 1),new Integer(1),
         > new Long(1),new Float(1.0),new Double(1.0),new Character('c'),
       > Converting String to primitive: Boolean.parseBoolean("true"); Byte.parseByte("1");
       > Converting String to  wrapper class:   Boolean.valueOf("TRUE"); Byte.valueOf("2");
    - Autoboxing 136
       >List<Double> weights = new ArrayList<>();
           > weights.add(50.5); // [50.5]  > weights.add(new Double(60)); // [50.5, 60.0]
    - Converting Between array and List 136
         >  String[] array = { "hawk", "robin" };  List<String> list = Arrays.asList(array); list.size();

         > List<String> list = new ArrayList<>();  list.add("hawk"); list.add("robin");
             > Object[] objectArray = list.toArray();  String[] stringArray = list.toArray(new String[0]); stringArray.length;
        
    - Sorting 138
         > List<Integer> numbers = new ArrayList<>(); numbers.add(99); numbers.add(5); numbers.add(81); 
         > Collections.sort(numbers); Output:[5, 81, 99]
    - Working with Dates and Times 138
        
    - Creating Dates and Times 138
         > LocalDate: Contains just a date >LocalDateTime Contains both a date and time but no time zone.
         > System.out.println(LocalDate/LocalTime/LocalDateTime.now());
    - Manipulating Dates and Times 142
         > LocalDate date = LocalDate.now(); > System.out.println(date); // 2024-01-20
         > date = date.plusDays/Weeks/Months/Years(2); > System.out.println(date); // 2024-01-22
    - Working with Periods 145
         >LocalDate date = LocalDate.of(2015, 1, 20);  Period period = Period.ofMonths(1); System.out.println(date.plus(period)); // 2015-02-20
        > LocalTime time = LocalTime.of(6, 15);  LocalDateTime dateTime = LocalDateTime.of(date, time); System.out.println(dateTime.plus(period)); // 2015-02-20T06:15

    - Formatting Dates and Times 148
        > LocalDate date = LocalDate.of(2020, Month.JANUARY, 20); LocalTime time = LocalTime.of(11, 12, 34);
        > LocalDateTime dateTime = LocalDateTime.of(date, time);
        > DateTimeFormatter f = DateTimeFormatter.ofPattern("MMMM dd, yyyy, hh:mm"); System.out.println(dateTime.format(f)); // January 20, 2020, 11:12
    - Parsing Dates and Times 151
        > DateTimeFormatter f = DateTimeFormatter.ofPattern("MM dd yyyy");  LocalDate date = LocalDate.parse("01 02 2015", f);
        > LocalTime time = LocalTime.parse("11:22");
             >System.out.println(date); // 2015-01-02
             >System.out.println(time); // 11:22

    - Summary 151
    - Exam Essentials 152
    - Review Questions 153


############# Chapter 4 Methods and Encapsulation 165 ##########################

    - Designing Methods 166
    - Optional Specifiers 168
       > static, abstract, final, synchronized, native, strictfp
    - Return Type 169
       > void return nothing but not restict.
    - Method Name 170
       > start with _, &,  A-Z, a-z
    - Parameter List 171
    - Optional Exception List 171
    - Method Body 171
    - Working with Varargs 172
       > only parameter works these two ways: 01. walk1(int... nums) 02. walk2(int start, int... nums)
       > nums.length of walk2(1), walk2(1, 2), walk2(1,2,3), walk2(1, new int[] {4,5});
    - Applying Access Modifiers 173
       > private: only accessible within the same class
       > default(package-private): private and other classes in the same package
       > protected: default access and child classes
       > public: protected and classes in the other packages
    - Private Access 173
    - Default (Package Private) Access 175
       > Two different packages 1. Football and 2. Cricket, can access members to each other
    - Protected Access 176
       > Two different packages 1. Football and 2. Cricket can access members creating subclass to each other
    - Public Access 180
    - Designing Static Methods and Fields 181
        > count
    - Calling a Static Variable or Method 182
    - Static vs. Instance 183
       > static works inside instance block, does not work opposite
    - Static Variables 185
    - Static Initialization 186
    - Static Imports 187
    - Passing Data Among Methods 188
       > pass-by-value with example  > pass-by-reference with example stringBuilder() 
    - Overloading Methods 191
       > Everything other than the method signature/name can vary. example:(access modifiers, return type, parameter, exception).
       > must have a different type/no./sequence of parameters
       > varargs: fly(int... length) ex: fly(1,2,3) vs fly(int[] length) ex: fly(new int[] {1,2,3})
       > Autoboxing > Reference Types > Primitives
       > autoboxing and varargs come last when Java looks at overloaded methods.
    
    - Creating Constructors 196
       > special method, name as class name > no return type >when use this?
    - Default Constructor 197
       > included by java automatically but when?
    - Overloading Constructors 199
       > must have a different type/no./sequence of parameters
    - Final Fields 202
       > set value exactly once > while declaring or constructor
    - Order of Initialization 202
       > 4 rules(Super, Static(Variable, Block), Instance(Variable, Block), Constructor)
       > static method/object instantiate into instance block

    - Encapsulating Data 205
       > bundling data into the method  > making uncontrolled changes to my class
       > private data(properties) >public method( is(), get(), set(), update())
    - Creating Immutable Classes 207
       > another common technique like encapsulation
       > making classes immutable so they can not be changed at all
       > omit the setters, not getter  > constuctor  >only when object is constructed 
       > issue with stringBuilder() and how to stop get reference too > toString() example

    - Writing Simple Lambdas 208
       > functional programming  > anonymous method > data type 'boolean'
    - Lambda Example 209
       > find negative/positive number > String startwith NOT 'h' > age of panda greater 5years > animal can swim. (Code>Lambda_Code)
    - Lambda Syntax 211
       > (Animal a)-> {return a.canHop();} vs  a-> a.canHop();
       > print(()->true) 
       > print(a->a.startsWtih("test"));      > print((String a)->a.startsWtih("test"));
       > print((a,b)-> a.startsWith("test")); > print((String a, Sring b)-> a.startsWith("test"));
       > print((a,b)-> { int c =0; return 5; }

    - Predicates 214
       > what & why > functional interface > data type boolean > generics
       > Interface Predicate<T>{boolean test(T t);} > removeIf() >Arraylist<>()

    - Summary 215
    - Exam Essentials 216
    - Review Questions 218


############# Chapter 5 Class Design 233 ##########################

    - Introducing Class Inheritance 234
        > why >what Single/Multiple > No. of times extends a class
    - Extending a Class 235
        > how to Stop extending
    - Applying Class Access Modifiers 237
        > role of Default(package-private) in a file
    - Creating Java Objects 237
        > Object as Super Class/Object 
    - Defining Constructors 238
        > this() vs super() > default constructor > overloading 
        > understand compiler enhancement
        > non-argument/argument constructor in parent and child (Yes Vs Yes, No vs No, Yes vs No, No vs Yes)
        > reviewing 5-rules (
            -call with this() at first line, 
            -super() may not at first line, -no super()..? java will add non-argument one, 
            -If parent doesn’t have a no-argument constructor and the child doesn’t define any,  compiler will throw an error and try to insert a default no-argument
              constructor into the child class. 
            -If the parent doesn’t have a no-argument constructor, the compiler requires an explicit call to a parent constructor in each child constructor  ) 
        > calling constructor(this(),super())
    - Calling Inherited Class Members 244
        > directly/(optional)this(current and parent) vs super
    - Inheriting Methods 246
        > overriding and 4-rules for nonprivate method(Access Modifier(Same/Broader), Return type(Same/Coveriant), Signature(Same), Parameter(Same), Exception(No/Narrower/not-new)
        > overloading vs overriding
        > redeclaring private methods > hidding static method > overriding vs hidding
        > final keyword
    - Inheriting Variables 257
        > hidding 
    - Creating Abstract Classes 259
        > why? 
    - Defining an Abstract Class 260
        > can have only abstract method? > final, private, abstract keyword with method.
    - Creating a Concrete Class 262
    - Extending an Abstract Class 263
        > 5-rules for definition Abs. class ( cannot be instantiated, any number, including zero, of abstract and nonabstract methods, 
           not private/final,  inherits all of its abstract methods as its own abstract methods, first concrete class implements all abstract methods.)
        > 4-rules for definition Abs. method(defined in abstract classes only, non-private/no-final, not method body/implementation, same rules for overriding a method )
    - Implementing Interfaces 266
        > declare
    - Defining an Interface 267
        > 5-rules(cannot be instantiated, not required to have any methods,  not final, assumed to have public or default access, non-default methods are assumed abstract and public )
    - Inheriting an Interface 269
        > 2-rules(interface extends another interface, first concrete class must provide an implementation for all of the inherited abstract methods) 
        > class, interfaces and keywords
        > abstract methods and multiple interface
          ( method name = same, or same/different params/return type)
    - Interface Variables 273
        > assume always what?
    - Default Interface Methods 274
        > why?
        > 4-rules( only be declared within an interface ,must be marked with the default keyword,  not assumed to be static, final, or abstract, default method is assumed to be public)
        > default methods and multiple inheritance
             ( method name = same, or same/different params/return type
    - Static Interface Methods 278
        > 2-rules(static method is assumed to be public,  reference to the name of the interface must be used)
    - Understanding Polymorphism 279
        > defination & why? 
    - Object vs. Reference 281
        > 2-rules(object(properties exist within the object in memory.), reference(methods and variables areaccessible to the Java program)) 
        > parents' members also store in memory as obj?
    - Casting Objects 282
        > Grandparent, parent and child's property-access
        > 4-rules(super2sub explicite, sub2super, not-related compilation error, or exemption runtime, ) 
        > 2 examples of rule 4
    - Virtual Methods 284
    - Polymorphic Parameters 285
        > what,why and how with example? 
        > casting > creating method in parent/child/unrelated class
    - Polymorphism and Method Overriding 287

    - Summary 288
    - Exam Essentials 289
    - Review Questions 291


############# Chapter 6 Exceptions 299 ##########################

    - Understanding Exceptions 300
        > what
    - The Role of Exceptions 300
        > baby stand up itself > need help to stand up
    - Understanding Exception Types 302
        > object >throwable > check, uncheck & error
    - Throwing an Exception 304
        > throws vs throw
    - Using a try Statement 305
        > bracket 
    - Adding a finally Block 307
        > always execute  > try-catch-finally sequence
    - Catching Various Types of Exceptions 309
        > parent-child sequence
    - Throwing a Second Exception 311
        > parameter > free to declare any type
    - Recognizing Common Exception Types 313
    - Runtime Exceptions 314
        > unchecked(7examples) by JVM > program can not catch
    - Checked Exceptions 317
        > compile-time(2example) must handled > program can catch
    - Errors 317
        > 3 example by JVM > program can not catch
    - Calling Methods That Throw Exceptions 318
    - Subclasses 319
        > unreachable 
    - Printing an Exception 321
      > e > e.getMessage() > e.printStackTrace()

    - Summary 323
    - Exam Essentials 324
    - Review Questions 325
    - Appendix A Answers to Review Questions 333
