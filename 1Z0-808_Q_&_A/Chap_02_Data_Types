Very Easy.


*** যদি আমি "Data Type" না জানি, তাহলে আমি কী কী সমস্যার সম্মুখীন হব?

==========================  কিছু প্রশ্ন, যা আপনাকে গভীরভাবে চিন্তা করতে সাহায্য করবে: ========================================

১.  কম্পিউটার কীভাবে বুঝবে যে মেমোরিতে কতটুকু জায়গা একটি নির্দিষ্ট (integer, floating-point number) মানের জন্য বরাদ্দ করতে হবে?
    যদি প্রতিটি ভেরিয়েবলের জন্য সবচেয়ে উপযুক্ত আকারের মেমরি বরাদ্দ করা না হয়, তাহলে কি মেমরির অপচয় হবে না এবং প্রোগ্রাম (performance) ধীর হয়ে যাবে না?
২.  যদি আপনি দুটি সংখ্যা যোগ করতে চান, কম্পিউটার কীভাবে বুঝবে যে এটি গাণিতিক যোগ হবে নাকি দুটি অক্ষর বা স্ট্রিং-কে একসাথে যুক্ত করা হবে?
৩.  আপনি কীভাবে এই (যেমন সংখ্যা, অক্ষর, সত্য/মিথ্যা (true/false)) বিভিন্ন ডেটাগুলোকে আলাদাভাবে চিহ্নিত করবেন এবং তাদের উপর বিভিন্ন অপারেশন চালাবেন?



=================================================================================================
*** "Number" is an abstract class: (java.lang.Number) that serves as the superclass for all numeric wrapper classes.
         -Long (and all the other numeric wrapper classes) inherit from the Number class.


-----------------------------------------------------------------------------------------
Data Type   | Size (bits) |	Default Value     | Range
-----------------------------------------------------------------------------------------
boolean     |	1       |	false             |	true or false
byte        |	8       |	0                 | -2^7  to 2^7-1)
char        |	16      |'\u0000'(null character) | 0 to 65,535 (Unicode code points)
short       |	16      |	0                 | -2^15 to 2^15 - 1 .
int         |	32	|       0                 | -2^31 to 2^31 - 1.
long        |	64      |	0                 | -2^63 to 2^63-1
float       |	32      |	0.0f              | Approximately ±3.4E-38 to ±3.4E+38
double      |	64      |	0.0d              | Approximately ±1.7E-308 to ±1.7E+308
------------------------------------------------------------------------------------------
how to convert short to int and vise-versa in java?
  ->short to int (Widening Conversion)
                        short myShort = 32767; // Maximum value a short can hold
                        int myInt = myShort;   // Implicit conversion (widening)
                        // Explicit cast (not really necessary in this direction, but good to know)
                        myInt = (int) myShort;
                        System.out.println(myInt); // Output: 32767 (same result)

 ->int to short (Narrowing Conversion)
                        int myInt = 65000;  // A value larger than a short can hold
                        short myShort = (short) myInt; // Explicit cast (narrowing)


======================================= # Chapter Summary: Java Fundamentals - Variables, Data Types, and Object Basics =======================================

This chapter covers essential Java concepts including:
1. - Variable declarations and initialization
2. - Primitive Data types, Reference Data types and why wrapper classes?
3. - Object creation and garbage collection
4. - Scope and initialization of variables
5. - Basic class structure and constructors

## Key Concepts to Master

### 1. Variable Declarations
- Valid variable names: start with letter/underscore/$ (not number), case-sensitive
- Multiple variables can be declared on one line (but must be same type)
- Local variables must be initialized/parameterised before use (no default values)
- Instance variables get default values (0, false, null)
- An instance "final" variable must be initialized either at the point of declaration or within every constructor of the class.
- A static "final" variable (which acts as a class-level constant) must be initialized either at the point of declaration or within a static initialization block.
   - Spot invalid declarations (mixed types, invalid names)
   - Know where variables can be accessed (scope rules)


### 2. Primitive Types and Wrappers
- 8 primitive types: byte, short, int, long, float, double, char, boolean
- Wrapper classes: to treat  primitive values as objects. Collections(List, ArrayList, HashMap, HashSet, LinkedList) ) and APIs 
            Ex: Byte, Short, Integer, Long, Float, Double, Character, Boolean
- Autoboxing automatically converts between primitives and wrappers
- Special cases: char → Character, int → Integer

### 3. Object Basics
- `new` keyword creates objects
- Objects become eligible for garbage collection when unreachable
- `finalize()` method (deprecated) runs before GC but timing unpredictable
- Constructor basics: same name as class, no return type, all access modifier usable


## Exam Preparation Strategy

1.  Primitive vs Wrapper:
   - Recognize valid conversions
   - Know method calling limitations (primitives vs objects)
   - Understand autoboxing behavior

                public class ConversionExample {
                        public static void main(String[] args) {
                            // Primitive types
                            int primitiveInt = 10;
                            char primitiveChar = 'A';
                    
                            // AutoBoxing/Boxing   (Primitive to Wrapper)
                            Integer wrapperInt = primitiveInt; // int to Integer
                            Character wrapperChar = primitiveChar; // char to Character
                    
                            // AutoUnboxing/ Unboxing (Wrapper to Primitive)
                            int newPrimitiveInt = wrapperInt; // Integer to int
                         Or int newPrimtiveInt= wrapperInt.intValue(10);
                         Or int newPrimtiveInt= new Integer(10);
                         Or int first = Integer.parseInt("10");
                            char newPrimitiveChar = wrapperChar; // Character to char
                    
                            // Explicit conversion (old way, still valid)
                            Integer explicitWrapperInt = Integer.valueOf(50); // Explicit boxing
                            int explicitPrimitiveInt = explicitWrapperInt.intValue(); // Explicit unboxing
                            }
                }


2. Object Lifecycle and Initialization Order:
   - Identify when objects become eligible for GC
            -সহজ কথায়, যখন কোনো ভেরিয়েবল বা ডেটা স্ট্রাকচার সেই অবজেক্টটিকে আর "ধরে" থাকে না, তখন সেটিকে GC দ্বারা মেমরি থেকে সরানো যেতে পারে।
        প্রধান পরিস্থিতি যেখানে অবজেক্ট GC-এর জন্য যোগ্য হয়:
            -রেফারেন্স null করা: যখন একটি অবজেক্টের রেফারেন্স null সেট করা হয়।
            -নতুন অবজেক্টে রেফারেন্স অ্যাসাইন করা: যখন একটি ভেরিয়েবল একটি নতুন অবজেক্টকে রেফার করে, তখন পূর্ববর্তী অবজেক্টটি (যদি এটির আর কোনো রেফারেন্স না থাকে) GC-এর জন্য যোগ্য হয়।
            -স্কোপের বাইরে যাওয়া: যখন একটি মেথড শেষ হয় এবং সেই মেথডের মধ্যে তৈরি স্থানীয় (local) অবজেক্টগুলির আর কোনো রেফারেন্স থাকে না।
            -অনাম্য অবজেক্ট (Island of Isolation): যখন দুটি বা ততোধিক অবজেক্ট শুধুমাত্র একে অপরকে রেফার করে কিন্তু কোনো সক্রিয় রেফারেন্স দ্বারা তাদের অ্যাক্সেস করা যায় না।
   - Understand constructor basics
   - Know initialization order (- static → instance → constructor)
        ইনিশিয়েলাইজেশন অর্ডার (একটি ক্লাসের ইনস্ট্যান্স তৈরির সময়):
            -প্যারেন্ট ক্লাসের স্ট্যাটিক মেম্বার: প্রথমে প্যারেন্ট ক্লাসের (যদি থাকে) স্ট্যাটিক ভেরিয়েবল এবং স্ট্যাটিক ইনিশিয়ালাইজার ব্লকগুলো ইনিশিয়েলাইজ হয়।
            -কারেন্ট ক্লাসের স্ট্যাটিক মেম্বার: এরপর বর্তমান ক্লাসের স্ট্যাটিক ভেরিয়েবল এবং স্ট্যাটিক ইনিশিয়ালাইজার ব্লকগুলো ইনিশিয়েলাইজ হয়। (১ ও ২ ধাপ শুধুমাত্র একবার ঘটে, যখন ক্লাসটি প্রথম JVM দ্বারা লোড হয়।)
            -প্যারেন্ট ক্লাসের ইনস্ট্যান্স মেম্বার: এরপর প্যারেন্ট ক্লাসের (যদি থাকে) ইনস্ট্যান্স ভেরিয়েবল এবং ইনস্ট্যান্স ইনিশিয়ালাইজার ব্লকগুলো ইনিশিয়েলাইজ হয়, তাদের ঘোষণার ক্রম অনুযায়ী।
            -প্যারেন্ট ক্লাসের কনস্ট্রাকটর: তারপর প্যারেন্ট ক্লাসের কনস্ট্রাকটর এক্সিকিউট হয়। (প্রতিটি কনস্ট্রাকটরের প্রথম লাইন হিসেবে super() (যদি না দেওয়া হয়) স্বয়ংক্রিয়ভাবে প্যারেন্ট ক্লাসের কনস্ট্রাকটরকে কল করে।)
            -কারেন্ট ক্লাসের ইনস্ট্যান্স মেম্বার: এরপর বর্তমান ক্লাসের ইনস্ট্যান্স ভেরিয়েবল এবং ইনস্ট্যান্স ইনিশিয়ালাইজার ব্লকগুলো ইনিশিয়েলাইজ হয়, তাদের ঘোষণার ক্রম অনুযায়ী।
            -কারেন্ট ক্লাসের কনস্ট্রাকটর: পরিশেষে, বর্তমান ক্লাসের কনস্ট্রাকটর এক্সিকিউট হয়।

3. Code Analysis:
   - Practice tracing code execution
   - Watch for common pitfalls (uninitialized variables, etc.)
   - Learn to identify compilation errors vs runtime behavior



## জাভার সাধারণ কিছু ভুল (Pitfalls) যা মনে রাখা দরকার:

- Variable declarations and initialization
- Primitive Data types, Reference Data types and why wrapper classes?
- Object creation and garbage collection
- Scope and initialization of variables
- Basic class structure and constructors

### ১. ভেরিয়েবল ঘোষণা (Declaration) এবং ইনিশিয়ালাইজেশন (Initialization)
* বিভিন্ন টাইপের ভেরিয়েবল একই লাইনে: আপনি একই লাইনে বিভিন্ন টাইপের ভেরিয়েবল ঘোষণা করতে পারবেন না (যেমন: `int x, double y;` এটি ভুল)।
* লোকাল ভেরিয়েবলের ইনিশিয়ালাইজেশন: মেথডের ভিতরে ঘোষণা করা লোকাল ভেরিয়েবলগুলোকে ব্যবহারের আগে অবশ্যই ইনিশিয়ালাইজ (মান দিতে হবে) করতে হবে or must parametarize। এগুলোতে স্বয়ংক্রিয়ভাবে কোনো ডিফল্ট মান বসে না।
* ডিফল্ট মান (Default Values): ইনস্ট্যান্স (instance) এবং স্ট্যাটিক (static) ভেরিয়েবলগুলোতে স্বয়ংক্রিয়ভাবে ডিফল্ট মান বসে (যেমন: সংখ্যা টাইপের জন্য `0`, বুলিয়ানের জন্য `false`, `String` এর মতো অবজেক্টের জন্য `null`)।

### ২. নামকরণের নিয়ম (Naming Conventions) এবং আইডেন্টিফায়ার (Identifiers)
* ভেরিয়েবলের নাম: সংখ্যার দিয়ে শুরু হতে পারে না। অক্ষর, সংখ্যা, `_` (আন্ডারস্কোর) এবং `$` (ডলার সাইন) ব্যবহার করা যায়।
* ক্লাসের নাম: PascalCase নিয়ম মেনে চলতে হবে (যেমন: `MyClass`)। সংখ্যার দিয়ে শুরু হতে পারে না।
* কিবোর্ড (Keywords) ব্যবহার: জাভার রিজার্ভড কিবোর্ডগুলো (যেমন: `int`, `public`, `class`) ভেরিয়েবল, মেথড বা ক্লাসের নাম হিসেবে ব্যবহার করা যাবে না।
* কেস সেন্সিটিভিটি (Case Sensitivity): জাভা কেস-সেন্সিটিভ! `int`, `Int` এবং `Integer` ভিন্ন জিনিস।

### ৩. প্রিমিটিভ (Primitives) বনাম র‍্যাপার ক্লাস (Wrapper Classes)
* প্রিমিটিভে মেথড কল করা যায় না: আপনি সরাসরি প্রিমিটিভ টাইপের উপর মেথড কল করতে পারবেন না (যেমন: `int.toString()` কম্পাইল হবে না)।
* র‍্যাপার ক্লাসের নাম: কিছু র‍্যাপার ক্লাসের নাম তাদের প্রিমিটিভের নামের থেকে ভিন্ন (যেমন: `int` এর র‍্যাপার `Integer`, `char` এর র‍্যাপার `Character`)।
* প্রিমিটিভের জন্য `null`: প্রিমিটিভ ভেরিয়েবল `null` মান ধারণ করতে পারে না। শুধুমাত্র অবজেক্ট রেফারেন্স (যেমন: `Integer` বা `String` এর মতো র‍্যাপার ক্লাস) `null` হতে পারে।
* অটোবক্সিং/আনবক্সিং (Autoboxing/Unboxing): 
    -জাভা কখন স্বয়ংক্রিয়ভাবে প্রিমিটিভ এবং তাদের র‍্যাপার ক্লাসের মধ্যে রূপান্তর করে তা জেনে রাখুন (যেমন: `Integer x = 5;` হলো অটোবক্সিং, `int y = new Integer(10);` হলো আনবক্সিং)। 
    -`parseInt()/intValue()` একটি প্রিমিটিভ ফিরিয়ে দেয়; `valueOf()` একটি র‍্যাপার অবজেক্ট ফিরিয়ে দেয়।
    - intValue() সংখ্যাবাচক র‍্যাপার অবজেক্ট (যেমন Integer, Double, Float, Long, Byte, Short) এর মানকে একটি প্রিমিটিভ int ডেটা টাইপে রূপান্তর করতে ব্যবহৃত হয়।
        Integer myInteger = new Integer(123);
        int primitiveInt = myInteger.intValue(); // Integer অবজেক্টকে int এ রূপান্তর করে

### ৪. সংখ্যা এবং লিটারেল (Literals)
* ফ্লোটিং-পয়েন্টের ডিফল্ট: দশমিক সংখ্যা (যেমন: `3.14`) স্বয়ংক্রিয়ভাবে `double` টাইপের হয়। এটিকে `float` করতে হলে `f` বা `F` যুক্ত করতে হবে (যেমন: `3.14f`)।
* লিটারেলের আন্ডারস্কোর: সংখ্যার মাঝখানে আন্ডারস্কোর ব্যবহার করা যায় (যেমন: `1_000_000`) কিন্তু শুরুতে, শেষে বা দশমিকের পাশে ব্যবহার করা যায় না (যেমন: `_123`, `123_`, `1._23` এগুলো ভুল)।
[***]Literals (লিটারেলস) হলো প্রোগ্রামিং কোডে সরাসরি ব্যবহৃত নির্দিষ্ট, অপরিবর্তনশীল মান। এগুলি ডেটার নির্দিষ্ট ধরনকে (যেমন: সংখ্যা, অক্ষর, স্ট্রিং, বুলিয়ান) প্রকাশ করে। 
     -সহজ কথায়, যখন আপনি কোডে কোনো মান (যেমন: case 21:, case "hello":, case true:, case null:) সরাসরি লেখেন, সেটিই একটি Literal।


    #### ৪.১-`float` এবং `double` উভয়ই ফ্লোটিং-পয়েন্ট (দশমিক) সংখ্যা ডেটা টাইপ। তাদের মধ্যে প্রধান পার্থক্য হলো তাদের প্রিসিশন (precision) বা নির্ভুলতা এবং মেমরি ব্যবহার।
        ### `float` ডেটা টাইপ
          * ব্যবহার: যখন মেমরি সংরক্ষণ একটি গুরুত্বপূর্ণ বিষয় হয় এবং উচ্চ নির্ভুলতা প্রয়োজন হয় না, যেমন - গ্রাফিক্স প্রোগ্রামিং বা হালকা গেম ডেভেলপমেন্ট।
                    - মেমরি খুবই সীমিত এবং সামান্য নির্ভুলতার ক্ষতি মেনে নেওয়া যায় (যেমন, কিছু গ্রাফিক্স অ্যাপ্লিকেশন, এমবেডেড সিস্টেম)।
                    = আপনি অনেক ফ্লোটিং-পয়েন্ট সংখ্যা সংরক্ষণ করছেন এবং মেমরি দক্ষতা একটি মূল বিষয়।
          * লিটারেল (Literal): `float` লিটারেল লেখার সময় সংখ্যার শেষে `f` অথবা `F` যোগ করা আবশ্যক। কারণ জাভা ডিফল্টভাবে যেকোনো দশমিক সংখ্যাকে `double` হিসেবে ধরে নেয়।
            উদাহরণ (float):
                float myFloat = 3.14f; // 'f' বা 'F' যোগ করা আবশ্যক
                float anotherFloat = 123.456789f; // 7 দশমিক স্থান পর্যন্ত নির্ভুলতা
                float smallFloat = 0.00000012345f;
                float f = 5f;
        
        ### `double` ডেটা টাইপ
          * ব্যবহার: যখন উচ্চ নির্ভুলতা অপরিহার্য, যেমন - বৈজ্ঞানিক গণনা, আর্থিক অ্যাপ্লিকেশন, বা যেখানে ছোট ত্রুটিগুলির বড় প্রভাব পড়তে পারে। এটি জাভার ডিফল্ট ফ্লোটিং-পয়েন্ট ডেটা টাইপ।
              * আপনার উচ্চ নির্ভুলতা প্রয়োজন (যেমন, বৈজ্ঞানিক গবেষণা, আর্থিক অ্যাপ্লিকেশন)।
              * আপনি বড় সংখ্যার সাথে কাজ করছেন।
              * আপনি নিশ্চিত নন যে কোন ডেটা টাইপ ব্যবহার করবেন (বেশিরভাগ ক্ষেত্রে `double` ব্যবহার করাই নিরাপদ)।
          * লিটারেল (Literal): `double` লিটারেল লেখার সময় শেষে `d` অথবা `D` যোগ করা ঐচ্ছিক, কারণ এটি ডিফল্ট আচরণ।
           উদাহরণ (double):
                double myDouble = 3.1415926535; // ডিফল্টভাবে double, 'd' যোগ করা ঐচ্ছিক
                double preciseDouble = 123.45678901234567; // 15-16 দশমিক স্থান পর্যন্ত নির্ভুলতা
                double largeDouble = 1.2345E+20; // খুব বড় সংখ্যা

    ### কাস্টিং (Casting)
        কাস্টিং হলো এক ডেটা টাইপের মানকে অন্য ডেটা টাইপে রূপান্তর করার প্রক্রিয়া। জাভাতে দুই ধরনের কাস্টিং আছে:
        1.  Implicit Casting (স্বয়ংক্রিয় কাস্টিং / Widening Conversion):
              * ছোট ডেটা টাইপ থেকে বড় ডেটা টাইপে রূপান্তর স্বয়ংক্রিয়ভাবে ঘটে, কারণ এতে ডেটা হারানোর কোনো ঝুঁকি থাকে না।
              * যেমন: `float` থেকে `double`। `float` একটি $32$ বিটের টাইপ এবং `double` একটি $64$ বিটের টাইপ, তাই `float` এর মান `double` এ সহজে ফিট হয়ে যায়।
        2.  Explicit Casting (এক্সপ্লিসিট কাস্টিং / Narrowing Conversion):
              * বড় ডেটা টাইপ থেকে ছোট ডেটা টাইপে রূপান্তর করার জন্য আপনাকে কাস্টিং অপারেটর `()` ব্যবহার করতে হবে।
              * এতে ডেটা হারানোর (loss of precision) ঝুঁকি থাকে, কারণ বড় টাইপের মান ছোট টাইপে সম্পূর্ণভাবে ফিট নাও হতে পারে।
              * যেমন: `double` থেকে `float`।


### ৫. অবজেক্ট-ওরিয়েন্টেড ধারণা (Object-Oriented Concepts)
* `new` কিওয়ার্ড: নতুন অবজেক্ট তৈরি করতে (`instantiate`) ব্যবহৃত হয়। সিনট্যাক্স: `new ClassName();` অথবা `new ClassName(arguments);`।
* কনস্ট্রাক্টর (Constructors): ক্লাসের নামের মতোই এর নাম হয়, এর কোনো রিটার্ন টাইপ থাকে না (এমনকি `void` ও নয়), এবং এটি `static/final/abstruct` হতে পারে না।
* ইনস্ট্যান্স বনাম স্ট্যাটিক মেম্বার (Instance vs. Static Members):
    * ইনস্ট্যান্স ভেরিয়েবল/মেথড: একটি অবজেক্টের সাথে সম্পর্কিত। `object.variable` এর মাধ্যমে অ্যাক্সেস করা হয়। ইনস্ট্যান্স মেথডগুলো সরাসরি অন্যান্য ইনস্ট্যান্স মেম্বার অ্যাক্সেস করতে পারে।
    * স্ট্যাটিক ভেরিয়েবল/মেথড: ক্লাসের সাথে সম্পর্কিত। `ClassName.variable/method()` এর মাধ্যমে অ্যাক্সেস করা হয়। স্ট্যাটিক মেথডগুলো শুধুমাত্র অন্যান্য স্ট্যাটিক মেম্বার সরাসরি অ্যাক্সেস করতে পারে; 
       -ইনস্ট্যান্স মেম্বার অ্যাক্সেস করার জন্য একটি সুস্পষ্ট অবজেক্ট রেফারেন্স (object reference) প্রয়োজন হয়।
* ইনিশিয়ালাইজেশনের ক্রম (Order of Initialization): একটি অবজেক্ট তৈরি করার সময়, প্রথমে ইনস্ট্যান্স ভেরিয়েবল ইনিশিয়ালাইজ হয়, তারপর ইনস্ট্যান্স ইনিশিয়ালাইজার ব্লকগুলো চলে, এবং সবশেষে কনস্ট্রাক্টর কার্যকর হয়। 
      - প্রতিটি ধাপ পূর্ববর্তী অ্যাসাইনমেন্টকে ওভাররাইড করতে পারে।

### ৬. গার্বেজ কালেকশন (Garbage Collection - GC)
* `System.gc()`: এটি JVM কে গার্বেজ কালেক্টর চালানোর জন্য একটি ইঙ্গিত মাত্র। এটি অবিলম্বে বা আদৌ GC চালাবে এমন কোনো গ্যারান্টি নেই।
* `finalize()` মেথড:
    * এটি `protected void finalize() throws Throwable` এর মতো হওয়া উচিত। `finalizer()` নামের কোনো মেথড শুধু একটি সাধারণ মেথড।
    * আধুনিক জাভাতে এটি বর্জন করা হয়েছে (deprecated)।
    * এটি কল হওয়ার কোনো গ্যারান্টি নেই।
    * যদি কল হয়, তবে এটি প্রতিটি অবজেক্টের জন্য সর্বোচ্চ একবার কল হবে।
* অবজেক্টের রিচেবিলিটি (Object Reachability): 
      -একটি অবজেক্ট তখনই GC-এর জন্য যোগ্য হয় যখন এটি কোনো সক্রিয় রেফারেন্স (যেমন: লোকাল ভেরিয়েবল, স্ট্যাটিক ভেরিয়েবল, বা বর্তমানে ব্যবহৃত অন্যান্য অবজেক্ট) থেকে অ্যাক্সেসযোগ্য না থাকে। 
      -একটি ভেরিয়েবলে `null` অ্যাসাইন করলে একটি অবজেক্ট GC-এর জন্য যোগ্য হতে পারে, তবে যদি এটিই সেই অবজেক্টের ***শেষ সক্রিয় রেফারেন্স হয়।




============================ Chap_02(Data Types) ================================
6,11,12,16,19,27,35,36,37,45,46,49=12 total

6,9,11,*13,24,*25,26,*27,*28,*37,43,44,*45,*46,*48,49=16


1. Which of the following declarations does not compile?
        A. double num1, int num2 = 0;
        B. int num1, num2;
        C. int num1, num2 = 0;
        D. int num1 = 0, num2 = 0;
        
2. What is the output of the following?
        public static void main(String... args) {
        String chair, table = "metal";
        chair = chair + table;
        System.out.println(chair);
        }
        A. metal
        B. metalmetal
        C. nullmetal
        D. The code does not compile.
        
3. Which is correct about an instance variable of type String?
        A. It defaults to an empty string.
        B. It defaults to null.
        C. It does not have a default value.
        D. It will not compile without initializing on the declaration line.
        
4. Which of the following is not a valid variable name?
        A. _blue
        B. 2blue
        C. blue$
        D. Blue
        
5. Which of these class names best follows standard Java naming conventions?
        A. fooBar
        B. FooBar
        C. FOO_BAR
        D. F_o_o_B_a_r
        
6. How many of the following methods compile?
        public String convert(int value) {
        return value.toString();
        }
        public String convert(Integer value) {
        return value.toString();
        }
        public String convert(Object value) {
        return value.toString();
        }
        A. None
        B. One
        C. Two
        D. Three
        
7. Which of the following does not compile?
        A. int num = 999;
        B. int num = 9_9_9;
        C. int num = _9_99;
        D. None of the above; they all compile.
        
8. Which of the following is a wrapper class?
        A. int
        B. Int
        C. Integer
        D. Object
        
9. What is the result of running this code?
        public class Values {
        integer a = Integer.valueOf("1");
        public static void main(String[] nums) {
        integer a = Integer.valueOf("2");
        integer b = Integer.valueOf("3");
        System.out.println(a + b);
        }
        }
        A. 4
        B. 5
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.
        
10. Which best describes what the new keyword does?
        A. Creates a copy of an existing object and treats it as a new one
        B. Creates a new primitive
        C. Instantiates a new object
        D. Switches an object reference to a new one
          
11. Which is the first line to trigger a compiler error?
        double d1 = 5f; // p1
        double d2 = 5.0; // p2
        float f1 = 5f; // p3
        float f2 = 5.0; // p4
        A. p1
        B. p2
        C. p3
        D. p4
        
12. Which of the following lists of primitive types are presented in order from smallest to largest data type?
        A. byte, char, float, double
        B. byte, char, double, float
        C. char, byte, float, double
        D. char, double, float, bigint
        
13. Which of the following is not a valid order for elements in a class?
        A. Constructor, instance variables, method names
        B. Instance variables, constructor, method names
        C. Method names, instance variables, constructor
        D. None of the above: all orders are valid.
        
14. Which of the following lines contains a compiler error?
        String title = "Weather"; // line x1
        int hot, double cold; // line x2
        System.out.println(hot + " " + title); // line x3
        A. x1
        B. x2
        C. x3
        D. None of the above
        
15. How many instance initializers are in this code?
        1: public class Bowling {
        2: { System.out.println(); }
        3: public Bowling () {
        4: System.out.println();
        5: }
        6: static { System.out.println(); }        
        7: { System.out.println(); }
        8: }
        A. None
        B. One
        C. Two
        D. Three
        
16. Of the types double, int, and short, how many could fill in the blank to have this code  output 0?
        public static void main(String[] args) {
        defaultValue;
        System.out.println(defaultValue);
        }
        A. None
        B. One
        C. Two
        D. Three
        
17. What is true of the finalize() method?
        A. It may be called zero or one times.
        B. It may be called zero or more times.
        C. It will be called exactly once.
        D. It may be called one or more times.
        
18. Which of the following is not a wrapper class?
        A. Double
        B. Integer
        C. Long
        D. String
        
19. Suppose you have the following code. 
        Which of the images best represents the state of the references right before the end of the main method, assuming garbage collection hasn’t run?
        1: public class Link {
        2: private String name;
        3: private Link next;
        4: public Link(String name, Link next) {
        5: this.name = name;
        6: this.next = next;
        7: }
        8: public void setNext(Link next) {
        9: this.next = next;
        10: }
        11: public Link getNext() {
        12: return next;
        13: }
        14: public static void main(String... args) {
        15: Link link1 = new Link("x", null);
        16: Link link2 = new Link("y", link1);
        17: Link link3 = new Link("z", link2);
        18: link2.setNext(link3);
        19: link3.setNext(link2);
        20: link1 = null;
        21: link3 = null;
        22: }
        23: }
        Option A
        Option C Option D
        Option B
        x
        y z
        link1
        link3
        link2
        link1 null
        link3
        link2
        x
        y z
        link1 null
        link3
        link2
        x
        y z
        link1 null
        link3
        link2
        x
        y z
        A. Option A
        B. Option B
        C. Option C
        D. Option D
        
20. Which type can fill in the blank?
        pi = 3.14;
        A. byte
        B. float
        C. double
        D. short
        
21. What is the first line in the following code to not compile?
        public static void main(String[] args) {
        int Integer = 0; // k1
        Integer int = 0; // k2
        Integer ++; // k3
        int++; // k4
        }
        A. k1
        B. k2
        C. k3
        D. k4
        
22. Suppose foo is a reference to an instance of a class. Which of the following is not true  about foo.bar?
        A. bar is an instance variable.
        B. bar is a local variable.
        C. It can be used to read from bar.
        D. It can be used to write to bar.
        
23. Which of the following is not a valid class declaration?
        A. class building {}
        B. class Cost$ {}
        C. class 5MainSt {}
        D. class _Outside {}
        
24. Which of the following can fill in the blanks to make this code compile?
        __ d = new (1_000_000_.00);
        A. double, double
        B. double, Double
        C. Double, double
        D. None of the above
        
25. Which is correct about a local variable of type String?
        A. It defaults to an empty string.
        B. It defaults to null.
        C. It does not have a default value.
        D. It will not compile without initializing on the declaration line.
        
26. Of the types double, int, long, and short, how many could fill in the blank to have this code output 0?
        static __ defaultValue;
        public static void main(String[] args) {
        System.out.println(defaultValue);
        }
        A. One
        B. Two
        C. Three
        D. Four
        
27. Which of the following is true about primitives?
        A. You can call methods on a primitive.
        B. You can convert a primitive to a wrapper class object simply by assigning it.
        C. You can convert a wrapper class object to a primitive by calling valueOf().
        D. You can store a primitive directly into an ArrayList.
        
28. What is the output of the following?
        Integer integer = new Integer(4);
        System.out.print(integer.byteValue());
        System.out.print("-");
        int i = new Integer(4);
        System.out.print(i.byteValue());
        A. 4-0
        B. 4-4
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.
        
29. Given the following code, fill in the blank to have the code print bounce.
        public class TennisBall {
        public TennisBall() {
        System.out.println("bounce");
        }
        public static void main(String[] slam) {
                __
        }
        }
        A. TennisBall;
        B. TennisBall();
        C. new TennisBall;
        D. new TennisBall();
        
30. Which of the following correctly assigns animal to both variables?
        I. String cat = "animal", dog = "animal";
        II. String cat = "animal"; dog = "animal";
        III. String cat, dog = "animal";
        IV. String cat, String dog = "animal";
        A. I
        B. I, II
        C. I, III
        D. I, II, III, IV
    
31. Which two primitives have wrapper classes that are not merely the name of the primitive  with an uppercase letter?
        A. byte and char
        B. byte and int
        C. char and int
        D. None of the above
        
32. Which of the following is true about String instance variables?
        A. They can be set to null.
        B. They can never be set from outside the class they are defined in.
        C. They can only be set in the constructor.
        D. They can only be set once per run of the program.
        
33. Which statement is true about primitives?
        A. Primitive types begin with a lowercase letter.
        B. Primitive types can be set to null.
        C. String is a primitive.
        D. You can create your own primitive types.
        
34. How do you force garbage collection to occur at a certain point?
        A. Call System.forceGc()
        B. Call System.gc()
        C. Call System.requireGc()
        D. None of the above
        
35. How many of the String objects are eligible for garbage collection right before the end of  the main method?
        public static void main(String[] fruits) {
        String fruit1 = new String("apple");
        String fruit2 = new String("orange");
        String fruit3 = new String("pear");
        fruit3 = fruit1;
        fruit2 = fruit3;
        fruit1 = fruit2;
        }
        A. None
        B. One
        C. Two
        D. Three
        
36. Which of the following can fill in the blanks to make this code compile?
          __ d = new __(1_000_000.00);
        A. double, double
        B. double, Double
        C. Double, double
        D. None of the above
        
37. What does the following output?
        1: public class InitOrder {
        2: public String first = "instance";
        3: public InitOrder() {
        4: first = "constructor";
        5: }
        6: { first = "block"; }
        7: public void print() {
        8: System.out.println(first);
        9: }
        10: public static void main(String... args) {
        11: new InitOrder().print();
        12: }
        13: }
        A. block
        B. constructor
        C. instance
        D. The code does not compile.
        
38. How many of the following lines compile?
        int i = null;
        Integer in = null;
        String s = null;
        A. None
        B. One
        C. Two
        D. Three
        
39. Which pairs of statements can accurately fill in the blanks in this table?
        Variable Type
        Can be called within the class from
        what type of method
        Instance Blank 1:
        Static Blank 2:
        A. Blank 1: an instance method only, Blank 2: a static method only
        B. Blank 1: an instance or static method, Blank 2: a static method only
        C. Blank 1: an instance method only, Blank 2: an instance or static method
        D. Blank 1: an instance or static method, Blank 2: an instance or static method
        
40. Which of the following does not compile?
        A. double num = 2.718;
        B. double num = 2._718;
        C. double num = 2.7_1_8;
        D. None of the above; they all compile.

41. Which of the following lists of primitive numeric types is presented in order from smallest
        to largest data type?
        A. byte, short, int, long
        B. int, short, byte, long
        C. short, byte, int, long
        D. short, int, byte, long
        

42. Fill in the blank to make the code compile:
        package animal;
        public class Cat {
        public String name;
        public static void main(String[] meow) {
        Cat cat = new Cat();
        = "Sadie";
        }
        }
        A. cat.name
        B. cat-name
        C. cat.setName
        D. cat[name]

43. Which of the following is the output of this code, assuming it runs to completion?
        package store;
        public class Toy {
        public void play() {
        System.out.print("play-");
        }
        public void finalizer() {
        System.out.print("clean-");
        }
        public static void main(String[] fun) {
        Toy car = new Toy();
        car.play();
        System.gc();
        Toy doll = new Toy();
        doll.play();
        }
        }
        A. play
        B. play-play
        C. play-clean-play
        D. play-play-clean-clean
        
44. Which is the most common way to fill in the blank to implement this method?
        public class Penguin {
        private double beakLength;
        public static void setBeakLength(Penguin p, int b) {
        __
        }
        }
        A. p.beakLength = b;
        B. p['beakLength'] = b;
        C. p[beakLength] = b;
        D. None of the above
        
45. Fill in the blanks to indicate whether a primitive or wrapper class can be assigned without the compiler using the autoboxing feature.
        __ first = Integer.parseInt("5");
        __ second = Integer.valueOf("5");
        A. int, int
        B. int, Integer
        C. Integer, int
        D. Integer, Integer

46. How many objects are eligible for garbage collection right before the end of the main method?
        1: public class Person {
        2: public Person youngestChild;
        3:
        4: public static void main(String... args) {
        5: Person elena = new Person();
        6: Person diana = new Person();
        7: elena.youngestChild = diana;
        8: diana = null;
        9: Person zoe = new Person();
        10: elena.youngestChild = zoe;
        11: zoe = null;
        12: }
        13: }
        A. None
        B. One
        C. Two
        D. Three

47. Which is a valid constructor for this class?
        public class TennisBall {
        }
        A. public TennisBall static create() { return new TennisBall(); }
        B. public TennisBall static newInstance() { return new TennisBall():}
        C. public TennisBall() {}
        D. public void TennisBall() {}

48. Which of the following is not a possible output of this code, assuming it runs to completion?
        package store;
        public class Toy {
        public void play() {
        System.out.print("play-");
        }
        public void finalize() {
        System.out.print("clean-");
        }
        public static void main(String[] args) {
        Toy car = new Toy();
        car.play();
        System.gc();
        Toy doll = new Toy();
        doll.play();
        }
        }
        A. play 
        B. play-play 
        C. play-play-clean 
        D. play-play-clean-clean
        
49. Which converts a primitive to a wrapper class object without using autoboxing?
        A. Call the asObject() method
        B. Call the constructor of the wrapper class
        C. Call the convertToObject() method
        D. Call the toObject() method

50. What is the output of the following?
        package beach;
        public class Sand {
        public Sand() {
        System.out.print("a");
        }
        public void Sand() {
        System.out.print("b");
        }
        public void run() {
        new Sand();
        Sand();
        }
        public static void main(String... args) {
        new Sand().run();
        }
        }
        A. a
        B. ab
        C. aab
        D. None of the above

========================================= Answers ========================================================

6.C, 11.D, 12.A, 16.A, 19, 27.B,
35.C, 36.B, 37.B, 45.B, 46.B, 49.B

-

1.A, 2.D, 3.B, 4.B, 5.B, 
6.C, 7.C, 8.C, 9.C, 10.C, 
11.D, 12.A, 13.D, 14.B, 15.C, 
16.A, 17.A, 18.D, 19.C, 20.C, 
21.B, 22.B, 23.C, 24.D, 25.C, 
26.C, 27.B, 28.C, 29.D, 30.A, 
31.C, 32.A, 33.A, 34.D, 35.C, 
36.B, 37.B, 38.C, 39.C, 40.B, 
41.A, 42.A, 43.B, 44.A, 45.B, 
46.B, 47.C, 48.A, 49.B, 50.C,


১. এ. অপশন এ কম্পাইল হবে না কারণ জাভা একই ঘোষণার অংশে বিভিন্ন টাইপ ঘোষণা করার অনুমতি দেয় না। অন্য তিনটি অপশন ঐচ্ছিক ডিফল্ট মান সহ একই ঘোষণায় একাধিক ভেরিয়েবল একত্রিত করার বিভিন্ন বৈধ সমন্বয় দেখায়।
২. ডি. `table` ভেরিয়েবলটি "metal" এ ইনিশিয়ালাইজ করা হয়েছে। তবে, `chair` ইনিশিয়ালাইজ করা হয়নি। জাভাতে, ইনিশিয়ালাইজেশন প্রতিটি ভেরিয়েবলের জন্য হয়, একটি একক ঘোষণার সমস্ত ভেরিয়েবলের জন্য নয়। সুতরাং, দ্বিতীয় লাইনটি একটি অনিশিয়ালাইজড স্থানীয় ভেরিয়েবল উল্লেখ করার চেষ্টা করে এবং কম্পাইল হয় না, যা অপশন ডি কে সঠিক করে।
৩. বি. ইনস্ট্যান্স ভেরিয়েবলের টাইপের উপর ভিত্তি করে একটি ডিফল্ট মান থাকে। `String` সহ যেকোনো নন-প্রিমিটিভের জন্য, সেই টাইপটি নালের একটি রেফারেন্স। সুতরাং অপশন বি সঠিক। যদি ভেরিয়েবলটি একটি স্থানীয় ভেরিয়েবল হত, তবে অপশন সি সঠিক হত।
৪. বি. একটি আইডেন্টিফায়ার নাম একটি অক্ষর, $, বা _ দিয়ে শুরু হতে হবে। সংখ্যা শুধুমাত্র পরবর্তী অক্ষরগুলোর জন্য অনুমোদিত। সুতরাং, অপশন বি একটি বৈধ ভেরিয়েবলের নাম নয়।
৫. বি. জাভাতে, কনভেনশন অনুসারে ক্লাসের নাম একটি বড় হাতের অক্ষর দিয়ে শুরু হয়। তারপর নতুন শব্দগুলো ছাড়া ছোট হাতের অক্ষর ব্যবহার করা হয়। অপশন বি এই কনভেনশন অনুসরণ করে এবং সঠিক। অপশন এ ভেরিয়েবলের নামের কনভেনশন অনুসরণ করে। অপশন সি ধ্রুবকের কনভেনশন অনুসরণ করে। অপশন ডি কোনো জাভা কনভেনশন অনুসরণ করে না।

৬. সি. অবজেক্টের ইনস্ট্যান্স মেথড থাকে, কিন্তু প্রিমিটিভের থাকে না। যেহেতু `int` একটি প্রিমিটিভ, তাই আপনি এর উপর ইনস্ট্যান্স মেথড কল করতে পারবেন না। `Integer` এবং `String` উভয়ই অবজেক্ট এবং তাদের ইনস্ট্যান্স মেথড আছে। সুতরাং, অপশন সি সঠিক।
৭. সি. একটি সংখ্যাসূচক লিটারেলে যেকোনো দুটি অঙ্কের মধ্যে আন্ডারস্কোর অনুমোদিত। লিটারেলের শুরুতে বা শেষে আন্ডারস্কোর অনুমোদিত নয়, যা অপশন সি কে সঠিক উত্তর করে তোলে।
৮. সি. অপশন এ ভুল কারণ `int` একটি প্রিমিটিভ। অপশন বি ভুল কারণ এটি জাভার কোনো ক্লাসের নাম নয়। যদিও অপশন ডি জাভার একটি ক্লাস, এটি একটি র‍্যাপার ক্লাস নয় কারণ এটি কোনো প্রিমিটিভের সাথে ম্যাপ করে না। সুতরাং, অপশন সি সঠিক।
৯. সি. `integer` নামের কোনো ক্লাস নেই। `int` নামে একটি প্রিমিটিভ এবং `Integer` নামে একটি ক্লাস আছে। সুতরাং, কোডটি কম্পাইল হবে না এবং অপশন সি সঠিক। যদি টাইপটি `Integer` এ পরিবর্তন করা হত, তবে অপশন বি সঠিক হত।
১০. সি. `new` কীওয়ার্ড একটি ক্লাসের কনস্ট্রাক্টর কল করতে এবং ক্লাসের একটি ইনস্ট্যান্স তৈরি করতে ব্যবহৃত হয়। `new` কীওয়ার্ড ব্যবহার করে একটি প্রিমিটিভ তৈরি করা যায় না। `new` দ্বারা তৈরি অবজেক্ট ফেরত দেওয়ার পরেই রেফারেন্সের সাথে মোকাবিলা করা হয়।

১১. ডি. জাভা `f` সাফিক্স ব্যবহার করে বোঝাতে যে একটি সংখ্যা `float`। জাভা স্বয়ংক্রিয়ভাবে একটি টাইপকে প্রশস্ত করে, `float` কে `float` বা `double` উভয়টিতেই অ্যাসাইন করার অনুমতি দেয়। এটি লাইন `p1` এবং `p3` উভয়কেই কম্পাইল করে। লাইন `p2` কোনো সাফিক্স ছাড়াই কম্পাইল হয়। লাইন `p4` কোনো সাফিক্স ছাড়াই কম্পাইল হয় না এবং তাই উত্তর।
১২. এ. একটি `byte` একটি `char` এর চেয়ে ছোট, যা অপশন সি কে ভুল করে। `bigint` একটি প্রিমিটিভ নয়, যা অপশন ডি কে ভুল করে। একটি `double` একটি `float` ভেরিয়েবলের চেয়ে দ্বিগুণ মেমরি ব্যবহার করে, তাই অপশন এ সঠিক।
১৩. ডি. একটি ক্লাস ঘোষণার মধ্যে ইনস্ট্যান্স ভেরিয়েবল, কনস্ট্রাক্টর এবং মেথডের নাম যেকোনো ক্রমে থাকতে পারে।
১৪. বি. জাভা একই ঘোষণায় একাধিক জাভা ডেটা টাইপ ঘোষণা করার অনুমতি দেয় না, যা অপশন বি কে সঠিক উত্তর করে তোলে। যদি `double` সরানো হয়, `hot` এবং `cold` উভয়েরই একই টাইপ হবে। তখন অনিশিয়ালাইজড ভেরিয়েবলের রেফারেন্সের কারণে `x3` তে কম্পাইলার ত্রুটি দেখা দেবে।
১৫. সি. লাইন ২ এবং ৭ ইনস্ট্যান্স ইনিশিয়ালাইজার চিত্রিত করে। লাইন ৬ একটি স্ট্যাটিক ইনিশিয়ালাইজার। লাইন ৩-৫ একটি কনস্ট্রাক্টর।

১৬. এ. যেহেতু `defaultValue` একটি স্থানীয় ভেরিয়েবল, তাই এটি স্বয়ংক্রিয়ভাবে ইনিশিয়ালাইজ হয় না। এর মানে হল কোডটি কোনো টাইপের সাথেই কম্পাইল হবে না। সুতরাং, অপশন এ সঠিক। যদি এটি একটি ইনস্ট্যান্স ভেরিয়েবল হত, তবে অপশন সি সঠিক হত কারণ `int` এবং `short` 0 তে ইনিশিয়ালাইজ হত, যখন `double` 0.0 তে ইনিশিয়ালাইজ হত।
১৭. এ. `finalize()` মেথড কল নাও হতে পারে, যেমন আপনার প্রোগ্রাম ক্র্যাশ করলে। তবে, এটি নিশ্চিতভাবে একবারের বেশি কল করা হবে না।
১৮. ডি. `String` একটি ক্লাস, তবে এটি একটি র‍্যাপার ক্লাস নয়। র‍্যাপার ক্লাস হওয়ার জন্য, ক্লাসটির একটি প্রিমিটিভের সাথে এক-থেকে-এক ম্যাপিং থাকতে হবে।
১৯. সি. লাইন ১৫-১৭ তিনটি অবজেক্ট তৈরি করে। লাইন ১৮-১৯ রেফারেন্স পরিবর্তন করে যাতে `link2` এবং `link3` একে অপরের দিকে নির্দেশ করে। লাইন ২০-২১ দুটি মূল রেফারেন্স মুছে ফেলে। এর মানে হল `x` নামযুক্ত অবজেক্টটি অ্যাক্সেসযোগ্য নয়।
২০. সি. অপশন এ এবং ডি ভুল কারণ `byte` এবং `short` দশমিক বিন্দু সহ মান সংরক্ষণ করে না। অপশন বি লোভনীয়। তবে, 3.14 স্বয়ংক্রিয়ভাবে একটি `double`। এটিকে `float` এ কাস্ট করা বা `float` এ অ্যাসাইন করার জন্য `3.14f` লেখা প্রয়োজন। সুতরাং, অপশন সি সঠিক।

২১. বি. `Integer` জাভার একটি ক্লাসের নাম। যদিও একটি ক্লাসের নামকে আপনার স্থানীয় ভেরিয়েবলের নাম হিসেবে ব্যবহার করা খারাপ অভ্যাস, তবে এটি বৈধ। সুতরাং, `k1` কম্পাইল হয়। একটি সংরক্ষিত শব্দকে ভেরিয়েবলের নাম হিসেবে ব্যবহার করা বৈধ নয়। `int` সহ সমস্ত প্রিমিটিভ সংরক্ষিত শব্দ। সুতরাং, `k2` কম্পাইল হয় না এবং অপশন বি উত্তর। লাইন `k4` ও কম্পাইল হয় না, তবে প্রশ্নটি প্রথম লাইনটি সম্পর্কে জিজ্ঞাসা করে যা কম্পাইল হয় না।
২২. বি. ডট নোটেশন ইনস্ট্যান্স ভেরিয়েবল পড়া এবং লেখার উভয় ক্ষেত্রেই ব্যবহৃত হয়, যদি তারা স্কোপের মধ্যে থাকে। এটি স্থানীয় ভেরিয়েবল উল্লেখ করার জন্য ব্যবহার করা যায় না, যা অপশন বি কে সঠিক উত্তর করে তোলে।
২৩. সি. ক্লাসের নাম অন্যান্য আইডেন্টিফায়ারের মতো একই প্রয়োজনীয়তা অনুসরণ করে। আন্ডারস্কোর এবং ডলার চিহ্ন অনুমোদিত। সংখ্যা অনুমোদিত, তবে একটি আইডেন্টিফায়ারের প্রথম অক্ষর হিসেবে নয়। সুতরাং, অপশন সি সঠিক। মনে রাখবেন যে কনভেনশন অনুসারে ক্লাসের নাম একটি বড় হাতের অক্ষর দিয়ে শুরু হয়, তবে এটি কোনো প্রয়োজন নয়।
২৪. ডি. এই প্রশ্নটি কঠিন কারণ এটি প্রিমিটিভ বনাম র‍্যাপার ক্লাস সম্পর্কে মনে হতে পারে। ঘনিষ্ঠভাবে দেখলে, দশমিক বিন্দুর ঠিক আগে একটি আন্ডারস্কোর রয়েছে। এটি অবৈধ কারণ একটি সংখ্যাসূচক লিটারেলে আন্ডারস্কোর শুধুমাত্র দুটি অঙ্কের মধ্যে থাকতে পারে।
২৫. সি. স্থানীয় ভেরিয়েবলের কোনো ডিফল্ট ইনিশিয়ালাইজেশন মান নেই। যদি মান নির্ধারণ করার আগে তাদের উল্লেখ করা হয়, তবে কোডটি কম্পাইল হয় না। সুতরাং, অপশন সি সঠিক। যদি ভেরিয়েবলটি একটি ইনস্ট্যান্স ভেরিয়েবল হত, তবে অপশন বি সঠিক হত। একটি স্থানীয় ভেরিয়েবল ইনিশিয়ালাইজেশন ছাড়াই কম্পাইল হবে যদি এটি কোথাও উল্লেখ করা না হয় বা উল্লেখ করার আগে একটি মান নির্ধারণ করা হয়।

২৬. সি. যেহেতু `defaultValue` একটি ইনস্ট্যান্স ভেরিয়েবল, তাই এটি স্বয়ংক্রিয়ভাবে সেই টাইপের জন্য সংশ্লিষ্ট মানটিতে ইনিশিয়ালাইজ হয়। `double` এর জন্য সেই মানটি হল 0.0। বিপরীতে, `int`, `long` এবং `short` এর জন্য এটি 0। সুতরাং অপশন সি সঠিক।
২৭. বি. অপশন বি অটোবক্সিং এর একটি উদাহরণ। জাভা স্বয়ংক্রিয়ভাবে প্রিমিটিভ থেকে র‍্যাপার ক্লাস টাইপ এবং বিপরীতভাবে রূপান্তর করবে। অপশন এ ভুল কারণ আপনি কেবল একটি অবজেক্টের উপর মেথড কল করতে পারেন। অপশন সি ভুল কারণ এই মেথডটি একটি স্ট্রিং থেকে একটি র‍্যাপার ক্লাসে রূপান্তর করার জন্য ব্যবহৃত হয়। অপশন ডি ভুল কারণ অটোবক্সিং প্রিমিটিভটিকে `ArrayList` এ যুক্ত করার আগে একটি অবজেক্টে রূপান্তর করবে।
২৮. সি. জাভা একটি প্রিমিটিভের উপর মেথড কল করার অনুমতি দেয় না। যদিও অটোবক্সিং একটি `Integer` কে `int` এ অ্যাসাইন করার অনুমতি দেয়, তবে এটি একটি প্রিমিটিভের উপর একটি ইনস্ট্যান্স মেথড কল করার অনুমতি দেয় না। সুতরাং, শেষ লাইনটি কম্পাইল হয় না।
২৯. ডি. একটি কনস্ট্রাক্টর কল করার জন্য, আপনাকে `new` কীওয়ার্ড ব্যবহার করতে হবে। এটিকে স্বাভাবিক মেথডের মতো কল করা যায় না। এটি অপশন এ এবং বি কে বাদ দেয়। তদুপরি, বন্ধনী প্রয়োজনীয় হওয়ায় অপশন সি ভুল।
৩০. এ. অপশন এ (I) উভয় ভেরিয়েবলে সঠিকভাবে মান নির্ধারণ করে। II কম্পাইল হয় না কারণ `dog` এর কোনো টাইপ নেই। সেই লাইনের সেমিকোলন লক্ষ্য করুন, যা একটি নতুন স্টেটমেন্ট শুরু করে। III কম্পাইল হয় তবে কেবল `dog` এ মান নির্ধারণ করে কারণ একটি ঘোষণা কেবল একটি ভেরিয়েবলে অ্যাসাইন করে, ঘোষণার সকলের কাছে নয়। IV কম্পাইল হয় না কারণ প্রতি ঘোষণায় টাইপটি কেবল একবার নির্দিষ্ট করা উচিত।

৩১. সি. `int` এর র‍্যাপার ক্লাস `Integer` এবং `char` এর র‍্যাপার ক্লাস `Character`। অন্যান্য সমস্ত প্রিমিটিভের একই নাম রয়েছে। উদাহরণস্বরূপ, `boolean` এর র‍্যাপার ক্লাস `Boolean`।
৩২. এ. ধরে নিচ্ছি ভেরিয়েবলগুলো প্রিমিটিভ নয়, তারা একটি নাল অ্যাসাইনমেন্টের অনুমতি দেয়। অন্য স্টেটমেন্টগুলো মিথ্যা।
৩৩. এ. একটি প্রিমিটিভ টাইপের উদাহরণ হল `int`। সমস্ত প্রিমিটিভ টাইপ ছোট হাতের অক্ষর দিয়ে লেখা হয়, যা অপশন এ কে সঠিক করে। অবজেক্ট রেফারেন্স ভেরিয়েবলের বিপরীতে, প্রিমিটিভ নাল উল্লেখ করতে পারে না। `String` একটি প্রিমিটিভ নয়, নামের বড় হাতের অক্ষর এবং আমরা এর উপর মেথড কল করতে পারি তা থেকে প্রমাণিত। আপনি নিজের ক্লাস তৈরি করতে পারেন, তবে প্রিমিটিভ নয়।
৩৪. ডি. যদিও আপনি JVM কে গার্বেজ কালেকশন চক্র চালানোর পরামর্শ দিতে পারেন, JVM আপনার পরামর্শ উপেক্ষা করতে স্বাধীন। অপশন বি হল এই পরামর্শ দেওয়ার উপায়। যেহেতু গার্বেজ কালেকশন চালানোর গ্যারান্টি নেই, তাই অপশন ডি সঠিক।
৩৫. সি. তিনটি রেফারেন্সই `String` "apple" কে নির্দেশ করে। এটি অন্য দুটি `String` অবজেক্টকে গার্বেজ কালেকশনের জন্য যোগ্য করে তোলে এবং অপশন সি সঠিক।

৩৬. বি. একটি কনস্ট্রাক্টর কেবল একটি ক্লাসের নাম দিয়ে কল করা যায়, প্রিমিটিভ দিয়ে নয়, যা অপশন এ এবং সি কে ভুল করে। নতুন তৈরি `Double` অবজেক্টটি অটোবক্সিংয়ের জন্য `double` বা `Double` উভয়টিতেই অ্যাসাইন করা যেতে পারে। সুতরাং, অপশন বি সঠিক।
৩৭. বি. প্রথমে লাইন ২ রান করে এবং ঘোষণার মাধ্যমে ভেরিয়েবল সেট করে। তারপর লাইন ৬ এর ইনস্ট্যান্স ইনিশিয়ালাইজার রান করে। অবশেষে, কনস্ট্রাক্টর রান করে। যেহেতু কনস্ট্রাক্টর এই তিনটির মধ্যে শেষ রান করে, তাই যখন আমরা ফলাফল প্রিন্ট করি তখন সেই মানটি সেট হয়, তাই অপশন বি সঠিক।
৩৮. সি. অবজেক্টের একটি নাল রেফারেন্স থাকতে পারে তবে প্রিমিটিভের পারে না। `int` একটি প্রিমিটিভ, তাই এটিকে নাল অ্যাসাইন করলে কম্পাইল হবে না। `Integer` এবং `String` উভয়ই অবজেক্ট এবং তাই তাদের একটি নাল রেফারেন্স অ্যাসাইন করা যেতে পারে। সুতরাং, অপশন সি সঠিক।
৩৯. সি. একটি ইনস্ট্যান্স ভেরিয়েবল কেবল ক্লাসের ইনস্ট্যান্স মেথড থেকে উল্লেখ করা যেতে পারে। একটি স্ট্যাটিক ভেরিয়েবল যেকোনো মেথড থেকে উল্লেখ করা যেতে পারে। সুতরাং, অপশন সি সঠিক।
৪০. বি. একটি সংখ্যাসূচক লিটারেলে যেকোনো দুটি অঙ্কের মধ্যে আন্ডারস্কোর অনুমোদিত। দশমিক বিন্দুর সংলগ্ন আন্ডারস্কোর অনুমোদিত নয়, যা অপশন বি কে সঠিক উত্তর করে তোলে।

৪১. এ. এই চারটি টাইপ অ-দশমিক মান উপস্থাপন করে। যদিও আপনার সঠিক আকার জানার প্রয়োজন নেই, তবে আপনাকে বৃহত্তম থেকে ক্ষুদ্রতম ক্রমে সাজাতে সক্ষম হতে হবে। একটি `byte` সবচেয়ে ছোট। এর পরে `short`, তারপর `int` এবং তারপর `long`। সুতরাং, অপশন এ সঠিক।
৪২. এ. জাভা ক্লাসে ইনস্ট্যান্স ভেরিয়েবল উল্লেখ করার জন্য ডট নোটেশন ব্যবহার করে, যা অপশন এ কে সঠিক করে।
৪৩. বি. যদি একটি `finalize()` মেথড থাকত, তবে এটি অন্য গল্প হত। তবে, এখানে মেথডটি হল `finalizer`। কঠিন! এটি কেবল একটি সাধারণ মেথড যা স্বয়ংক্রিয়ভাবে কল হয় না। সুতরাং `clean` কখনোই আউটপুট হয় না।
৪৪. এ. অপশন বি এবং সি কম্পাইল হবে না। জাভাতে, ব্র্যাকেট ইনস্ট্যান্স ভেরিয়েবলের জন্য নয়, অ্যারের জন্য। অপশন এ সঠিক উত্তর। এটি ইনস্ট্যান্স ভেরিয়েবল অ্যাক্সেস করতে ডট নোটেশন ব্যবহার করে। এটি আরও দেখায় যে একই ক্লাসে একটি প্রাইভেট ভেরিয়েবল অ্যাক্সেসযোগ্য এবং একটি সংকীর্ণ টাইপকে একটি প্রশস্ত টাইপে অ্যাসাইন করার অনুমতি দেওয়া হয়েছে।
৪৫. বি. `parseInt()` মেথড একটি প্রিমিটিভ ফেরত দেয়। `valueOf()` মেথড একটি র‍্যাপার ক্লাস অবজেক্ট ফেরত দেয়। বাস্তব কোডে, অটোবক্সিং আপনাকে রিটার্ন মানটিকে একটি প্রিমিটিভ বা র‍্যাপার ক্লাসে অ্যাসাইন করতে দেবে। সরাসরি কী ফেরত দেওয়া হয় তার পরিপ্রেক্ষিতে, অপশন বি সঠিক।

৪৬. বি.
- লাইন ৯ এ, তিনটি অবজেক্টেরই রেফারেন্স রয়েছে / `elena` প্রতিনিধিত্বকারী একটি অবজেক্ট তৈরি করা হয়েছে। `elena` এটির একটি রেফারেন্স ধারণ করে।
- যদি কোনো অবজেক্ট অ্যাক্সেসযোগ্য হয়, তবে এটিকে গার্বেজ কালেকশন করা যাবে না।
- `elena.youngestChild = diana;`: `diana` অবজেক্টটিও এখন `elena.youngestChild` এর মাধ্যমে অ্যাক্সেসযোগ্য।
- `diana = null;`: `diana` ভেরিয়েবলটি নাল এ সেট করা হয়েছে। তবে, `diana` অবজেক্টটি গার্বেজ কালেকশন করা হবে না কারণ এটি এখনও `elena.youngestChild` এর মাধ্যমে অ্যাক্সেসযোগ্য।
- `elena.youngestChild = zoe;`: `zoe` অবজেক্টটি এখন `elena.youngestChild` এর মাধ্যমে অ্যাক্সেসযোগ্য। `diana` অবজেক্টটি এখন রুট সেট থেকে অ্যাক্সেসযোগ্য নয়। সুতরাং `diana` অবজেক্টটি এখন গার্বেজ কালেকশনের জন্য যোগ্য।
- `zoe = null;`: `zoe` ভেরিয়েবলটি নাল এ সেট করা হয়েছে। তবে, `zoe` অবজেক্টটি গার্বেজ কালেকশন করা হবে না কারণ এটি এখনও `elena.youngestChild` এর মাধ্যমে অ্যাক্সেসযোগ্য।

৪৭. সি. অপশন এ এবং বি কনস্ট্রাক্টর নয়, স্ট্যাটিক মেথড। অপশন ডি এমন একটি মেথড যার নাম ক্লাসের নামের মতো। এটি কনস্ট্রাক্টর নয় কারণ কনস্ট্রাক্টরের কোনো রিটার্ন টাইপ থাকে না।
৪৮. এ. মনে রাখবেন যে ডিমান্ডে গার্বেজ কালেকশন চালানোর গ্যারান্টি নেই। যদি এটি একেবারেই না চলে, তবে অপশন বি আউটপুট হবে। যদি এটি অনুরোধের স্থানে চলে, তবে অপশন সি আউটপুট হবে। যদি এটি `main()` মেথডের ঠিক শেষে চলে, তবে অপশন ডি আউটপুট হবে। অপশন এ সঠিক উত্তর কারণ `play` অবশ্যই দুবার কল করা হয়েছে। মনে রাখবেন যে আপনি এই কোডটি চালালে এই সমস্ত দৃশ্য দেখতে পাওয়ার সম্ভাবনা কম কারণ গার্বেজ কালেকশন চালানোর মতো যথেষ্ট মেমরি আমরা ব্যবহার করিনি। তবে, এটি অসম্ভাব্য হলেও কী ঘটতে পারে তা আপনাকে উত্তর দিতে সক্ষম হতে হবে।
৪৯. বি. প্রতিটি র‍্যাপার ক্লাসের একটি কনস্ট্রাক্টর রয়েছে যা প্রিমিটিভ সমতুল্য গ্রহণ করে। অপশন এ, সি এবং ডি তে উল্লিখিত মেথডগুলো বিদ্যমান নেই।
৫০. সি. `main()` মেথড কনস্ট্রাক্টর কল করে যা `a` আউটপুট করে। তারপর `main` মেথড `run()` মেথড কল করে। `run()` মেথড আবার কনস্ট্রাক্টর কল করে, যা আবার `a` আউটপুট করে। তারপর `run()` মেথড `Sand()` মেথড কল করে, যার নামটি কনস্ট্রাক্টরের নামের মতো। এটি `b` আউটপুট করে। সুতরাং, অপশন সি সঠিক।






1. A. Option A does not compile because Java does not allow declaring different types as part
of the same declaration. The other three options show various legal combinations of combining multiple variables in the same declarations with optional default values.
2. D. The table variable is initialized to "metal". However, chair is not initialized. In Java, initialization is per variable and not for all the variables in a single declaration. 
Therefore, the second line tries to reference an uninitialized local variable and does not compile, which makes Option D correct.
3. B. Instance variables have a default value based on the type. For any non-primitive, including String, that type is a reference to null. Therefore Option B is correct. 
If the variable was a local variable, Option C would be correct.
4. B. An identifier name must begin with a letter, $, or _. Numbers are only permitted for subsequent characters. Therefore, Option B is not a valid variable name.
5. B. In Java, class names begin with an uppercase letter by convention. Then they use lowercase with the exception of new words. Option B follows this convention and is correct.
Option A follows the convention for variable names. Option C follows the convention for constants. Option D doesn’t follow any Java conventions.

6. C. Objects have instance methods while primitives do not. Since int is a primitive, you cannot call instance methods on it. Integer and String are both objects and have instance methods. 
Therefore, Option C is correct.
7. C. Underscores are allowed between any two digits in a numeric literal. Underscores are not allowed at the beginning or end of the literal, making Option C the correct answer.
8. C. Option A is incorrect because int is a primitive. Option B is incorrect because it is not the name of a class in Java. While Option D is a class in Java, it is not a wrapper class
because it does not map to a primitive. Therefore, Option C is correct.
9. C. There is no class named integer. There is a primitive int and a class Integer. Therefore, the code does not compile, and Option C is correct. If the type was changed to
Integer, Option B would be correct.
10. C. The new keyword is used to call the constructor for a class and instantiate an instance of the class. A primitive cannot be created using the new keyword. Dealing with references
happens after the object created by new is returned.

11. D. Java uses the suffix f to indicate a number is a float. Java automatically widens a type, allowing a float to be assigned to either a float or a double. This makes both lines p1 and
p3 compile. Line p2 does compile without a suffix. Line p4 does not compile without a suffix and therefore is the answer.
12. A. A byte is smaller than a char, making Option C incorrect. bigint is not a primitive, making Option D incorrect. A double uses twice as much memory as a float variable,
therefore Option A is correct.
13. D. The instance variables, constructor, and method names can appear in any order within a class declaration.
14. B. Java does not allow multiple Java data types to be declared in the same declaration, making Option B the correct answer. If double was removed, both hot and cold would be
the same type. Then the compiler error would be on x3 because of a reference to an uninitialized variable.
15. C. Lines 2 and 7 illustrate instance initializers. Line 6 is a static initializer. Lines 3–5 are a constructor.

16. A. Since defaultValue is a local variable, it is not automatically initialized. That means the code will not compile with any type. Therefore, Option A is correct. If this was an
instance variable, Option C would be correct as int and short would be initialized to 0 while double would be initialized to 0.0.
17. A. The finalize() method may not be called, such as if your program crashes. However,it is guaranteed to be called no more than once.
18. D. String is a class, but it is not a wrapper class. In order to be a wrapper class, the class must have a one-to-one mapping with a primitive.
19. C. Lines 15–17 create the three objects. Lines 18–19 change the references so link2 and link3 point to each other. The lines 20–21 wipe out two of the original references.
This means the object with name as x is inaccessible.
20. C. Options A and D are incorrect because byte and short do not store values with decimal points. Option B is tempting. However, 3.14 is automatically a double. It requires
casting to float or writing 3.14f in order to be assigned to a float. Therefore, Option C is correct.

21. B. Integer is the name of a class in Java. While it is bad practice to use the name of a class as your local variable name, this is legal. Therefore, k1 does compile. It is not legal to use
a reserved word as a variable name. All of the primitives including int are reserved words. Therefore, k2 does not compile, and Option B is the answer. Line k4 doesn’t compile either,
but the question asks about the first line to not compile.
22. B. Dot notation is used for both reading and writing instance variables, assuming they are in scope. It cannot be used for referencing local variables, making Option B the correct answer.
23. C. Class names follow the same requirements as other identifiers. Underscores and dollar signs are allowed. Numbers are allowed, but not as the first character of an identifier.
Therefore, Option C is correct. Note that class names begin with an uppercase letter by convention, but this is not a requirement.
24. D. This question is tricky as it appears to be about primitive vs. wrapper classes. Looking closely, there is an underscore right before the decimal point. 
This is illegal as the underscore in a numeric literal can only appear between two digits.
25. C. Local variables do not have a default initialization value. If they are referenced before being set to a value, the code does not compile. 
Therefore, Option C is correct. If the variable was an instance variable, Option B would be correct. Option D is tricky. 
*A local variable will compile without an initialization if it isn’t referenced anywhere or it is assigned a value before it is referenced.

26. C. Since defaultValue is an instance variable, it is automatically initialized to the corresponding value for that type. 
For double, that value is 0.0. By contrast, it is 0 for int, long, and short. Therefore Option C is correct.
27. B. Option B is an example of autoboxing. Java will automatically convert from primitive to wrapper class types and vice versa. Option A is incorrect because you can only call methods
on an object. Option C is incorrect because this method is used for converting to a wrapper class from a String. Option D is incorrect because autoboxing will convert the primitive to
an object before adding it to the ArrayList.
28. C. Java does not allow calling a method on a primitive. While autoboxing does allow the assignment of an Integer to an int, it does not allow calling an instance method on a
primitive. Therefore, the last line does not compile.
29. D. In order to call a constructor, you must use the new keyword. It cannot be called as if it was a normal method. This rules out Options A and B. Further, Option C is incorrect
because the parentheses are required.
30. A. Option A (I) correctly assigns the value to both variables. II does not compile as dog does not have a type. Notice the semicolon in that line, which starts a new statement. III
compiles but only assigns the value to dog since a declaration only assigns to one variable rather than everything in the declaration. IV does not compile because the type should only
be specified once per declaration.

31. C. The wrapper class for int is Integer and the wrapper class for char is Character. All other primitives have the same name. For example, the wrapper class for boolean is Boolean.
32. A. Assuming the variables are not primitives, they allow a null assignment. The other statements are false.
33. A. An example of a primitive type is int. All the primitive types are lowercase, making Option A correct. Unlike object reference variables, primitives cannot reference null.
String is not a primitive as evidenced by the uppercase letter in the name and the fact that we can call methods on it. You can create your own classes, but not primitives.
34. D. While you can suggest to the JVM that it might want to run a garbage collection cycle, the JVM is free to ignore your suggestion. Option B is how to make this suggestion. Since
garbage collection is not guaranteed to run, Option D is correct.
35. C. All three references point to the String apple. This makes the other two String objectseligible for garbage collection and Option C correct.

36. B. A constructor can only be called with a class name rather than a primitive, making Options A and C incorrect. The newly constructed Double object can be assigned to either
a double or Double thanks to autoboxing. Therefore, Option B is correct.
37. B. First line 2 runs and sets the variable using the declaration. Then the instance initializer on line 6 runs. Finally, the constructor runs. Since the constructor is the last to run of the
three, that is the value that is set when we print the result, so Option B is correct.
38. C. Objects are allowed to have a null reference while primitives cannot. int is a primitive, so assigning null to it does not compile. Integer and String are both objects and
can therefore be assigned a null reference. Therefore, Option C is correct.
39. C. An instance variable can only be referenced from instance methods in the class. A static variable can be referenced from any method. Therefore, Option C is correct.
40. B. Underscores are allowed between any two digits in a numeric literal. Underscores are not allowed adjacent to a decimal point, making Option B the correct answer.

41. A. These four types represent nondecimal values. While you don’t need to know the exact sizes, you do need to be able to order them from largest to smallest. A byte is smallest.
A short comes next, followed by int and then long. Therefore, Option A is correct.
42. A. Java uses dot notation to reference instance variables in a class, making Option A correct.
43. B. If there was a finalize() method, this would be a different story. However, the method here is finalizer. Tricky! That’s just a normal method that doesn’t get called automatically. Therefore clean is never output.
44. A. Options B and C do not compile. In Java, braces are for arrays rather than instance variables. Option A is the correct answer. It uses dot notation to access the instance variable. 
It also shows that a private variable is accessible in the same class and that a narrower type is allowed to be assigned to a wider type.
45. B. The parseInt() methods return a primitive. The valueOf() methods return a wrapper class object. In real code, autoboxing would let you assign the return value to either a
primitive or wrapper class. In terms of what gets returned directly, Option B is correct.

46. B. 
-On line 9, all three objects have references / An object representing elena is created. elena holds a reference to it
-If an object is reachable, it cannot be garbage collected.
-elena.youngestChild = diana;: The diana object is now also reachable through elena.youngestChild.
-diana = null;: The diana variable is set to null. However, the diana object is NOT garbage collected because it's still reachable through elena.youngestChild.
-elena.youngestChild = zoe;: The zoe object is now reachable through elena.youngestChild. The diana object is now unreachable from the root set. 
                             Therefore the diana object is now eligible for garbage collection.
-zoe = null;: The zoe variable is set to null. However, the zoe object is not garbage collected because it's still reachable through elena.youngestChild.

47. C. Options A and B are static methods rather than constructors. Option D is a method that happens to have the same name as the class. It is not a constructor because constructors don’t have return types.
48. A. Remember that garbage collection is not guaranteed to run on demand. If it doesn’t run at all, Option B would be output. If it runs at the requested point, Option C would be output. 
If it runs right at the end of the main() method, Option D would be output. Option A is the correct answer because play is definitely called twice. Note that you are unlikely
to see all these scenarios if you run this code because we have not used enough memory for garbage collection to be worth running. 
However, you still need to be able to answer what could happen regardless of it being unlikely.
49. B. Each wrapper class has a constructor that takes the primitive equivalent. The methods mentioned in Options A, C, and D do not exist.
50. C. The main() method calls the constructor which outputs a. Then the main method calls the run() method. The run() method calls the constructor again, which outputs a again.
Then the run() method calls the Sand() method, which happens to have the same name as the constructor. This outputs b. Therefore, Option C is correct.



















-
