Not Very easy but EASY. :D



*** যদি আমি Operator and Decision Constructor সঠিক ব্যবহার না জানি, তাহলে আমি কী কী সমস্যার সম্মুখীন হব?


===================================  কিছু প্রশ্ন ==============================================

১. একটি ব্যাংকিং সিস্টেমে, একজন গ্রাহক যদি তার অ্যাকাউন্টে পর্যাপ্ত ব্যালেন্স থাকে তবেই টাকা তুলতে পারবে। 
   আপনি কীভাবে এই লেনদেনের নিয়মটি আপনার প্রোগ্রামে অন্তর্ভুক্ত করবেন?

২.  ধরুন, আপনি একটি অনলাইন শপিং ওয়েবসাইটে একটি নির্দিষ্ট মূল্যের বেশি কিনলে বিনামূল্যে শিপিংয়ের সুবিধা দিতে চান।
    আপনি কীভাবে এই শর্তটি আপনার প্রোগ্রামে বাস্তবায়ন করবেন যাতে ব্যবহারকারীকে শিপিং চার্জের বিষয়ে সঠিক তথ্য দেখানো যায়?

৩. একটি বিদ্যালয়ে, শিক্ষার্থীদের তাদের প্রাপ্ত নম্বরের ভিত্তিতে গ্রেড দেওয়া হয় (যেমন, ৮০-১০০ পেলে 'A', ৭০-৭৯ পেলে 'B', ইত্যাদি)। 
    অপারেটর এবং ডিসিশন কনস্ট্রাক্ট ছাড়া, আপনি কীভাবে প্রতিটি শিক্ষার্থীর জন্য সঠিক গ্রেড নির্ধারণ করবেন?



=======================================================================================================
This chapter covers essential Java concepts related to:
1. - Conditional statements (if-then, switch-case,default,final,constant,literal,break)
2. - Ternary operators
3. - Logical and Bitwise operators
4. - Operator precedence
5. - Object comparison (== vs equals())
   - Common Pitfalls to Avoid

#### 1. Control Flow Statements ####
- if-then-else: Executes blocks conditionally (no required else)
- switch: Works with byte, short, char, int, String, enums (** NOT long/double)
  - case values must be compile-time constants -`case` স্টেটমেন্টের মান ধ্রুবক, একটি লিটারেল মান, বা ফাইনাল ভেরিয়েবল হতে হবে।
  - break prevents fall-through ( `switch` স্টেটমেন্টে কোনো `break` স্টেটমেন্ট নেই ? সমস্ত `case` স্টেটমেন্ট execute করা হবে।)
  - default is optional and can be placed anywhere

#### 2. Ternary Operator ####
- Ternary (? :): Compact if-else replacement (must return compatible types)
   গুরুত্বপূর্ণ বিষয়:
   -টারনারি অপারেটর কোডকে সংক্ষিপ্ত করে তোলে, তবে অতিরিক্ত ব্যবহার কোডকে পড়তে কঠিন করে তুলতে পারে, বিশেষ করে যখন শর্তগুলি জটিল হয়।
   -valueIfTrue এবং valueIfFalse এর ডেটা টাইপ একই অথবা সামঞ্জস্যপূর্ণ (compatible) হতে হবে।
      eX_1: gradeValue = (score > 90) ? 4.0 : 3.0; // 4.0 (double), 3.0 (double)  // যদি একটি int হয়, যেমন (score > 90) ? 4.0 : 3, তাহলে 3 স্বয়ংক্রিয়ভাবে double এ convert হবে।
        eX_2: 
         boolean isText = true;
         Object data; // Object একটি জেনেরিক ক্লাস যা অন্য যেকোনো অবজেক্টকে ধারণ করতে পারে।
         data = (isText) ? "হ্যালো ওয়ার্ল্ড" : 123; //যেহেতু String এবং Integer উভয়ই Object ক্লাসকে ইনহেরিট করে (বাস্তবে Object তাদের প্যারেন্ট ক্লাস), তাই এই অ্যাসাইনমেন্ট সামঞ্জস্যপূর্ণ।

#### 3. Logical and Bitwise operators ####
      ### Short-circuit (&&, ||) vs non-short-circuit (&, |) *** শুধুমাত্র বুলিয়ান (boolean) টাইপের অপারেন্ডের সাথে কাজ করে | আপনি দুটি Integer অবজেক্টের উপর সরাসরি && অপারেটর ব্যবহার করতে পারবেন না। 
             int a = 5;  int b = 0;
         && (Logical AND - লজিক্যাল অ্যান্ড): -`&&` অপারেটর শুধুমাত্র তখনই এক্সপ্রেশনের ডান দিকটি নির্বাহ করে যদি এক্সপ্রেশনের বাম দিকটি সত্য হয়। 
                                           -যদি প্রথম অপারেন্ড (operand1) false হয়, তাহলে দ্বিতীয় অপারেন্ড (operand2) আর মূল্যায়ন করা হয় না, কারণ ফলাফল নিশ্চিতভাবে false হবে।
                                           eX: if ((a < 5) && (b != 0)) { // (5 < 5) is false, so (b != 0) is skipped
         || (Logical OR - লজিক্যাল অর): যদি প্রথম অপারেন্ড (operand1) true হয়, তাহলে দ্বিতীয় অপারেন্ড (operand2) আর মূল্যায়ন করা হয় না, কারণ ফলাফল নিশ্চিতভাবে true হবে।
                                          eX: if ((a > 3) || (b / a == 0)) { // (5 > 3) is true, so (b / a == 0) is skipped
         এদেরকে "শর্ট-সার্কিট" বলা হয় কারণ প্রয়োজনে এরা দ্বিতীয় অংশটি এড়িয়ে যেতে পারে, যা পারফরম্যান্সের জন্য ভালো এবং NullPointerException এর মতো ত্রুটি এড়াতে সাহায্য করে।
            
      ### NON-SHORT-CIRCUIT/Bitwise(&(AND) =যদি দুটি বিটই 1 হয়, তাহলে ফলাফল বিট 1 হবে; অন্যথায় 0 হবে।), |(OR) = যদি দুটি বিটের মধ্যে অন্তত একটি 1 হয়, তাহলে ফলাফল বিট 1 হবে; অন্যথায় 0 হবে|)
            & (Logical AND - লজিক্যাল অ্যান্ড): উভয় অপারেন্ডই (operand1 এবং operand2) সবসময় মূল্যায়ন করা হয়, এমনকি যদি প্রথম অপারেন্ডের ফলস্বরূপ ফলাফল নিশ্চিত হয়।
                                          eX: boolean resultAnd = (a < 5) & (b == 0); // (false) & (true) -> false
            | (Logical OR - লজিক্যাল অর): উভয় অপারেন্ডই (operand1 এবং operand2) সবসময় মূল্যায়ন করা হয়, এমনকি যদি প্রথম অপারেন্ডের ফলস্বরূপ ফলাফল নিশ্চিত হয়।
                                          eX: boolean resultOr = (a > 3) | (b == 0); // (true) | (true) -> true
            সাধারণত, পারফরম্যান্স এবং ত্রুটি এড়ানোর জন্য শর্ট-সার্কিট অপারেটরগুলোই বেশি ব্যবহৃত হয়। নন-শর্ট-সার্কিট অপারেটরগুলো বিটওয়াইজ অপারেশন (bitwise operations) হিসেবেও ব্যবহৃত হয়।
      ### XOR (^): (caret) চিহ্ন
          eX: এই অপারেটরটি তখনই true রিটার্ন করে যখন এর উভয় দিকের অপারেন্ডের মান ভিন্ন হয়। যদি উভয় অপারেন্ডের মান একই হয় (true এবং true অথবা false এবং false), তাহলে এটি false রিটার্ন করবে।
              boolean condition1 = true;
              boolean condition2 = false;
                 // যদি condition1 এবং condition2 ভিন্ন হয়, তাহলে result হবে true।
                 boolean result1 = condition1 ^ condition2; // true ^ false -> true // আউটপুট: true


- Increment/decrement: 
  - Pre (++x): প্রথমে ভেরিয়েবলের মান 1 বাড়ায়, তারপর বর্ধিত মানটি রিটার্ন করে। Ex: int x=5; y = ++x;  আউটপুট: x=6; y=6;
  - Post (x++): প্রথমে ভেরিয়েবলের বর্তমান মান রিটার্ন করে, তারপর ভেরিয়েবলের মান 1 বাড়ায়। Ex: int x=5; int y = x++;(x এর বর্তমান মান 5, যা y তে অ্যাসাইন হবে। তারপর x এর মান 6 হবে।) আউটপুট: x=6; y=5;


#### 4. Object Comparison ####
- ==: Compares references (memory location)
- equals(): Compares content/values (must be overridden properly)
- String literals vs new String() behavior

#### 5. Operator Precedence ####
- Arithmetic: +, -, *, /, % (modulus)
Highest to lowest:
   1. Postfix (x++, x--)     2. Unary (++x, --x, !, ~)      3. Multiplicative (, /, %)    4. Additive (+, -)      5. Relational (<, >, <=, >=, instanceof) 
   6. Equality (==, !=)      7. Logical AND (&&)            8. Logical OR (||)            9. Ternary (? :)        10. Assignment (=, +=, etc.)


## Common Pitfalls to Avoid

1. Assuming == compares object content - it compares references
2. Forgetting break in switch statements - causes fall-through
3. Mixing types in ternary operations - both branches must be compatible
     -System.out.print(leaders + followers < 10 ? "Too few" : "Too many"); //work withuot any issue
4. Ignoring operator precedence - use parentheses when unsure
     -int leaders = 10 * (2 + (1 + 2 / 5)); //why result 30
5. Using assignment (=) instead of equality (==) in conditions
6. Applying operators to incompatible types (e.g., boolean with arithmetic)
7. Know increment/decrement timing

8. switch-case alternative of  if-then, 
  - switch: Works with byte, short, char, int, String, enums (** NOT long/double)
  - case values must be compile-time constants 
      -`case` স্টেটমেন্টের মান ধ্রুবক(final), বা  একটি লিটারেল(literal) মান, ভেরিয়েবল হতে হবে।
      - প্রতিটি case লেবেল একটি কন্সট্যান্ট (constant) মান হতে হবে। ভেরিয়েবল (variable) ব্যবহার করা যাবে না। যেমন, case 1: বা case "Apple": বৈধ, কিন্তু case x: (যেখানে x একটি ভেরিয়েবল) অবৈধ।
      - ডুপ্লিকেট case মান অনুমোদিত নয়: একই switch স্টেটমেন্টের মধ্যে দুটি case লেবেলের একই মান থাকতে পারবে না। যেমন, case 1: এবং আবার case 1: লেখা যাবে না।
  - default is optional and can be placed anywhere
  - break prevents fall-through ( `switch` স্টেটমেন্টে কোনো `break` স্টেটমেন্ট নেই ? সমস্ত `case` স্টেটমেন্ট execute করা হবে।)

9. Pre-Increment (++x): First, it increases the value of the variable by 1, then it returns the new, incremented value.
   Post-Increment (x++): First, it returns the variable's current value, then it increases the value of the variable by 1.

- &(AND Operator) vs &&(Logical AND,  Short-circuit)=2true |(OR) vs ||(Logical OR)=any 1true, , ^(bitwise Ex-OR)=oposite ভিন্ন হয়, তাহলে result হবে true|
      *** শুধুমাত্র বুলিয়ান (boolean) টাইপের অপারেন্ডের সাথে কাজ করে | আপনি দুটি Integer অবজেক্টের উপর সরাসরি && অপারেটর ব্যবহার করতে পারবেন না। 
- Long Logical(AND and OR) operator use:
       -public static void main(String... data) {
              if(data.length>=1 && (data[0].equals("sound") || data[0].equals ("logic")) && data.length<2) { //is it possible
              System.out.print(data[0]);
              }
       -public static void main(String... weather) {
               System.out.print(weather[0]!=null && weather[0].equals("sunny") && !false ? "Go Outside" : "Stay Inside");
              }

- if-else statement new idea to write:
       -public String runTest(boolean spinner, boolean roller) {
           if(spinner = roller) return "up";
           else return roller ? "down" : "middle";
           }




====================== Chapter_03(Using Operators and Decision Constructs) ==================

2,5,9,14,16,17,20,22,24,29,34,35,36,38,42,46,48= 17 total

 2,5,6,*9,*10,11,12,*13,*14,*15,16,*17,18,*19,20,23,24,26,27,29,30,*33,*36,37,40,43,44,46,*48,*49=30


1. Which of the following variable types is not permitted in a switch statement?
        A. String
        B. double
        C. int
        D. char
        
2. What is the value of tip after executing the following code snippet?
        int meal = 5;
        int tip = 2;
        int total = meal + (meal>6 ? ++tip : --tip);
        A. 1
        B. 2
        C. 3
        D. 6
        
3. What is the output of the following application?
        package registration;
        public class NameCheck {
        public static void main(String... data) {
        String john = "john";
        String jon = new String(john);
        System.out.print((john==jon)+" "+(john.equals(jon)));
        }
        }
        A. true true
        B. true false
        C. false true
        D. false false
        
4. What is the output of the following application?
        package planning;
        public class ThePlan {
        public static void main(String[] input) {
        int plan = 1;
        plan = plan++ + --plan;
        if(plan==1) {
        System.out.print("Plan A");
        } else { if(plan==2) System.out.print("Plan B");
        } else System.out.print("Plan C");
        }
        }
        A. Plan A
        B. Plan B
        C. Plan C
        D. None of the above
        
5. Which of the following statements about a default branch in a switch statement is correct?
        A. All switch statements must include a default statement.
        B. The default statement is required to be placed after all case statements.
        C. Unlike a case statement, the default statement does not take a value.
        D. A default statement can only be used when at least one case statement is present.
        
6. What is the value of thatNumber after the execution of the following code snippet?
        long thatNumber = 5 >= 5 ? 1+2 : 1*1;
        if(++thatNumber < 4)
        thatNumber += 1;
        A. 3
        B. 4
        C. 5
        D. The answer cannot be determined until runtime.
        
7. Which statement immediately exits a switch statement, skipping all remaining case or default branches?
        A. exit
        B. break
        C. goto
        D. continue
        
8. Which statement about ternary expressions is true?
        A. In some cases, both expressions to the right of the conditional operator in a ternary expression will be evaluated at runtime.
        B. Ternary expressions require parentheses for proper evaluation.
        C. The ternary expressions are a convenient replacement for an if-then-else statement.
        D. Ternary expressions support int and boolean expressions for the left-most operand.
        
9. What is the output of the following application?
        package voting;
        1: public class Election {
        2: public void calculateResult(Integer candidateA, Integer candidateB) {
        3: boolean process = candidateA == null || candidateA.intValue() < 10;
        4: boolean value = candidateA && candidateB;
        5: System.out.print(process || value);
        6: }
        7: public static void main(String[] unused) {
        8: new Election().calculateResult(null,203);
        9: }
        10: }
        A. true
        B. false
        C. The code does not compile.
        D. The code compiles but throws a NullPointerException on line 3 at runtime.
        
10. What is the output of the following application?
        package dinosaur;
        public class Park {
        public final static void main(String... arguments) {
        int pterodactyl = 6;
        long triceratops = 3;
        if(pterodactyl % 3 >= 1)
        triceratops++;
        triceratops--;
        System.out.print(triceratops);
        }
        }
        A. 2
        B. 3
        C. 4
        D. The code does not compile.
        
11. Which statement about if-then statements is true?
        A. An if-then statement is required to have an else statement.
        B. If the boolean test of an if-then statement evaluates to false, then the target clause of the if-then statement will still be evaluated.
        C. An if-then statement is required to cast an object.
        D. An if-then statement can execute a single statement or a block {}.
        
12. What is the output of the following application?
        package restaurant;
        public class Pieces {
        public static void main(String[] info) {
        int flair = 15;
        if(flair >= 15 && flair < 37) {
        System.out.print("Not enough");
        } if(flair==37) {
        System.out.print("Just right");
        } else {
        System.out.print("Too many");
        }
        }
        }
        A. Not enough
        B. Just right
        C. Too many
        D. None of the above
        
13. Which statement about case statements of a switch statement is not true?
        A. A case value can be final.
        B. A case statement must be terminated with a break statement.
        C. A case value can be a literal expression.
        D. A case value must match the data type of the switch variable, or be able to be promoted to that type.
        
14. Given the following truth table, which operator for the boolean expressions x and y corresponds to this relationship?
        -------------------------------------
                   |  x = true  |  x = false
        -------------------------------------
        y = true   |   true     |  false
        -------------------------------------
        y = false  |   false    |  false
        -------------------------------------
        A. --
        B. ++
        C. ||
        D. &&
        
15. What is the output of the following code snippet?
        int hops = 0;
        int jumps = 0;
        jumps = hops++;
        if(jumps)
        System.out.print("Jump!");
        else
        System.out.print("Hop!");
        
        A. Jump!
        B. Hop!
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.
        
16. Fill in the blanks: 
        __ The operator increases the value of a variable by 1 and returns the new value, while __ the operator decreases the value of a variable by 1 and returns the original value.
        A. pre-increment [++v], pre-decrement [--v]
        B. pre-increment [++v], post-decrement [v--]
        C. post-increment [v++], pre-decrement [--v]
        D. post-increment [v++], post-decrement [v--]
        
17. What is the output of the following application?
        package jungle;
        public class TheBigRace {
        public static void main(String[] in) {
        int tiger = 2;
        short lion = 3;
        long winner = lion+2*(tiger + lion);
        System.out.print(winner);
        }
        }
        A. 11
        B. 13
        C. 25
        D. None of the above
        
18. Given the following code snippet, assuming dayOfWeek is an int, what variable type of saturday is not permitted?
        __ final saturday = 6;
        switch(dayOfWeek) {
        default:
        System.out.print("Another Weekday");
        break;
        case saturday:
        System.out.print("Weekend!");
        }       
        A. byte
        B. long
        C. int
        D. None of the above
        
19. Given the following code snippet, what is the value of dinner after it is executed?
        int time = 11;
        int day = 4;
        String dinner = time > 10 ? day ? "Takeout" : "Salad" : "Leftovers";
        A. Takeout
        B. Salad
        C. The code does not compile but would compile if parentheses were added.
        D. None of the above
        
20. What is the output of the following application?
        package recreation;
        public class Dancing {
        public static void main(String[] vars) {
        int leaders = 10 * (2 + (1 + 2 / 5);
        int followers = leaders * 2;
        System.out.print(leaders + followers < 10 ? "Too few" : "Too many");
        }
        }
        A. Too few
        B. Too many
        C. The code does not compile.
        D. The code compiles but throws a division by zero error at runtime.
        
21. What is the output of the following application?
        package schedule;
        public class PrintWeek {
        public static final void main(String[] days) {
        System.out.print(5 + 6 + "7" + 8 + 9);
        }
        }
        A. 56789
        B. 11789
        C. 11717
        D. The code does not compile.
        
        
22. Fill in the blanks: __ The operator is used to find the difference between two numbers, 
    while __ operator is used to find the remainder when one number is divided by another.
        A. /, %
        B. –, %
        C. %, <
        D. –, ||
        
23. What is the output of the following application?
        package transporter;
        public class Rematerialize {
        public static void main(String[] input) {
        int dog = 11;
        int cat = 3;
        int partA = dog / cat;
        int partB = dog % cat;
        int newDog = partB + partA * cat;
        System.out.print(newDog);
        }
        }
        A. 9
        B. 11
        C. 15
        D. The code does not compile.
        
24. What is the output of the following application?
        package dessert;
        public class IceCream {
        public final static void main(String... args) {
        int flavors = 30;
        int eaten = 0;
        switch(flavors) {
        case 30: eaten++;
        case 40: eaten+=2;
        default: eaten--;
        }
        System.out.print(eaten);
        }
        }
        A. 1
        B. 2
        C. 3
        D. The code does not compile.
        
25. What is the output of the following application?
        package mode;
        public class Transportation {
        public static String travel(int distance) {
        return distance<1000 ? "train" : 10;
        }
        public static void main(String[] answer) {
        System.out.print(travel(500));
        }
        }
        A. train
        B. 10
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.
        
26. Fill in the blanks: 
    Given two non-null String objects with reference names apples and oranges, if apples __ oranges evaluates to true, then apples__ oranges must also evaluate to true.
        A. ==, equals()
        B. !=, equals()
        C. equals(), ==
        D. equals(), =!
        
27. For a given non-null String myTestVariable, what is the resulting value of executing the statement myTestVariable.equals(null)?
        A. true
        B. false
        C. The statement does not compile.
        D. The statement compiles but will produce an exception when used at runtime.
        
28. How many 1s are outputted when the following application is compiled and run?
        package city;
        public class Road {
        public static void main(String... in) {
        int intersections = 100;        
        int streets = 200;
        if (intersections < 150) {
        System.out.print("1");
        } else if (streets && intersections > 1000) {
        System.out.print("2");
        } if (streets < 500)
        System.out.print("1");
        else
        System.out.print("2");
        }
        }
        A. None
        B. One
        C. Two
        D. The code does not compile.
        
29. Which statement about the logical operators & and && is true?
        A. The & and && operators are interchangeable, always producing the same results at runtime.
        B. The & operator always evaluates both operands, while the && operator may only evaluate the left operand.
        C. Both expressions evaluate to true if either operand is true.
        D. The & operator always evaluates both operands, while the && operator may only evaluate the right operand.
        
30. What is the output of the following code snippet?
        int x = 10, y = 5;
        boolean w = true, z = false;
        x = w ? y++ : y--;
        w = !z;
        System.out.print((x+y)+" "+(w ? 5 : 10));
        A. The code does not compile.
        B. 10 10
        C. 11 5
        D. 12 5
        
31. What is the output of the following application?
        package bob;
        public class AreYouBob {
        public static void main(String[] unused) {
        String bob = new String("bob");
        String notBob = bob;
        System.out.print((bob==notBob)+" "+(bob.equals(notBob)));
        }
        }
        A. true true
        B. true false
        C. false true
        D. false false
        
32. What is the value of 12 + 6 * 3 % (1 + 1) in Java?
        A. 0
        B. 12
        C. 14
        D. None of the above
        
33. Given the following truth table, the boolean variables p and q, and the expression p ^ q,
        what are the missing values in the truth table, starting with the first column?
        ------------------------------
                    p = true   |  p = false
        ------------------------------
        q = true  |    false   |  true
        q = false |            |
        ------------------------------
        A. false and true
        B. false and false
        C. true and true
        D. true and false
        
34. Which of the following is not a possible result of executing the following application?
        public class ConditionallyLogical {
        public static void main(String... data) {
        if(data.length>=1 && (data[0].equals("sound") || data[0].equals ("logic")) && data.length<2) {
        System.out.print(data[0]);
        }
        }
        }        
        A. Nothing is printed.
        B. sound is printed.
        C. The application throws an exception at runtime.
        D. logic is printed.
        
35. Fill in the blanks: The operators +,__,__, and ++ are listed in the same or increasing level of operator precedence.
        A. *, --, /
        B. %, -, *
        C. /, *, %
        D. *, -, /
        
36. What statement about the ^ operator is correct?
        A. If one of the operands of ^ is true, then the result is always true.
        B. There is a conditional form of the operator, denoted as ^^.
        C. If both operands of ^ are true, the result is true.
        D. The ^ operator can only be applied to boolean values.

37. Given the following Venn diagram and the variables, x, y, and z, which Java expression most closely represents the filled-in region of the diagram?
        x        y
            z
        A. x || z
        B. y || (y && z)
        C. x || y
        D. y && x
        
38. What variable type of red allows the following application to compile?
        package tornado;
        public class Kansas {
        public static void main(String[] args) {
        int colorOfRainbow = 10;
        __ red = 5;
        switch(colorOfRainbow) {
        default:
        System.out.print("Home");
        break;
        case red:
        System.out.print("Away");
        }
        }
        }
        A. long
        B. double
        C. int
        D. None of the above
        
39. Which two operators would be used to test if a number is equal to or greater than 5.21 but strictly less than 8.1?
        A. > and <=
        B. >= and >
        C. < and >=
        D. < and >
        
40. What is the output of the following application?
        package transporter;
        public class TurtleVsHare {
        public static void main(String[] arguments) {
        int turtle = 10 * (2 + (3 + 2) / 5);
        int hare = turtle < 5 ? 10 : 25;
        System.out.print(turtle < hare ? "Hare wins!" : "Turtle wins!");
        }
        }
        A. Hare wins!
        B. Turtle wins!
        C. The code does not compile.
        D. The code compiles but throws a division by zero error at runtime.
        
41. What is the output of the following application?
        public class CountEntries {
        public static int getResult(int threshold) {
        return threshold > 5 ? 1 : 0;
        }
        public static final void main(String[] days) {
        System.out.print(getResult(5)+getResult(1)+getResult(0)+getResult(2)+"");
        }
        }
        A. 0
        B. 1
        C. 0000
        D. 1000
        
42. What is the output of the following application?
        package yoyo;
        public class TestGame {
        public String runTest(boolean spinner, boolean roller) {
        if(spinner = roller) return "up";
        else return roller ? "down" : "middle";
        }
        public static final void main(String pieces[]) {
        final TestGame tester = new TestGame();
        System.out.println(tester.runTest(false,true));
        }
        }
        A. up
        B. middle
        C. down
        D. The code does not compile.
        
43. Fill in the blanks: The ___ operator is true if either of the operands are true, while the ___ operator flips a boolean value.
        A. +, -
        B. &&, !
        C. |, -
        D. ||, !
        
44. Given the following code snippet, what is the value of movieRating after it is executed?
        int characters = 5;
        int story = 3;
        double movieRating = characters <= 4 ? 3 : story>1 ? 2 : 1;
        A. 2.0
        B. 3.0
        C. The code does not compile but would compile if parentheses were added.
        D. None of the above
        
45. Fill in the blanks: A switch statement can have ____ case statements and __ default statements.
        A. at most one, at least one
        B. any number of, at most one
        C. at least one, any number of
        D. at least one, at most one
        
46. Which of the following is not a possible result of executing the following application?
        public class OutsideLogic {
        public static void main(String... weather) {
         System.out.print(weather[0]!=null && weather[0].equals("sunny") && !false ? "Go Outside" : "Stay Inside");
        }
        }
        A. Nothing is printed.
        B. The application throws an exception at runtime.
        C. Go Outside is printed.
        D. Stay Inside is printed.
        
47. What is the value of (5 + (!2 + 8) * 3 - 3 % 2)/2 in Java?
        A. 2
        B. 11
        C. 16
        D. None of the above
        
48. Given the following truth table, the boolean variables w and z, and the expression w || z,
        what are the missing values in the truth table, starting with the first row?
        -------------------------------
                  w = true | w = false
        -------------------------------
        z = true     true  | 
        z = false          | false  
        --------------------------------
        A. false and false
        B. true and false
        C. true and true
        D. false and true
        
49. Fill in the blanks: The operators –,__,__,__, and % are listed in the same or increasing level of operator precedence.
        A. +, /, *
        B. --, -, *
        C. ++, /, *
        D. *, ++, %

50. What is the output of the following application?
        public class Baby {
        public static String play(int toy, int age) {
        final String game;
        if(toy<2)
        game = age > 1 ? 1 : 10; // p1
        else
        game = age > 3 ? "Ball" : "Swim"; // p2
        return game;
        }
        public static void main(String[] variables) {
        System.out.print(play(5,2));
        }
        }
        A. Ball
        B. Swim
        C. The code does not compile due to p1.
        D. The code does not compile due to p2.
        

========================== Chapter 3: Using Operators and Decision Constructs ===================================

2.A, 5.C, 9.C, 14.D, 16.B, 17.B, 20.C, 22.B, 24.B, 
29.B, 34.C, 35.C, 36.D, 38.D, 42.A, 46.A, 48.C

১. বি. একটি `switch` স্টেটমেন্ট প্রিমিটিভ টাইপ `byte`, `short`, `char`, এবং `int` এবং ক্লাস `String`, `Character`, `Byte`, `Short`, এবং `Integer` সমর্থন করে। এটি এনুমারেটেড টাইপও সমর্থন করে। `float` এবং `double`-এর মতো ফ্লোটিং-পয়েন্ট টাইপ সমর্থিত নয়, তাই অপশন বি সঠিক উত্তর।
২. এ. মনে রাখবেন যে টার্নারি এক্সপ্রেশনে, ডানদিকের দুটি এক্সপ্রেশনের মধ্যে শুধুমাত্র একটি মূল্যায়ন করা হয়। যেহেতু `meal>6` মিথ্যা, তাই `--tip` মূল্যায়ন করা হয় এবং `++tip` বাদ দেওয়া হয়। এর ফলে `tip`-এর মান 2 থেকে 1-এ পরিবর্তিত হয়, যা অপশন এ-কে সঠিক উত্তর করে তোলে। `total`-এর মান 6, যেহেতু `tip`-এর উপর প্রি-ইনক্রিমেন্ট অপারেটর ব্যবহার করা হয়েছিল, যদিও প্রশ্নটি সমাধানের জন্য আপনার এটি জানার প্রয়োজন ছিল না।
৩. সি. প্রথম অ্যাসাইনমেন্ট একটি নতুন `String` "john" অবজেক্ট তৈরি করে। দ্বিতীয় লাইন স্পষ্টভাবে `new` কীওয়ার্ড ব্যবহার করে, যার অর্থ একটি নতুন `String` অবজেক্ট তৈরি হয়। যেহেতু এই অবজেক্টগুলো একই নয়, তাই এদের উপর `==` পরীক্ষাটি মিথ্যা হয়। এদের উপর `equals()` পরীক্ষাটি সত্য হয় কারণ তারা যে মানগুলোকে নির্দেশ করে সেগুলো সমতুল্য। সুতরাং, সঠিক উত্তর হল সি।
৪. ডি. এই কোডটি কম্পাইল হবে না কারণ এতে একটি `if-then` স্টেটমেন্টের অংশ হিসেবে দুটি `else` স্টেটমেন্ট রয়েছে। লক্ষ্য করুন যে দ্বিতীয় `if` স্টেটমেন্টটি শেষ `else` স্টেটমেন্টের সাথে সংযুক্ত নয়। এই কারণে, অপশন ডি, উপরের কোনটিই নয়, সঠিক উত্তর।
৫. সি. একটি `switch` স্টেটমেন্টের ভিতরে একটি `default` স্টেটমেন্ট ঐচ্ছিক এবং `switch`-এর `case` স্টেটমেন্টের মধ্যে যেকোনো ক্রমে স্থাপন করা যেতে পারে, যা অপশন এ এবং বি-কে ভুল করে। 
        অপশন ডি একটি ভুল স্টেটমেন্ট কারণ একটি `switch` স্টেটমেন্ট একটি একক `default` স্টেটমেন্ট এবং কোনো `case` স্টেটমেন্ট ছাড়াই গঠিত হতে পারে। 
         অপশন সি সঠিক কারণ একটি `default` স্টেটমেন্ট একটি `case` স্টেটমেন্টের মতো কোনো মান নেয় না।

৬. বি. `thatNumber`-এর প্রাথমিক অ্যাসাইনমেন্ট টার্নারি এক্সপ্রেশনের প্রথম শাখা অনুসরণ করে। যেহেতু `5 >= 5` সত্য হয়, তাই `thatNumber`-এ 3 মানটি অ্যাসাইন করা হয়। পরবর্তী লাইনে, প্রি-ইনক্রিমেন্ট অপারেটর `thatNumber`-এর মান 4-এ বৃদ্ধি করে এবং এক্সপ্রেশনে 4 মানটি ফেরত দেয়। যেহেতু `4 < 4` মিথ্যা হয়, তাই `if-then` ব্লকটি বাদ দেওয়া হয়। এর ফলে `thatNumber`-এর মান 4 থাকে, যা অপশন বি-কে সঠিক উত্তর করে তোলে।
৭. বি. `break` স্টেটমেন্ট একটি `switch` স্টেটমেন্ট থেকে বেরিয়ে আসে, সমস্ত অবশিষ্ট শাখা বাদ দিয়ে, যা অপশন বি-কে সঠিক উত্তর করে তোলে। অপশন এ-তে, `exit` জাভাতে কোনো স্টেটমেন্ট নয়। অপশন সি-তে, `goto` একটি সংরক্ষিত শব্দ কিন্তু জাভাতে অব্যবহৃত। অবশেষে, অপশন ডি-তে, `continue` একটি স্টেটমেন্ট কিন্তু শুধুমাত্র লুপের জন্য ব্যবহৃত হয়।
৮. সি. অপশন এ ভুল কারণ রানটাইমে ডানদিকের দুটি এক্সপ্রেশনের মধ্যে শুধুমাত্র একটি মূল্যায়ন করা হয়। টার্নারি এক্সপ্রেশন পড়ার জন্য বন্ধনী প্রায়শই সহায়ক তবে প্রয়োজনীয় নয়, যা অপশন বি-কে ভুল করে। অপশন সি টার্নারি অপারেটর সম্পর্কে একটি সঠিক স্টেটমেন্ট কারণ এগুলো সাধারণত ছোট `if-then-else` স্টেটমেন্ট প্রতিস্থাপনের জন্য ব্যবহৃত হয়। অবশেষে, অপশন ডি ভুল কারণ টার্নারি এক্সপ্রেশনের বামদিকের অপারেন্ডে শুধুমাত্র বুলিয়ান এক্সপ্রেশন অনুমোদিত।
৯. সি. লাইন 4-এ, `candidateA` এবং `candidateB` সংখ্যা, কিন্তু `&&` অপারেশন শুধুমাত্র বুলিয়ান এক্সপ্রেশনের উপর প্রয়োগ করা যেতে পারে। 
       সুতরাং, লাইন 4-এর কারণে কোডটি কম্পাইল হবে না, যা সি-কে সঠিক উত্তর করে তোলে। অন্য সমস্ত লাইন সঠিক। 
        মনে রাখবেন যে যদি লাইন 4 ঠিক করা হয়, তবে লাইন 3 রানটাইমে `NullPointerException` তৈরি করবে না। 
        কন্ডিশনাল `||` এবং পূর্ববর্তী নাল চেক কোডটিকে শুধুমাত্র `intValue()` কল করার অনুমতি দেয় যদি `candidateA` নাল না হয়।
১০. এ. প্রথম ধাপ হল `if-then` স্টেটমেন্টের এক্সপ্রেশনটি নির্বাহ করা হবে কিনা তা নির্ধারণ করা। `6 % 3` এক্সপ্রেশনটি 0-এ মূল্যায়ন করে, যেহেতু কোনো অবশিষ্ট নেই, এবং যেহেতু `0 >= 1` মিথ্যা, তাই `triceratops++` কল করা হয় না। লক্ষ্য করুন `if-then` স্টেটমেন্টে কোনো ব্র্যাকেট `{}` নেই। `triceratops--` লাইনটি ইন্ডেন্ট করা সত্ত্বেও, এটি `if-then` স্টেটমেন্টের অংশ নয়। মনে রাখবেন যে জাভা স্টেটমেন্টের শুরু বা শেষ নির্ধারণের জন্য ইন্ডেন্টেশন ব্যবহার করে না। সুতরাং, `triceratops--` সর্বদা নির্বাহ করা হয়, যার ফলে `triceratops`-এর মান 2 হয় এবং অপশন এ-কে সঠিক উত্তর করে তোলে।

১১. ডি. অপশন এ ভুল কারণ `else` স্টেটমেন্ট সম্পূর্ণরূপে ঐচ্ছিক। অপশন বি-ও ভুল। বুলিয়ান পরীক্ষা মিথ্যা হলে `if-then` স্টেটমেন্টের লক্ষ্য মূল্যায়ন করা হয় না। অপশন সি ভুল। যদিও একটি `if-then` স্টেটমেন্ট প্রায়শই কোনো অবজেক্ট কোনো নির্দিষ্ট টাইপের কিনা তা পরীক্ষা করার জন্য ব্যবহৃত হয় যাতে এটিকে কাস্ট করা যায়, তবে অবজেক্ট কাস্ট করা বাধ্যতামূলক নয়। অপশন ডি সঠিক কারণ একটি `if-then` স্টেটমেন্ট একটি একক স্টেটমেন্ট বা কোডের একটি ব্লক `{}` নির্বাহ করতে পারে।
১২. ডি. এই প্রশ্নের জন্য, এটি লক্ষ্য করা সহায়ক যে দ্বিতীয় `if-then` স্টেটমেন্টটি প্রথম `if-then` স্টেটমেন্টের সাথে সংযুক্ত নয়, কারণ তাদের যোগদানকারী কোনো `else` নেই। যখন এই কোডটি নির্বাহ হয়, তখন প্রথম `if-then` স্টেটমেন্ট `Not enough` আউটপুট করে কারণ `flair` >= 15 এবং < 37। তারপর দ্বিতীয় `if-then` স্টেটমেন্টটি মূল্যায়ন করা হয়। যেহেতু `flair` 37 নয়, তাই `Too many` এক্সপ্রেশনটি আউটপুট হয়। যেহেতু দুটি স্টেটমেন্ট আউটপুট হয়, অপশন ডি, উপরের কোনটিই নয়, সঠিক উত্তর।
১৩. বি. একটি `case` মান অবশ্যই একটি ধ্রুবক এক্সপ্রেশন হতে হবে, যেমন একটি লিটারেল বা ফাইনাল ভেরিয়েবল, তাই অপশন এ এবং সি `case` মান সম্পর্কে সত্য স্টেটমেন্ট। একটি `case` স্টেটমেন্ট একটি `break` স্টেটমেন্ট দ্বারা সমাপ্ত হতে পারে, তবে এটি বাধ্যতামূলক নয়, যা অপশন বি-কে মিথ্যা স্টেটমেন্ট এবং সঠিক উত্তর করে তোলে। অপশন ডি-ও `case` মান সম্পর্কে একটি সত্য স্টেটমেন্ট।
১৪. ডি. প্রশ্নটি বুলিয়ান অপারেটর সম্পর্কে। যেহেতু অপশন এ এবং বি সংখ্যাসূচক অপারেটর, তাই এগুলো তাৎক্ষণিকভাবে বাতিল করা যেতে পারে। প্রশ্নটি তখন সরলীকৃত হয় কোন বুলিয়ান এক্সপ্রেশন, `&&` বা `||`, সেই সত্য সারণীর সাথে সঙ্গতিপূর্ণ যা শুধুমাত্র তখনই সত্য হয় যদি উভয় অপারেন্ড সত্য হয়। শুধুমাত্র সংযোজক যৌক্তিক `&&` অপারেটর এই সম্পর্কটি উপস্থাপন করে, যা অপশন ডি-কে সঠিক উত্তর করে তোলে।
১৫. সি. `jumps` এবং `hops`-এর মান গুরুত্বপূর্ণ নয় কারণ এই কোডটি কম্পাইল হবে না, যা অপশন সি-কে সঠিক উত্তর করে তোলে। অন্যান্য কিছু প্রোগ্রামিং ভাষার বিপরীতে, জাভা `if-then` স্টেটমেন্টে ব্যবহারের জন্য স্বয়ংক্রিয়ভাবে পূর্ণসংখ্যাকে বুলিয়ান মানে রূপান্তর করে না। `if(jumps)` স্টেটমেন্টটি `if(0)`-এ মূল্যায়ন করে, এবং যেহেতু 0 একটি বুলিয়ান মান নয়, তাই কোডটি কম্পাইল হবে না। মনে রাখবেন যে এই উদাহরণে `jumps` ভেরিয়েবলের মান অপ্রাসঙ্গিক; জাভাতে কোনো পূর্ণসংখ্যা বুলিয়ান মানে মূল্যায়ন করে না।

১৬. বি. প্রিফিক্স অপারেটর ভেরিয়েবল পরিবর্তন করে এবং নতুন মানে মূল্যায়ন করে, যখন পোস্টফিক্স অপারেটর ভেরিয়েবল পরিবর্তন করে কিন্তু মূল মান ফেরত দেয়। সুতরাং, অপশন বি সঠিক উত্তর।
          int a = 10;    int b = a--; // প্রথমে a এর আসল মান (10) b কে অ্যাসাইন হয়, তারপর a এর মান 1 কমে (a এখন 9)।
           System.out.println("a এর নতুন মান: " + a); // আউটপুট: a এর নতুন মান: 9
           System.out.println("b এর মান: " + b);     // আউটপুট: b এর মান: 10
১৭. বি. এই সমস্যার জন্য, এটি উপলব্ধি করা সহায়ক যে বন্ধনীর ভিতরের ক্রিয়াকলাপের উপর বন্ধনীর বাইরের ক্রিয়াকলাপের প্রাধান্য থাকে। 
        একবার আমরা ভেরিয়েবলগুলোকে মান দিয়ে প্রতিস্থাপন করলে, এক্সপ্রেশনটি দাঁড়ায়: `3+2*(2+3)`। তারপর আমরা বন্ধনীর ভিতরের মান গণনা করে পাই `3+2*5`। 
       যেহেতু গুণ (*) অপারেটরের যোগ (+) অপারেটরের চেয়ে উচ্চতর প্রাধান্য রয়েছে, তাই আমরা প্রথমে এটি মূল্যায়ন করি, যার ফলে `3+10 = 13` হয়, যা অপশন বি-কে সঠিক উত্তর করে তোলে।
১৮. বি. `int` ইনপুট সহ `case` স্টেটমেন্টের জন্য যেকোনো মান যা অন্তর্নিহিতভাবে `int`-এ উন্নীত হতে পারে তা কাজ করবে। যেহেতু `switch` স্টেটমেন্ট `long` মান সমর্থন করে না, এবং ডেটা হারানোর সম্ভাবনা ছাড়া `long`-কে `int`-এ রূপান্তর করা যায় না, তাই অপশন বি সঠিক উত্তর।
১৯. ডি. টার্নারি অপারেশনের জন্য বন্ধনী সুপারিশ করা হলেও, বিশেষত এম্বেডেডগুলোর জন্য, এগুলো বাধ্যতামূলক নয়, তাই অপশন সি ভুল। কোডটি কম্পাইল হবে না কারণ দ্বিতীয় টার্নারি অপারেশনে `day` একটি `int`, বুলিয়ান এক্সপ্রেশন নয়, যা অপশন ডি-কে সঠিক উত্তর করে তোলে। মনে রাখবেন যে জাভাতে, `if-then` স্টেটমেন্ট বা টার্নারি অপারেশনে বুলিয়ান এক্সপ্রেশনের পরিবর্তে সংখ্যাসূচক মান গ্রহণ করা হয় না।
২০. সি. int leaders = 10 * (2 + (1 + 2 / 5); //")" missing

২১. বি. মনে রাখবেন যে জাভা বাম থেকে ডানে + মূল্যায়ন করে। প্রথম দুটি মানই সংখ্যা, তাই + সংখ্যাসূচক যোগ হিসাবে মূল্যায়ন করা হয়, যার ফলে `11 + "7" + 8 + 9`-এ হ্রাস পায়। পরবর্তী দুটি পদ, `11 + "7"`, স্ট্রিং কনক্যাটেনেশন হিসাবে পরিচালনা করা হয় কারণ পদগুলোর মধ্যে একটি `String`। এটি আমাদের এক্সপ্রেশনটিকে `"117" + 8 + 9`-এ হ্রাস করতে দেয়। একইভাবে, চূড়ান্ত দুটি পদ বামের `String`-এর সাথে একবারে মূল্যায়ন করা হয়। সুতরাং, চূড়ান্ত মান হল 11789, যা অপশন বি-কে সঠিক উত্তর করে তোলে।
২২. বি. বিয়োগ (-) অপারেটর দুটি সংখ্যার মধ্যে পার্থক্য খুঁজে বের করার জন্য ব্যবহৃত হয়, যখন মডুলাস (%) অপারেটর একটি সংখ্যাকে অন্য সংখ্যা দ্বারা ভাগ করলে অবশিষ্ট খুঁজে বের করার জন্য ব্যবহৃত হয়, যা অপশন বি-কে সঠিক উত্তর করে তোলে। অন্যান্য অপশনগুলো এমন অপারেটর ব্যবহার করে যা এই বর্ণনার সাথে মেলে না।
২৩. বি. কোডটি কোনো সমস্যা ছাড়াই কম্পাইল হয়, যা অপশন ডি-কে ভুল করে। এই প্রশ্নের মূল বিষয় হল দুটি সংখ্যার ভাগ এবং মডুলাস কীভাবে মূল অপারেন্ডগুলোর একটি পুনরুদ্ধার করতে ব্যবহার করা যেতে পারে তা দেখানো। এই উদাহরণে, `partA` হল দুটি সংখ্যার পূর্ণসংখ্যা ভাগ। যেহেতু 3 11-কে সমানভাবে ভাগ করে না, তাই এটি 3-এ রাউন্ড ডাউন করা হয়। `partB` ভেরিয়েবলটি প্রথম এক্সপ্রেশনের অবশিষ্ট, যা 2। `newDog` ভেরিয়েবলটি একটি এক্সপ্রেশন যা ভাগ মান এবং অবশিষ্ট ব্যবহার করে `dog`-এর মূল মান পুনরুদ্ধার করে। মনে রাখবেন অপারেটরের অগ্রাধিকারের কারণে, গুণ (*) অপারেশন যোগ (+) অপারেশনের আগে মূল্যায়ন করা হয়। ফলাফল হল `dog`-এর মূল মান 11 এই প্রোগ্রাম দ্বারা আউটপুট হয়।
২৪. বি. কোডটি কোনো সমস্যা ছাড়াই কম্পাইল হয়, তাই অপশন ডি ভুল। এই প্রশ্নের `switch` স্টেটমেন্টে কোনো `break` স্টেটমেন্ট নেই। 
         একবার মিলে যাওয়া `case` স্টেটমেন্ট, 30-এ পৌঁছালে, সমস্ত অবশিষ্ট `case` স্টেটমেন্ট নির্বাহ করা হবে। 
         `eaten` ভেরিয়েবলটি প্রথমে 1, তারপর 2 দ্বারা বৃদ্ধি পায়, তারপর 1 দ্বারা হ্রাস পায়, যার ফলে চূড়ান্ত মান 2 হয়, যা অপশন বি-কে সঠিক উত্তর করে তোলে।
২৫. সি. টার্নারি অপারেশনের জন্য উভয় ডানদিকের এক্সপ্রেশনকে সামঞ্জস্যপূর্ণ ডেটা টাইপের হতে হবে। এই উদাহরণে, বাইরের টার্নারি অপারেশনের প্রথম ডানদিকের এক্সপ্রেশনটি `String` টাইপের, যখন দ্বিতীয় ডানদিকের এক্সপ্রেশনটি `int` টাইপের। যেহেতু এই ডেটা টাইপগুলো অসামঞ্জস্যপূর্ণ, তাই কোডটি কম্পাইল হবে না এবং অপশন সি সঠিক উত্তর।

২৬. এ. এই প্রশ্নের জন্য, মনে রাখবেন যদি দুটি `String` অবজেক্ট `==` ব্যবহার করে সত্য হয়, তবে সেগুলো একই অবজেক্ট। যদি সেগুলো একই `String` অবজেক্ট হয়, তবে `equals()` তুচ্ছভাবে সত্য ফেরত দেবে। অপশন এ সঠিকভাবে এই নীতিটি প্রতিফলিত করে। অপশন বি ভুল কারণ দুটি `String` অবজেক্ট একই না হলেও `equals()`-এর ক্ষেত্রে সমতুল্য হতে পারে। উদাহরণস্বরূপ, `apples == new String(apples)` মিথ্যা মূল্যায়ন করে, কিন্তু `equals()` এই `String` অবজেক্টগুলোর উপর সত্য মূল্যায়ন করবে। একইভাবে, অপশন সি এবং ডি-ও ভুল কারণ `equals()`-এর ক্ষেত্রে সমতুল্য দুটি `String` অবজেক্ট ভিন্ন অবজেক্ট হতে পারে।
২৭. বি. স্টেটমেন্টটি কোনো সমস্যা ছাড়াই কম্পাইল এবং রান করে, যা অপশন সি এবং ডি-কে ভুল করে। যেহেতু আমাদের দেওয়া হয়েছে যে `myTestVariable` নাল নয়, তাই স্টেটমেন্টটি সর্বদা মিথ্যা মূল্যায়ন করবে, যা অপশন বি-কে সঠিক উত্তর করে তোলে। মনে রাখবেন যদি `myTestVariable` নাল হত, তবে কোডটি এখনও কম্পাইল হত কিন্তু রানটাইমে `equals()` কল করার সময় একটি `NullPointerException` থ্রো করত।
২৮. ডি. কোডটি কম্পাইল হবে না, যা অপশন ডি-কে সঠিক উত্তর করে তোলে। কোডটি কম্পাইল না হওয়ার কারণ হল দ্বিতীয় `if-then` স্টেটমেন্টের পরীক্ষা। `(streets && intersections > 1000)` এক্সপ্রেশনটি অবৈধ কারণ `streets` একটি বুলিয়ান এক্সপ্রেশন নয় এবং সংযোজক যৌক্তিক `&&` অপারেটরের বাম দিকে ব্যবহার করা যাবে না। কোডের লাইনটি সংশোধিত এক্সপ্রেশন `(streets > 1000 && intersections > 1000)`-এর মতো করে ডিজাইন করা হয়েছে। লক্ষ্য করুন সংশোধিত এক্সপ্রেশনটির দুটি রিলেশনাল `>` অপারেটরের প্রয়োজন। যদি দ্বিতীয় `if-then` স্টেটমেন্টটি সংশোধন করা হত, তবে অ্যাপ্লিকেশনটি কম্পাইল হত এবং দুটি 1 তৈরি করত, যা অপশন সি-কে সঠিক উত্তর করত।
২৯. বি. `&` এবং `&&` (AND) অপারেটর অদলবদলযোগ্য নয়, কারণ সংযোজক `&` অপারেটর সর্বদা এক্সপ্রেশনের উভয় দিক মূল্যায়ন করে, যখন কন্ডিশনাল সংযোজক `&&` অপারেটর শুধুমাত্র তখনই এক্সপ্রেশনের ডান দিক মূল্যায়ন করে যদি বাম দিকটি সত্য বলে নির্ধারিত হয়। এই কারণে কন্ডিশনাল অপারেটরগুলোকে প্রায়শই শর্ট-সার্কিট অপারেটর বলা হয়, রানটাইমে ডানদিকের এক্সপ্রেশনটি এড়িয়ে যায়। এই কারণে, অপশন বি সঠিক উত্তর। মনে রাখবেন অপশন সি-ও একটি ভুল স্টেটমেন্ট, কারণ এটি ডিসজাঙ্কটিভ (OR) অপারেটর বর্ণনা করে।
৩০. সি. কোডটি কম্পাইল হয়, তাই অপশন এ ভুল। যেহেতু `w` প্রথমে সত্য, তাই তৃতীয় লাইন টার্নারি এক্সপ্রেশনের প্রথম ডান দিকটি নেয় এবং `x`-এ 5 (পোস্ট-ইনক্রিমেন্ট অপারেটর) ফেরত দিয়ে অ্যাসাইন করে যখন `y`-কে 6-এ বৃদ্ধি করে। মনে রাখবেন টার্নারি অপারেটর রানটাইমে শুধুমাত্র একটি ডানদিকের এক্সপ্রেশন মূল্যায়ন করে তাই টার্নারি এক্সপ্রেশনের দ্বিতীয় ডান দিক `y--` মূল্যায়ন করা হয় না। চতুর্থ লাইনে, `w`-এর মান `!z`-এ সেট করা হয়। যেহেতু `z` মিথ্যা, তাই `w`-এর মান সত্য থাকে। চূড়ান্ত লাইন `(5+6)` এবং `(true ? 5 : 10)`-এর মান আউটপুট করে, যা `11 5`, যা অপশন সি-কে সঠিক উত্তর করে তোলে।

৩১. এ. প্রথম অ্যাসাইনমেন্ট আসলে দুটি `String` অবজেক্ট ব্যবহার করে, লিটারেল "bob" এবং `new` কীওয়ার্ড দিয়ে তৈরি `String`। যাই হোক না কেন, শুধুমাত্র দ্বিতীয় অবজেক্টটি `bob` ভেরিয়েবলে অ্যাসাইন করা হয়। দ্বিতীয় ভেরিয়েবল, `notBob`, `bob` ভেরিয়েবলের মানের একটি রেফারেন্স অ্যাসাইন করা হয়। এর মানে হল শুধুমাত্র `equals()` পরীক্ষাই পাস করে না, বরং সেগুলো আসলে একই অবজেক্ট, তাই `==` পরীক্ষাও সত্য। সুতরাং, সঠিক উত্তর হল অপশন এ।
৩২. বি. প্রশ্নটি অপারেটরের প্রাধান্য এবং অপারেশনের ক্রম সম্পর্কে। গুণ (*) এবং মডুলাস (%) অপারেটরের সর্বোচ্চ প্রাধান্য রয়েছে, যদিও বন্ধনীর ভিতরের অংশ প্রথমে মূল্যায়ন করা প্রয়োজন। আমরা এক্সপ্রেশনটিকে নিম্নরূপ হ্রাস করতে পারি: `12 + 6 * 3 % 2`। যেহেতু গুণ (*) এবং মডুলাস (%) এর একই অপারেটরের প্রাধান্য রয়েছে, তাই আমরা সেগুলোকে বাম থেকে ডানে নিম্নরূপ মূল্যায়ন করি: `12 + 6 * 3 % 2 → 12 + 18 % 2 → 12 + 0 → 12`। আমরা দেখতে পাচ্ছি যে এক্সপ্রেশনের ডান দিকে এতগুলো অপারেটর থাকা সত্ত্বেও, ফলাফল শূন্য, যা আমাদের মান 12 রেখে যায়, যা অপশন বি-কে সঠিক উত্তর করে তোলে।
৩৩. ডি. XOR (^) অপারেটর সত্য মূল্যায়ন করে যদি p এবং q ভিন্ন হয় এবং মিথ্যা যদি তারা একই হয়। সুতরাং, অনুপস্থিত মানগুলো হল সত্য এবং মিথ্যা, যা অপশন ডি-কে সঠিক উত্তর করে তোলে।
৩৪. সি. এই প্রশ্নটি বোঝার মূল বিষয় হল মনে রাখা যে কন্ডিশনাল সংযোজন `&&` অপারেটর শুধুমাত্র তখনই এক্সপ্রেশনের ডান দিকটি নির্বাহ করে যদি এক্সপ্রেশনের বাম দিকটি সত্য হয়। 
        যদি `data` একটি খালি অ্যারে হয়, তবে এক্সপ্রেশনটি তাড়াতাড়ি শেষ হয় এবং কিছুই আউটপুট হয় না। এক্সপ্রেশনের দ্বিতীয় অংশটি সত্য ফেরত দেবে যদি `data`-এর প্রথম উপাদানটি `sound` বা `logic` হয়।
        যেহেতু আমরা স্টেটমেন্টের প্রথম অংশ থেকে জানি যে `data`-এর দৈর্ঘ্য কমপক্ষে এক, তাই কোনো ব্যতিক্রম থ্রো করা হবে না। `data.length<2` সহ এক্সপ্রেশনের শেষ অংশটি যখন `data` এক আকারের অ্যারে হয় তখন আউটপুট পরিবর্তন করে না।
        সুতরাং, `sound` এবং `logic` উভয়ই সম্ভাব্য আউটপুট। এই কারণে, অপশন সি হল একমাত্র ফলাফল যা রানটাইমে অপ্রত্যাশিত।
৩৫. সি. অপশন এ-তে, ভাগ (/) অপারেটরটি ভুলভাবে ডিক্রিমেন্ট (--) অপারেটরের পরে এসেছে। অপশন বি-তে, বিয়োগ (-) অপারেটরটি ভুলভাবে মডুলাস (%) অপারেটরের পরে এসেছে। অপশন ডি-তে, ভাগ (/) অপারেটরটি ভুলভাবে বিয়োগ (-) অপারেটরের পরে এসেছে। সঠিক উত্তর হল অপশন সি, যেখানে তিনটি অপারেটরেরই একই অগ্রাধিকারের ক্রম রয়েছে।

৩৬. ডি. এক্সক্লুসিভ অর (XOR) (^) অপারেটরের ফলাফল নির্ধারণের জন্য উভয় অপারেন্ডের মূল্যায়ন করা প্রয়োজন। এই কারণে, অপশন এ এবং বি ভুল। অপশন বি-এর জন্য, যদি উভয় অপারেন্ড সর্বদা পঠিত হয় তবে আপনার শর্ট-সার্কিট অপারেশন থাকতে পারে না, তাই ^^ বিদ্যমান নেই। অপশন সি একটি ভুল স্টেটমেন্ট কারণ ^ অপারেটর শুধুমাত্র তখনই সত্য ফেরত দেয় যদি ঠিক একটি অপারেন্ড সত্য হয়। অবশেষে, অপশন ডি সঠিক কারণ ^ শুধুমাত্র জাভাতে বুলিয়ান মানের উপর প্রয়োগ করা হয়।
৩৭. সি. ডায়াগ্রামটি x এবং y-এর ওভারল্যাপ উপস্থাপন করে, যখন তাদের মধ্যে একটি সত্য হয় তার সাথে সঙ্গতিপূর্ণ। সুতরাং, x || y, অপশন সি, এই সম্পর্কের সাথে সবচেয়ে ঘনিষ্ঠভাবে মেলে। মনে রাখবেন ডায়াগ্রামে z অব্যবহৃত এবং তাই কোনো এক্সপ্রেশনে এর প্রয়োজন নেই।
৩৮. ডি. একটি `case` স্টেটমেন্টের মান ধ্রুবক, একটি লিটারেল মান, বা ফাইনাল ভেরিয়েবল হতে হবে। 
          যেহেতু `red`-এর `final` অ্যাট্রিবিউট অনুপস্থিত, তাই কোনো ভেরিয়েবল টাইপ কোডটিকে কম্পাইল করার অনুমতি দেয় না, যা অপশন ডি-কে সঠিক উত্তর করে তোলে।
৩৯. সি. প্রশ্নটি জিজ্ঞাসা করছে কোন অপারেটর বৃহত্তর বা সমান এবং কোন অপারেটর কঠোরভাবে কম প্রতিনিধিত্ব করে। >= এবং < যথাক্রমে এই অপারেটরগুলোর সাথে সঙ্গতিপূর্ণ। সুতরাং, অপশন সি সঠিক উত্তর। মনে রাখবেন প্রশ্নটি নির্দিষ্ট করে না যে অপারেটরগুলোকে কোন ক্রমে উপস্থিত হতে হবে, কেবল প্রশ্নের বর্ণনার সাথে মেলে এমন দুটি অপারেটর নির্বাচন করতে হবে।
৪০. বি. কোডটি কোনো সমস্যা ছাড়াই কম্পাইল এবং রান করে, যা অপশন সি এবং ডি-কে ভুল করে। এখানে মূল বিষয় হল অপারেটরের অগ্রাধিকার বোঝা এবং অগ্রাধিকার সঠিকভাবে ওভাররাইড করার জন্য বন্ধনী প্রয়োগ করা। প্রথম এক্সপ্রেশনটি নিম্নরূপ মূল্যায়ন করা হয়: `10 * (2 + (3 + 2) / 5) → 10 * (2 + 5 / 5) → 10 * (2 + 1) → 10 * 3`, যার চূড়ান্ত মান `turtle`-এর জন্য 30। যেহেতু `turtle` 5-এর চেয়ে কম নয়, তাই `hare`-এ 25 মানটি অ্যাসাইন করা হয়। যেহেতু `turtle` `hare`-এর চেয়ে কম নয়, তাই শেষ এক্সপ্রেশনটি `Turtle wins!`-এ মূল্যায়ন করে, যা কনসোলে আউটপুট হয়, যা অপশন বি-কে সঠিক উত্তর করে তোলে।

৪১. এ. এই প্রশ্নের `getResult()`-এর সমস্ত পদ 0-এ মূল্যায়ন করে, যেহেতু সবগুলোই 5-এর চেয়ে কম বা সমান। তাই এক্সপ্রেশনটিকে `0+0+0+0+""`-এ হ্রাস করা যেতে পারে। যেহেতু জাভা বাম থেকে ডানে + অপারেটর মূল্যায়ন করে, তাই বামের চারটি অপারেন্ড সংখ্যাসূচক যোগ ব্যবহার করে প্রয়োগ করা হয়, যার ফলে এক্সপ্রেশনটি `0+""` হয়। এই এক্সপ্রেশনটি কেবল মানটিকে একটি `String`-এ রূপান্তর করে, যার ফলে 0 আউটপুট হয়, যা অপশন এ-কে সঠিক উত্তর করে তোলে।
৪২. এ. কোডটি কোনো সমস্যা ছাড়াই কম্পাইল হয়, তাই অপশন ডি ভুল। এখানে মূল বিষয় হল `runTest()` মেথডের `if-then` স্টেটমেন্টটি `(==)` অপারেটরের পরিবর্তে অ্যাসাইনমেন্ট অপারেটর (=) ব্যবহার করে। এর ফলে `spinner`-এ `true` মানটি অ্যাসাইন করা হয় এবং `(spinner = roller)` স্টেটমেন্টটি নতুন অ্যাসাইন করা মান ফেরত দেয়। তারপর মেথডটি `up` ফেরত দেয়, যা অপশন এ-কে সঠিক উত্তর করে তোলে। যদি `if-then` স্টেটমেন্টে `(==)` অপারেটর ব্যবহার করা হত, তবে প্রক্রিয়াটি `else` স্টেটমেন্টে চলে যেত, এবং মেথডটি `down` ফেরত দিত।
৪৩. ডি. কন্ডিশনাল ডিসজাংশন (OR) `||` অপারেটর সত্য হয় যদি অপারেন্ডগুলোর মধ্যে যেকোনো একটি সত্য হয়, যখন যৌক্তিক পরিপূরক (!) অপারেটর একটি বুলিয়ান মানকে বিপরীত বা ফ্লিপ করে, যা অপশন ডি-কে সঠিক উত্তর করে তোলে। অন্যান্য অপশনগুলো এমন অপারেটর ব্যবহার করে যা এই বর্ণনার সাথে মেলে না। বিশেষ করে, অপশন এ এবং সি এমন অপারেটর অন্তর্ভুক্ত করে যা শুধুমাত্র সংখ্যাসূচক মানের উপর প্রয়োগ করা যেতে পারে, বুলিয়ান মানের উপর নয়।
৪৪. এ. টার্নারি অপারেশনের জন্য বন্ধনী সুপারিশ করা হলেও, বিশেষত এম্বেডেডগুলোর জন্য, এগুলো বাধ্যতামূলক নয়, তাই অপশন সি ভুল। প্রথম টার্নারি অপারেশন `characters <= 4` মিথ্যা মূল্যায়ন করে, তাই দ্বিতীয় টার্নারি অপারেশনটি নির্বাহ করা হয়। যেহেতু `story > 1` সত্য, তাই `movieRating`-এর চূড়ান্ত মান 2.0, যা অপশন এ-কে সঠিক উত্তর করে তোলে।
৪৫. বি. কোনো JVM সীমাবদ্ধতা না থাকলে, একটি `switch` স্টেটমেন্টে যেকোনো সংখ্যক `case` স্টেটমেন্ট (কোনোটি না থাকলেও) থাকতে পারে তবে সর্বাধিক একটি `default` স্টেটমেন্ট থাকতে পারে, এবং অপশন বি সঠিকভাবে এই সম্পর্কটি চিহ্নিত করে।

৪৬. এ. অ্যাপ্লিকেশনটি `weather[0]` নাল কিনা তা পরীক্ষা করার জন্য কন্ডিশনাল সংযোজন `&&` অপারেটর ব্যবহার করে, তবে দুর্ভাগ্যবশত এই পরীক্ষাটি শূন্য-দৈর্ঘ্যের অ্যারের উপর কাজ করে না। 
        সুতরাং, রানটাইমে এই কোডটি `ArrayIndexOutOfBoundsException` থ্রো করতে পারে। এক্সপ্রেশনের দ্বিতীয় অংশটি সত্য মূল্যায়ন করে যদি `weather`-এর প্রথম ইনপুট `sunny`-এর সাথে মেলে। 
        এক্সপ্রেশনের শেষ অংশ, `&& !false`, একটি টটোলজি কারণ এটি সর্বদা সত্য এবং এক্সপ্রেশনের উপর এর কোনো প্রভাব নেই।
        `weather`-এর মানের উপর ভিত্তি করে হয় একটি ব্যতিক্রম থ্রো করা হবে অথবা টেক্সট আউটপুট হবে, তাই অপশন এ সঠিক উত্তর।
৪৭. ডি. প্রশ্নটি যতটা কঠিন দেখাচ্ছে ততটা নয়। আসলে, এটি সমাধান করার জন্য আপনাকে কিছুই গণনা করতে হবে না! আপনাকে কেবল লক্ষ্য করতে হবে যে যৌক্তিক পরিপূরক (!), যা কেবলমাত্র বুলিয়ান মানের উপর প্রয়োগ করা যেতে পারে, একটি সংখ্যাসূচক মানের উপর প্রয়োগ করা হচ্ছে। সুতরাং, উত্তর হল এক্সপ্রেশনটি কম্পাইল বা রান হবে না, যা অপশন ডি-কে সঠিক উত্তর করে তোলে।
৪৮. সি. ডিসজাঙ্কটিভ যৌক্তিক `||` অপারেটর সত্য মূল্যায়ন করে যদি যেকোনো অপারেন্ড সত্য হয়। এটিকে দেখার আরেকটি উপায় হল এটি কেবলমাত্র তখনই মিথ্যা মূল্যায়ন করে যদি উভয় অপারেন্ড মিথ্যা হয়। সুতরাং, অনুপস্থিত মানগুলো উভয়ই সত্য, যা অপশন সি-কে সঠিক উত্তর করে তোলে।
৪৯. এ. অপশন বি-তে, বিয়োগ (-) অপারেটরটি ভুলভাবে ডিক্রিমেন্ট (--) অপারেটরের পরে এসেছে। অপশন সি-তে, ভাগ (/) অপারেটরটি ভুলভাবে ইনক্রিমেন্ট (++) অপারেটরের পরে এসেছে। অপশন ডি-তে, মডুলাস (%) অপারেটরটি ভুলভাবে ইনক্রিমেন্ট (++) অপারেটরের পরে এসেছে। সঠিক উত্তর হল অপশন এ, যেখানে বিয়োগ (-) এবং যোগ (+) অপারেটরগুলোর পরে ভাগ (/) এবং গুণ (*) অপারেটর রয়েছে।
৫০. সি. এই সমস্যাটি সমাধানের মূল বিষয় হল মনে রাখা যে একটি টার্নারি অপারেশন দ্বারা ফেরত মানের ধরণ ডানদিকের এক্সপ্রেশন দ্বারা নির্ধারিত হয়। লাইন p1-এ, এক্সপ্রেশনগুলো `int` টাইপের, কিন্তু অ্যাসাইনমেন্টটি `game` ভেরিয়েবলে, যা `String` টাইপের। যেহেতু অ্যাসাইনমেন্টটি অবৈধ, তাই কোডটি কম্পাইল হবে না এবং অপশন সি সঠিক।



====================================================================================================== 0 ======================================================================================================



1. B. A switch statement supports the primitive types byte, short, char, and int and the classes String, Character, Byte, Short, and Integer. It also supports enumerated types.
Floating-point types like float and double are not supported, therefore Option B is the correct answer.
2. A. Remember that in ternary expressions, only one of the two right-most expressions are evaluated. Since meal>6 is false, ––tip is evaluated and ++tip is skipped. The result is
that tip is changed from 2 to 1, making Option A the correct answer. The value of total is 6, since the pre-increment operator was used on tip, although you did not need to know this to solve the question.
3. C. The first assignment creates a new String "john" object. The second line explicitly uses the new keyword, meaning a new String object is created. Since these objects are not
the same, the == test on them evaluates to false. The equals() test on them returns true because the values they refer to are equivalent. Therefore, the correct answer is C.
4. D. This code does not compile because it has two else statements as part of a single if-then statement. Notice that the second if statement is not connected to the last else statement.
For this reason, Option D, none of the above, is the correct answer.
5. C. A default statement inside a switch statement is optional and can be placed in any order within the switch’s case statements, making Options A and B incorrect. Option D
is an incorrect statement as a switch statement can be composed of a single default statement and no case statements. Option C is correct because a default statement does not
take a value, unlike a case statement.

6. B. The initial assignment of thatNumber follows the first branch of the ternary expression. Since 5 >= 5 evaluates to true, a value of 3 is assigned to thatNumber. In the next line, the
pre-increment operator increments the value of thatNumber to 4 and returns a value of 4 to the expression. Since 4 < 4 evaluates to false, the if-then block is skipped. This leaves the
value of thatNumber as 4, making Option B the correct answer.
7. B. The break statement exits a switch statement, skipping all remaining branches, making Option B the correct answer. In Option A, exit is not a statement in Java. In Option C,
goto is a reserved word but unused in Java. Finally, in Option D, continue is a statement but only used for loops.
8. C. Option A is incorrect as only one of the two right-hand expressions is evaluated at runtime. Parentheses are often helpful for reading ternary expressions but are not required,
making Option B incorrect. Option C is a correct statement about ternary operators as they are commonly used to replace short if-then-else statements. Finally, Option D is
incorrect as only boolean expressions are permitted in the left-most operand of a ternary expression.
9. C. On line 4, candidateA and candidateB are numbers, but the && operation can only be applied to boolean expressions. Therefore, the code does not compile because of line 4,
making C the correct answer. All of the other lines are correct. Note that if line 4 is fixed, line 3 does not produce a NullPointerException at runtime. The conditional || and the
preceding null check allows the code to only call intValue() if candidateA is not null.
10. A. The first step is to determine whether or not the if-then statement’s expression is executed. The expression 6 % 3 evaluates to 0, since there is no remainder, and since
0 >= 1 is false, the expression triceratops++ is not called. Notice there are no brackets {} in the if-then statement. Despite the triceratops–– line being indented, it is
not part of the if-then statement. Recall that Java does not use indentation to determine the beginning or end of a statement. Therefore, triceratops–– is always executed, resulting in a value of 2 for triceratops and making Option A the correct answer.

11. D. Option A is incorrect because else statements are entirely optional. Option B is also incorrect. The target of an if-then statement is not evaluated if the boolean test is false.
Option C is incorrect. While an if-then statement is often used to test whether an object is of a particular type in order to cast it, it is not required to cast an object. Option D is correct as an if-then statement may execute a single statement or a block of code {}.
12. D. For this question, it helps to notice that the second if-then statement is not connected to the first if-then statement, as there is no else joining them. When this code executes, the first if-then statement outputs Not enough since flair is >= 15 and < 37. The second ifthen statement is then evaluated. 
Since flair is not 37, the expression Too many is outputted. Since two statements are outputted, Option D, none of the above, is the correct answer.
13. B. A case value must be a constant expression, such as a literal or final variable, so Options A and C are true statements about case values. A case statement may be terminated by a break statement, but it is not required, making Option B the false statement and correct answer.
Option D is also a true statement about case values.
14. D. The question is about boolean operators. Since Options A and B are numeric operators, they can be instantly disregarded. 
The question then simplifies to which boolean expression, && or ||, corresponds to the truth table that only evaluates to true if both operands
are true. Only the conjunctive logical && operator represents this relationship, making Option D the correct answer.
15. C. The value of jumps and hops is unimportant because this code does not compile, making Option C the correct answer. Unlike some other programming languages, Java does not
automatically convert integers to boolean values for use in if-then statements. The statement if(jumps) evaluates to if(0), and since 0 is not a boolean value, the code does not
compile. Note that the value of the jumps variable is irrelevant in this example; no integer evaluates to a boolean value in Java.

16. B. Prefix operators modify the variable and evaluate to the new value, while postfix operators modify the variable but return the original value. Therefore, Option B is the correct answer.
17. B. For this problem, it helps to recognize that parentheses take precedence over the operations outside the parentheses. Once we replace the variables with values, the expression
becomes: 3+2*(2+3). We then calculate the value inside the parentheses to get 3+2*5. Since the multiplication operator has higher precedence than addition, 
we evaluate it first, resulting in 3+10 = 13, making Option B the correct answer.
18. B. Any value that can be implicitly promoted to int will work for the case statement with an int input. Since switch statements do not support long values, and long cannot be
converted to int without a possible loss of data, Option B is the correct answer.
19. D. While parentheses are recommended for ternary operations, especially embedded ones,
they are not required, so Option C is incorrect. The code does not compile because day is an int, not a boolean expression, in the second ternary operation, making Option D
the correct answer. Remember that in Java, numeric values are not accepted in place of boolean expressions in if-then statements or ternary operations.
20. C. While the code involves numerous operations, none of that matters for solving this problem. The key to solving it is to notice that the line that assigns the leaders variable has
an uneven number of parentheses. Without balanced parentheses, the code will not compile, making Option C the correct answer.

21. B. Remember that Java evaluates + from left to right. The first two values are both numbers, so the + is evaluated as numeric addition, resulting in a reduction to 11 + "7" + 8
+ 9. The next two terms, 11 + "7", are handled as string concatenation since one of the terms is a String. This allows us to reduce the expression to "117" + 8 + 9. Likewise, the
final two terms are each evaluated one at a time with the String on the left. Therefore, the final value is 11789, making Option B the correct answer.
22. B. The subtraction - operator is used to find the difference between two numbers, while the modulus % operator is used to find the remainder when one number is divided by
another, making Option B the correct answer. The other options use operators that do not match this description.
23. B. The code compiles without issue, making Option D incorrect. The focus of this question is showing how the division and modulus of two numbers can be used to reconstitute
one of the original operands. In this example, partA is the integer division of the two numbers. Since 3 does not divide 11 evenly, it is rounded down to 3. The variable partB is the
remainder from the first expression, which is 2. The newDog variable is an expression that reconstitutes the original value for dog using the division value and the remainder. Note
that due to operator precedence, the multiplication * operation is evaluated before the addition + operation. The result is the original value of 11 for dog is outputted by this program.
24. B. The code compiles without issue, so Option D is incorrect. In this question’s switch statement, there are no break statements. 
Once the matching case statement, 30, is reached, all remaining case statements will be executed. The variable eaten is increased
by 1, then 2, then reduced by 1, resulting in a final value of 2, making Option B the correct answer.
25. C. Ternary operations require both right-hand expressions to be of compatible data types. In this example, the first right-hand expression of the outer ternary operation is of type String, 
while the second right-hand expression is of type int. Since these data types are incompatible, the code does not compile, and Option C is the correct answer.

26. A. For this question, remember that if two String objects evaluate to true using ==, then they are the same object. If they are the same String object, equals() will trivially return true. Option A correctly reflects this principle. 
Option B is incorrect as two String objects that are not the same may still be equivalent in terms of equals().
For example, apples == new String(apples) evaluates to false, but equals() will evaluate to true on these String objects. 
Likewise, Options C and D are also incorrect because two String objects that are equivalent in terms of equals() may be different objects.
27. B. The statement compiles and runs without issue, making Options C and D incorrect. Since we are given that myTestVariable is not null, the statement will always evaluate to false,
making Option B the correct answer. Note that if myTestVariable was null, then the code would still compile but throw a NullPointerException calling equals() at runtime.
28. D. The code does not compile, making Option D the correct answer. The reason the code does not compile is due to the test in the second if-then statement. 
The expression (streets && intersections > 1000) is invalid because streets is not a boolean expression and cannot be used as the left-hand side of the conjunctive logical &&
operator. The line of code is designed to resemble the corrected expression(streets > 1000 && intersections > 1000. Notice the fixed expression requirestwo relational > operators. 
If the second if-then statement was corrected, then the application would compile and produce two 1’s, making Option C the correct answer.
29. B. The & and && (AND) operators are not interchangeable, as the conjunctive & operator always evaluates both sides of the expression, while the conditional conjunctive && operator
only evaluates the right-hand side of the expression if the left side is determined to be true. This is why conditional operators are often referred to as short-circuit operators, skipping
the right-hand side expression at runtime. For these reasons, Option B is the correct answer. Note that Option C is an incorrect statement as well, since it describes disjunctive (OR) operators.
30. C. The code compiles, so Option A is incorrect. Since w starts out true, the third line takes the first right-hand side of the ternary expression returning and assigning 5 to x (postincrement operator) while incrementing y to 6. 
Note that the second right-hand side of the ternary expression y–– is not evaluated since ternary operators only evaluate one right-hand expression at runtime.
On the fourth line, the value of w is set to !z. Since z is false, the value of w remains true. The final line outputs the value of (5+6) and (true ? 5 : 10), which is 11 5, making Option C the correct answer.

31. A. The first assignment actually uses two String objects, the literal "bob" and the String
created with the new keyword. Regardless, only the second object is assigned to the variable bob. The second variable, notBob, is assigned a reference to the value of the bob variable. 
This means that not only does the equals() test pass, but they are actually the same object, so the == test is true as well. Therefore, the correct answer is Option A.
32. B. The question is about operator precedence and order of operation. The multiplication * and modulus % operators have the highest precedence, although what is inside the
parentheses needs to be evaluated first. We can reduce the expression to the following:
12 + 6 * 3 % 2. Since multiplication * and modulus % have the same operator precedence, we evaluate them from left to right as follows: 12 + 6 * 3 % 2 → 12 + 18 % 2 → 12 + 0 → 12.
We see that despite all of the operators on the right-hand side of the expression, the result is zero, leaving us a value of 12, making Option B the correct answer.
33. D. The XOR ^ operator evaluates to true if p and q differ and false if they are the same.
Therefore, the missing values are true and false, making Option D the correct answer.
34. C. The key to understanding this question is to remember that the conditional conjunction && operator only executes the right-hand side of the expression if the left-hand side of the
expression is true. If data is an empty array, then the expression ends early and nothing is output. The second part of the expression will return true if data’s first element is sound
or logic. Since we know from the first part of the statement that data is of length at least one, no exception will be thrown. The final part of the expression with data.length<2
doesn’t change the output when data is an array of size one. Therefore, sound and logic are both possible outputs. For these reasons, Option C is the only result that is unexpected at runtime.
35. C. In Option A, the division operator / incorrectly comes after the decrement –– operator.In Option B, the subtraction operator - incorrectly comes after the modulus % operator. 
In Option D, the division operator / incorrectly comes after the subtraction - operator. The correct answer is Option C, where all three operators have the same order of precedence.

36. D. The exclusive or (XOR) ^ operator requires evaluating both operands to determine the result. For this reason, Options A and B are incorrect. 
For Option B, you can’t have a short-circuit operation if both operands are always read, therefore ^^ does not exist. 
Option C is an incorrect statement as the ^ operator only returns true if exactly one operand is true. Finally, Option D is correct as the ^ is only applied to boolean values in Java.
37. C. The diagram represents the overlap of x and y, corresponding to when one of them is true. Therefore, x || y, Option C, most closely matches this relationship. 
Note that z is unused in the diagram and therefore is not required in any expression.
38. D. The value of a case statement must be constant, a literal value, or final variable. 
Since red is missing the final attribute, no variable type allows the code to compile, making Option D the correct answer.
39. C. The question is asking which operator represents greater than or equal to and which operator is strictly less than. The >= and < correspond to these operators, respectively.
Therefore, Option C is the correct answer. Note that the question does not specify which order the operators needed to appear in, only to select the two operators that match the
question description.
40. B. The code compiles and runs without issue, making Options C and D incorrect.
The key here is understanding operator precedence and applying the parentheses to override precedence correctly. The first expression is evaluated as follows:
10 * (2 + (3 + 2) / 5) → 10 * (2 + 5 / 5) → 10 * (2 + 1) → 10 * 3, with a final value of 30 for turtle. Since turtle is not less than 5, a value of 25 is assigned to
hare. Since turtle is not less than hare, the last expression evaluates to Turtle wins!, which is outputted to the console, making Option B the correct answer.

41. A. All of the terms of getResult() in this question evaluate to 0, since they are all less than or equal to 5. The expression can therefore be reduced to 0+0+0+0+"". 
Since Java evaluates the + operator from left to right, the four operands on the left are applied using numeric addition, resulting in the expression 0+"". 
This expression just converts the value to a String, resulting in an output of 0, making Option A the correct answer.
42. A. The code compiles without issue, so Option D is incorrect. The key here is that the ifthen statement in the runTest() method uses the assignment operator (=) instead of the
(==) operator. The result is that spinner is assigned a value of true, and the statement (spinner = roller) returns the newly assigned value. 
The method then returns up, making Option A the correct answer. If the (==) operator had been used in the if-then statement,
then the process would have branched to the else statement, with down being returned by the method.
43. D. The conditional disjunction (OR) || operator is true if either of the operands are true, while the logical complement (!) operator reverses or flips a boolean value, making Option
D the correct answer. The other options use operators that do not match this description. 
In particular, Options A and C include operators that can only be applied to numerical values, not boolean ones.
44. A. While parentheses are recommended for ternary operations, especially embedded ones, they are not required, so Option C is incorrect.. The first ternary operation evaluates
characters <= 4 as false, so the second ternary operation is executed. Since story > 1 is true, the final value of movieRating is 2.0, making Option A the correct answer.
45. B. Barring any JVM limitations, a switch statement can have any number of case statements (including none) 
but at most one default statement, with Option B correctly identifying this relationship.

46. A. The application uses the conditional conjunction && operator to test if weather[0] is null, but unfortunately this test does not work on zero-length arrays. 
Therefore, it is possible this code will throw an ArrayIndexOutOfBoundsException at runtime. The second part of the expression evaluates to true if the first input of weather matches sunny. 
The final part of the expression, && !false, is a tautology in that it is always true and has no impact on the expression. 
Either an exception will be thrown or text will be output, based on the value of weather, therefore Option A is the correct answer.
47. D. The question looks a lot more difficult than it is. In fact, to solve it you don’t have to compute anything! You just have to notice that the logical complement operator (!), 
which can only be applied to boolean values, is being applied to a numeric value. Therefore, the answer is that the expression wouldn’t compile or run, making Option D the correct answer.
48. C. The disjunctive logical || operator evaluates to true if either operand is true. Another way to look at it is that it only evaluates to false if both operands are false. 
Therefore, the missing values are both true, making Option C the correct answer.
49. A. In Option B, the subtraction operator - incorrectly comes after the decrement –– operator.
In Option C, the division operator / incorrectly comes after the increment ++ operator. In Option D, the modulus operator % incorrectly comes after the increment ++ operator. 
The correct answer is Option A, where the subtraction - and addition + operators are followed by the division / and multiplication * operators.
50. C. The key to solving this problem is remembering that the type of the value returned by a ternary operation is determined by the expressions on the right-hand side. On line p1,
the expressions are of type int, but the assignment is to the variable game, of type String. Since the assignment is invalid, the code does not compile, and Option C is correct.


===================================================# Chapter Summary: Control Flow and Operators in Java ===================================================








-
