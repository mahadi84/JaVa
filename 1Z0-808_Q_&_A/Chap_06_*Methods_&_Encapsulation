Medium.

========================== কিছু প্রশ্ন: ==============================

*** মেথড কী? একটি মেথড সিগনেচার কী? 
*** মেথড না থাকলে কী সমস্যা হতো/মেথড কেন ব্যবহার করি? 
*** যদি এনক্যাপসুলেশন না থাকে, তাহলে আমি কী কী সমস্যার সম্মুখীন হব? আমরা এটি নিয়ে কেন মাথা ঘামাই?

*** Call-By-Value কী?
*** OOP এর ক্ষেত্রে, "ইনস্ট্যান্স" (Instance) শব্দটির অর্থ কী?
         -"ইনস্ট্যান্স" (Instance) শব্দটি দ্বারা একটি ক্লাস (class) থেকে তৈরি করা একটি নির্দিষ্ট অবজেক্টকে বোঝায়।

   Web: https://github.com/mahadi84/Learning-A-Programming/blob/main/OOP_What_%26_Why_%3F

----------


## মেথড কী?
মেথড হলো কিছু স্টেটমেন্টের একটি ব্লক যা একটি নির্দিষ্ট কাজ সম্পন্ন করার জন্য ডিজাইন করা হয়। আমি এটি প্রোগ্রামে বারবার ব্যবহার করতে পারি।
যখন আমার সেই নির্দিষ্ট কাজটি করার প্রয়োজন হয়, তখন আমি মেথডটিকে তার নাম ধরে "কল" করি।

## মেথড সিগনেচার হলো একটি মেথডকে স্বতন্ত্রভাবে সনাক্ত করার জন্য ব্যবহৃত মূল অংশ, যাদুটি উপাদান নিয়ে গঠিত:
১. মেথডের নাম (Method Name): মেথডটির কী নাম দেওয়া হয়েছে।
২. প্যারামিটার তালিকা (Parameter List): মেথডটি যে প্যারামিটারগুলো গ্রহণ করে, তাদের সংখ্যা, ডেটা টাইপ এবং ক্রম।

## মেথড না থাকলে কী সমস্যা হতো/মেথড কেন ব্যবহার করি?
মেথড না থাকলে কোড অনেক দীর্ঘ এবং অগোছালো হয়ে যেত, কারণ একই কাজ বারবার লিখতে হতো। 
এতে কোড বোঝা, কোনো ভুল খুঁজে বের করা এবং পরিবর্তন করা খুবই কঠিন হয়ে পড়তো।

## যদি এনক্যাপসুলেশন না থাকে, তাহলে আমি কী কী সমস্যার সম্মুখীন হব? আমরা এটি নিয়ে কেন মাথা ঘামাই?
-কারণ ডিফল্ট (প্যাকেজ প্রাইভেট) অ্যাক্সেস থাকায়, প্যাকেজের যেকোনো parent  ক্লাস-  numberEggs ভেরিয়েবলটিকে সরাসরি পরিবর্তন করতে পারে। 
এর ফলে, আমার নিজের ক্লাসের মধ্যে কী মান সেট হচ্ছে, তার ওপর আমার আর কোনো নিয়ন্ত্রণ থাকে না।
আমার কোডের ডেটা নিরাপত্তা কমে যাবে, কারণ ক্লাসের অভ্যন্তরীণ ডেটা সরাসরি বাইরে থেকে পরিবর্তন করা যেতে পারে, যা অপ্রত্যাশিত ত্রুটি ঘটাতে পারে। 
এছাড়া, কোড রক্ষণাবেক্ষণ করা কঠিন হয়ে পড়বে, কারণ যেকোনো অভ্যন্তরীণ পরিবর্তনে সিস্টেমের অন্যান্য অংশে প্রভাব পড়ার ঝুঁকি থাকবে।

## Call-By-Value কী?
জাভাতে কল-বাই-ভ্যালু (Call-By-Value) বলতে বোঝায় যে যখন আপনি একটি মেথডে কোনো ভেরিয়েবল পাস করেন, তখন সেই ভেরিয়েবলের আসল মানটির একটি কপি মেথডের প্যারামিটারে পাঠানো হয়, আসল ভেরিয়েবলটি নয়। 
এর মানে হলো, মেথডের ভিতরে সেই কপির পরিবর্তন করা হলেও মূল ভেরিয়েবলের মানের কোনো পরিবর্তন হয় না।
    উদাহরণে:
      public class CallByValueShortExample {
          public static void increment(int x) {
              x = x + 1; // x-এর কপির মান বাড়ানো হচ্ছে
              System.out.println("মেথডের ভিতরে x: " + x); // আউটপুট: 11
          }
      
          public static void main(String[] args) {
              int originalValue = 10;
              System.out.println("কল করার আগে: " + originalValue); // আউটপুট: 10
              increment(originalValue); // originalValue-এর একটি কপি পাঠানো হচ্ছে
              System.out.println("কল করার পর: " + originalValue); // আউটপুট: 10 (মান অপরিবর্তিত)
          }
      }
এই উদাহরণে, increment মেথডে originalValue-এর মান (10) এর একটি কপি পাঠানো হয়। মেথডের ভিতরে সেই কপির মান 11 করা হলেও, main মেথডে originalValue-এর আসল মান 10-ই থেকে যায়। এটিই জাভাতে কল-বাই-ভ্যালু।


==============================================================================================================

This chapter covers essential Java concepts including:
1. - Access modifiers (public, protected, package-private, private)
2. - Encapsulation principles
3. - Method overloading and signatures
4. - Constructors and constructor chaining(this vs this(), super vs super())
5. - Static vs instance members
6. - Variable scope, final keyword, and hiding variable and method

## Key Concepts to Master

### 1. Access Modifiers
-----------------------------------------------------------
| Modifier        | Class | Package | Subclass | World |
|-----------------|-------|---------|----------|-------|
| public          | ✓     | ✓       | ✓        | ✓     |
| protected       | ✓     | ✓       | ✓        | ✗     |
| package-private | ✓     | ✓       | ✗        | ✗     |
| private         | ✓     | ✗       | ✗        | ✗     |
-----------------------------------------------------------
Access Modifier Scenarios:
   - Determine visibility in different package/subclass situations
   - Identify proper encapsulation techniques
   - Recognize invalid access combinations

### 2. Encapsulation Advantage and Principles
Advantage:
- Prevent users from modifying the internal attributes of a class./ব্যবহারকারীদের একটি ক্লাসের অভ্যন্তরীণ বৈশিষ্ট্য পরিবর্তন করা থেকে বিরত রাখুন।
- Hide implementation details/বাস্তবায়নের বিবরণ লুকান।
- Maintain class data integrity of data elements./ডেটা উপাদানগুলির ক্লাসের ডেটা অখণ্ডতা বজায় রাখুন।
- Protect class invariants/ক্লাস ইনভেরিয়েন্ট রক্ষা করুন।
- Promote usability by other developers./অন্যান্য ডেভেলপারদের দ্বারা ব্যবহারযোগ্যতা বাড়ান।
Principles:
- Use private fields with public getters/setters
- Follow JavaBean naming conventions:
  - getX()/isX() for getters
  - setX() for setters

### 3. Constructor Rules
- Constructor chaining with this() and super() //একটি ক্লাসের মধ্যে এক কন্সট্রাক্টর থেকে অন্য কন্সট্রাক্টরকে কল করার প্রক্রিয়াকে কন্সট্রাক্টর চেইনিং বলে।
- Implicit super() if no constructor defined
- Must explicitly call super() if parent has no no-arg constructor
- First line must be this() or super() (implicit super() if omitted)
- Cannot be static, final or abstract
Constructor Analysis:
   - Trace constructor chaining
   - Identify implicit super() calls
   - Spot constructor syntax errors
 ** When Java sees the new keyword, it allocates memory for the new object. Java also looks for a constructor and calls it.


## জাভাতে কন্সট্রাক্টর সম্পর্কিত গুরুত্বপূর্ণ নিয়মাবলী

01. কন্সট্রাক্টর চেইন (Constructor Chaining):
     -`this()` ব্যবহার করে একই ক্লাসের অন্য কন্সট্রাক্টরকে কল করা যায়।
     -`super()` ব্যবহার করে সুপারক্লাসের কন্সট্রাক্টরকে কল করা যায়।
     একটি কন্সট্রাক্টরের প্রথম স্টেটমেন্টটি অবশ্যই `this()` অথবা `super()` হতে হবে। জাভার নিয়ম অনুযায়ী, একই কন্সট্রাক্টরে `this()` এবং `super()` একসাথে ব্যবহার করা যাবে না।

02. ডিফল্ট কন্সট্রাক্টর এবং `super()` এর স্বয়ংক্রিয় যোগ:
     -যদি কোনো ক্লাসে আপনি কোনো কন্সট্রাক্টর তৈরি না করেন, তবে জাভা কম্পাইলার স্বয়ংক্রিয়ভাবে একটি ডিফল্ট (নো-আর্গুমেন্ট) কন্সট্রাক্টর তৈরি করে দেয়। এই ডিফল্ট কন্সট্রাক্টর স্বয়ংক্রিয়ভাবে সুপারক্লাসের নো-আর্গুমেন্ট `super()` কল করে।
     -যদি আপনি ক্লাসে একটিও কন্সট্রাক্টর ডিফাইন করেন (আর্গুমেন্ট থাকুক বা না থাকুক), তাহলে ডিফল্ট কন্সট্রাক্টর আর স্বয়ংক্রিয়ভাবে তৈরি হবে না।
     -যদি আপনি স্পষ্টভাবে `super()` কল না করেন, তবে জাভা কম্পাইলার স্বয়ংক্রিয়ভাবে একটি নো-আর্গুমেন্ট `super()` কল যোগ করে দেয়।

03. সুপারক্লাসে নো-আর্গুমেন্ট কন্সট্রাক্টরের অনুপস্থিতি:
     -যদি সুপারক্লাসে কোনো ডিফল্ট (নো-আর্গুমেন্ট) কন্সট্রাক্টর না থাকে (অর্থাৎ, শুধুমাত্র আর্গুমেন্টযুক্ত কন্সট্রাক্টর থাকে), 
     -তবে আপনার সাবক্লাসের প্রতিটি কন্সট্রাক্টরের প্রথম লাইনে স্পষ্টভাবে `super(arguments)` ব্যবহার করে প্যারেন্ট ক্লাসের উপযুক্ত কন্সট্রাক্টরকে কল করতে হবে।
     -যদি আপনি এটি না করেন, অথবা যদি আপনি শুধু `super()` (নো-আর্গুমেন্ট) কল করেন এবং প্যারেন্ট ক্লাসে সেই ধরনের কোনো কন্সট্রাক্টর না থাকে, তাহলে কম্পাইল-টাইম এরর হবে।

04. কন্সট্রাক্টরের মডিফায়ার:
     -কন্সট্রাক্টরকে `public`, `protected`, `default` (কিছু না লিখলে এটাই ডিফল্ট), অথবা `private` মডিফায়ার ব্যবহার করে ডিক্লেয়ার করা যায়।
     তবে, কন্সট্রাক্টর কখনো `static`, `final`, অথবা `abstract` মডিফায়ার ব্যবহার করে ডিক্লেয়ার করা যায় না।
         `static` মেম্বার ক্লাসের সাথে সম্পর্কিত, কোনো নির্দিষ্ট অবজেক্টের সাথে নয়।
         `final` মানে অপরিবর্তনীয়, কিন্তু কন্সট্রাক্টরের কাজ হলো অবজেক্টের প্রাথমিক অবস্থা নির্ধারণ করা।
         `abstract` ক্লাস বা মেথডকে বোঝায় যার কোনো সম্পূর্ণ বাস্তবায়ন নেই, কিন্তু কন্সট্রাক্টরকে অবশ্যই অবজেক্ট তৈরির সময় নির্বাহিত হতে হবে।


### 4. Method Signature Evaluation & Overloading:
   - Validate overloaded methods
   - Identify valid JavaBean methods
   - Recognize varargs usage
         public void walk1() { }
         public void 2walk() { } // DOES NOT COMPILE
         public void walk4(int a; int b) { } // DOES NOT COMPILE
         public void walk5(int a, int b) { }
Overloading:
- Same method name
- Different parameter lists (type, number, or order)
- Return type not considered for overloading
- Varargs can be used in overloading


### 5. Static Members & Static vs Instance:
- Belong to the class, not instances
- Can be accessed via class name
- Static methods cannot access instance variables
- Static imports allow direct access to static members
Static vs Instance:
   - Proper static member access
   - Identify invalid static/instance mixing
   - Understand static initialization


### 6.  Variable scope, final keyword, and hiding variable and method
   - Final variables (must be initialized)
   - Final methods (cannot be overridden)
   - Final classes (cannot be extended)
-private modifiers hide variable and method in child class

## Common Pitfalls to Avoid

1. Assuming default access is "protected" - it's actually package-private
2. Forgetting super()/this() must be first constructor line
3. Confusing method overloading with overriding
4. Trying to modify final variables after initialization
5. Accessing instance members from static context
6. Mixing up pass-by-value behavior for primitives vs object references

// Calling not-static function without this/creating obj is Ok for instant to instant method
public void nested() { nested(2,true); }  //Does not run(will catch error into Main()). A function Must have Return-Type and return-keyword. 
public int nested(int level, boolean height) { return nested(level); } 

*** Array Data- can be modified after they are passed to a method as an argument. (Pass_by_Reference)



=========================== Chapter_6(Working with Methods and Encapsulation) =================================

4,*5,11,13,17,18,21,22,27,28,32,34,36,37,39,46,48,50=18

3,10,*11,13,*17,*21,22,24,*27,28,*32,33,*34,*36,*39,42,43,45,46,*47 = 20


1. Fill in the blanks: __ The access modifier allows access to everything the access modifier __ does and more.
        A. package-private, protected
        B. protected, public
        C. protected, package-private
        D. private, package-private

2. What is the command to call one constructor from another constructor in the same class?
        A. super()
        B. this()
        C. that()
        D. construct()

3. What is the output of the following application?
        package stocks;
        public class Bond {
        private static int price = 5;
        public boolean sell() {
        if(price<10) {
        price++;
        return true;
        } else if(price>=10) {
        return false;
        }
        }
        public static void main(String[] cash) {
        new Bond().sell();
        new Bond().sell();
        new Bond().sell();
        System.out.print(price);
        }
        }
        A. 5
        B. 6
        C. 8
        D. The code does not compile.

4. What is true about the following program?
        package figures;
        public class Dolls {
        public void nested() { nested(2,true); } // g1
        public int nested(int level, boolean height) { return nested(level); }
        public int nested(int level) { return level+1; }; // g2
        public static void main(String[] outOfTheBox) {
        System.out.print(new Dolls().nested());
        }
        }
        A. It compiles successfully and prints 3 at runtime.
        B. It does not compile because of line g1.
        C. It does not compile because of line g2.
        D. It does not compile for some other reason.

5. Fill in the blank: __ Java uses to send data into a method.
        A. pass-by-null
        B. pass-by-value
        C. both pass-by-value and pass-by-reference
        D. pass-by-reference

6. Which of the following is a valid JavaBean method signature?
        A. public void getArrow()
        B. public void setBow()
        C. public void setRange(int range)
        D. public String addTarget(String target)

7. Which of the following statements about calling this() in a constructor is not true?
        A. If this() is used, it must be the first line of the constructor.
        B. If super() and this() are both used in the same constructor, super() must appear on the line immediately after this().
        C. If arguments are provided to this(), then there must be a constructor in the class able to take those arguments.
        D. If the no-argument this() is called, then the class must explicitly implement the no-argument constructor.

8. Which of the following can fill in the blank to make the class compile?
        package ai;
        public class Robot {
        compute() { return 10; }
        }
        A. Public int
        B. Long
        C. void
        D. private String

9. Fill in the blank: A variable is always available to all instances of the class.
        A. public
        B. local
        C. static
        D. instance

10. Which line of code, inserted at line p1, causes the application to print 5?
        package games;
        public class Jump {
        private int rope = 1;
        protected boolean outside;
        public Jump() {
        // p1
        outside = true;
        }
        public Jump(int rope) {
        this.rope = outside ? rope : rope+1;
        }
        public static void main(String[] bounce) {
        System.out.print(new Jump().rope);
        }
        }
        A. this(4);
        B. new Jump(4);
        C. this(5);
        D. rope = 4;

11. Which of the following statements is not true?
        A. An instance of one class may access an instance of another class’s attributes if it has a reference to the instance and the attributes are declared public.
        B. An instance of one class may access package-private attributes in a parent class, provided the parent class is not in the same package.
        C. Two instances of the same class may access each other’s private attributes.
        D. An instance of one class may access an instance of another class’s attributes if both classes are located in the same package and marked protected.

12. Given the following class, what should be inserted into the two blanks to ensure the class data is properly encapsulated?
        package storage;
        public class Box {
        public String stuff;
        __ String __() {
        return stuff;
        }
        public void setStuff(String stuff) {
        this.stuff = stuff;
        }
        }
        A. public and getStuff
        B. private and isStuff
        C. public and setStuff
        D. None of the above

13. Which statement about a no-argument constructor is true?
        A. The Java compiler will always insert a default no-argument constructor if you do not define a no-argument constructor in your class.
        B. In order for a class to call super() in one of its constructors, its parent class must explicitly implement a no-argument constructor.
        C. If a class extends another class that has only one constructor that takes a value, then the child class must explicitly declare at least one constructor.
        D. A class may contain more than one no-argument constructor.

14. Which of the following method signatures does not contain a compiler error?
        A. public void sing(String key, String... harmonies)
        B. public void sing(int note, String... sound, int music)
        C. public void sing(String... keys, String... pitches)
        D. public void sing(String... notes, String melodies)

15. Given the following application, which diagram best represents the state of the mySkier,mySpeed, and myName variables in the main() method after the call to the slalom() method?
       *** GitHub does not support Diagram.

16. Given the class below, which method signature could be successfully added to the class as an overloaded version of the findAverage() method?
        public class Calculations {
        public Integer findAverage(int sum) { return sum; }
        }
        A. public Long findAverage(int sum)
        B. public Long findAverage(int sum, int divisor)
        C. public Integer average(int sum)
        D. private void findAverage(int sum)

17. Which of the following is not a reason to use encapsulation when designing a class?
        A. Promote usability by other developers.
        B. Maintain class data integrity of data elements.
        C. Prevent users from modifying the internal attributes of a class.
        D. Increase concurrency and improve performance.

18. Which of the following data types can be modified after they are passed to a method as an argument?
        A. int[]
        B. String
        C. long
        D. boolean

19. What is the best way to call the following method from another class in the same package, 
    assuming the class using the method does not have any static imports?
        package useful;
        public class MathHelper {
        public static int roundValue(double d) {
        // Implementation omitted
        }
        }
        A. MathHelper:roundValue(5.92)
        B. MathHelper.roundValue(3.1)
        C. roundValue(4.1)
        D. useful.MathHelper.roundValue(65.3)

20. Given a method with one of the following return types, which data type prevents the return statement from being used within the method?
        A. byte
        B. String
        C. void
        D. None of the above

21. How many final modifiers would need to be removed for this application to compile?
        package end;
        public final class Games {
        public final static int finish(final int score) {
        final int win = 3;
        final int result = score++ < 5 ? 2 : win;
        return result+=win;
        }
        public static void main(final String[] v) {
        System.out.print(finish(Integer.parseInt(v[0])));
        }
        }
        A. None
        B. One
        C. Two
        D. The code will not compile regardless of the number of final modifiers that are removed.

22. Fill in the blanks: __ is used to call a constructor in the parent class,
        while __ is used to reference a member of the parent class.
        A. super and this()
        B. super and super()
        C. super() and this
        D. super() and super

23. Given the following method signature, which classes can call it?
        void run(String government)
        A. Classes in other packages
        B. Classes in the same package
        C. Subclasses in a different package
        D. All classes

24. Which statement(s) about the following class would help to properly encapsulate the data in the class?
        package shield;
        public class Protect {
        private String material;
        protected int strength;
        public int getStrength() {
        return strength;
        }
        public void setStrength(int strength) {
        this.strength = strength;
        }
        }
        I. Change the access modifier of strength to private.
        II. Add a getter method for material.
        III. Add a setter method for material.
        A. I
        B. II and III
        C. I, II, and III
        D. None, the data in the class is already encapsulated.

25. Which of the following is a valid method name in Java?
        A. Go_$Outside$2()
        B. have-Fun()
        C. new()
        D. 9enjoyTheWeather()

26. Which of the following lines of code can be inserted in the line below that would allow the class to compile?
        package farm;
        public class Coop {
        public final int static getNumberOfChickens() {
        // INSERT CODE HERE
        }
        }

        A. return 3.0;
        B. return 5L;
        C. return 10;
        D. None of the above

27. Which of the following is a true statement about passing data to a method?
        A. A change made to a primitive value passed to a method is reflected in the calling  method.
        B. A change made to the data within an object passed to a method is reflected in the calling  method.
        C. Reassigning an object reference passed to a method is reflected in the calling method.
        D. A change made to a boolean value passed to a method is reflected in the calling method.

28. What is a possible output of the following application?
        package wrap;
        public class Gift {
        private final Object contents;
        protected Object getContents() {
        return contents;
        }
        protected void setContents(Object contents) {
        this.contents = contents;
        }
        public void showPresent() {
        System.out.print("Your gift: "+contents);
        }
        public static void main(String[] treats) {
        Gift gift = new Gift();
        gift.setContents(gift);
        gift.showPresent();
        }
        }
        A. Your gift: wrap.Gift@29ca2745
        B. Your gift: Your gift:
        C. It does not compile.
        D. It compiles but throws an exception at runtime.

29. Which of the following is a valid JavaBean method prefix?
        A. is
        B. gimme
        C. request
        D. put

30. Given the following two classes, each in a different package, which line inserted below allows the second class to compile?
        package clothes;
        public class Store {
        public static String getClothes() { return "dress"; }
        }
        package wardrobe;
        // INSERT CODE HERE
        public class Closet {
        public void borrow() {
        System.out.print("Borrowing clothes: "+getClothes());
        }
        }
        A. static import clothes.Store.getClothes;
        B. import clothes.Store.*;
        C. import static clothes.Store.getClothes;
        D. import static clothes.Store;

31. What access modifier is used to mark class members package-private?
        A. private
        B. default
        C. protected
        D. None of the above

32. How many lines of the following program contain compilation errors?
        package sky;
        public class Stars {
        private int inThe = 4;
        public void Stars() {
        super();
        }
        public Stars(int inThe) {
        this.inThe = this.inThe;
        }
        public static void main(String[] endless) {
        System.out.print(new sky.Stars(2).inThe);
        }
        }
        A. None
        B. One
        C. Two
        D. Three

33. Which of the following statements is true?
        A. An instance method is allowed to reference a static variable.
        B. A static method is allowed to reference an instance variable.
        C. A static initialization block is allowed to reference an instance variable.
        D. A final static variable may be set in a constructor.

34. Given the following method declaration, which line can be inserted to make the code compile?
        public short calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        // INSERT CODE HERE
        }
        A. return new Integer(3);
        B. return new Byte((byte)6);
        C. return 5L;
        D. return new Short(4).longValue();

35. Which of the following statements about overloaded methods are true?
        I. Overloaded methods must have the same name.
        II. Overloaded methods must have the same return type.
        III. Overloaded methods must have a different list of parameters.
        A. I
        B. I and II
        C. I and III
        D. I, II, and III

36. How many lines of code would need to be removed for the following class to compile?
        package work;
        public class Week {
        private static final String monday;
        String tuesday;
        final static wednesday = 3;
        final protected int thursday = 4;
        }
        A. One
        B. Two
        C. Three
        D. The code will not compile regardless of the number of lines removed.

37. What is the output of the following application?
        package pet;
        public class Puppy {
        public static int wag = 5; // q1
        public void Puppy(int wag) { // q2
        this.wag = wag;
        }
        public static void main(String[] tail) {
        System.out.print(new Puppy(2).wag); // q3
        }
        }
        A. 2
        B. It does not compile because of line q1.
        C. It does not compile because of line q2.
        D. It does not compile because of line q3.

38. Fill in the blanks: __The access modifier allows access to everything the access modifier __ does and more.
        A. public, private
        B. private, package-private
        C. package-private, protected
        D. private, public

39. What is the output of the following application?
        package ship;
        public class Phone {
        private int size;
        public Phone(int size) {this.size=size;}
        public static void sendHome(Phone p, int newSize) {
        p = new Phone(newSize);
        p.size = 4;
        }
        public static final void main(String... params) {
        final Phone phone = new Phone(3);
        sendHome(phone,7);
        System.out.print(phone.size);
        }
        }
        A. 3
        B. 4
        C. 7
        D. The code does not compile.

40. Given the following class, which line of code when inserted below would prevent the class from compiling?
        public class Drink {
        public static void water() {}
        public void get() {
        // INSERT CODE HERE
        }
        }
        A. water();
        B. this.Drink.water();
        C. this.water();
        D. Drink.water();

41. Given the following method declaration signature, which of the following is a valid call of this method?
        public void call(int count, String me, String... data)
        A. call(9,"me",10,"Al")
        B. call(5)
        C. call(2,"home","sweet")
        D. call("answering","service")

42. Which statement about a static variable is true?
        A. The value of a static variable must be set when the variable is declared or in a static initialization block.
        B. It is not possible to read static final variables outside the class in which they are defined.
        C. It is not possible to reference static methods using static imports.
        D. A static variable is always available in all instances of the class.

43. Which of the following is not a true statement?
        A. The first line of every constructor is a call to the parent constructor via the super() command.
        B. A class does not have to have a constructor explicitly defined.
        C. A constructor may pass arguments to the parent constructor.
        D. A final instance variable whose value is not set when they are declared or in an initialization block should be set by the constructor.

44. How many final modifiers would need to be removed for this application to compile?
        package park;
        public class Tree {
        public final static long numberOfTrees;
        public final double height;
        static {}
        { final int initHeight = 2;
        height = initHeight;
        }
        static {
        numberOfTrees = 100;
        height = 4;
        }
        }
        A. None
        B. One
        C. Two
        D. The code will not compile regardless of the number of final modifiers removed.

45. What is the output of the following application?
        package jungle;
        public class RainForest extends Forest {
        public RainForest(long treeCount) {
        this.treeCount = treeCount+1;
        }
        public static void main(String[] birds) {
        System.out.print(new RainForest(5).treeCount);
        }
        }
        class Forest {
        public long treeCount;
        public Forest(long treeCount) {
        this.treeCount = treeCount+2;
        }
        }
        A. 5
        B. 6
        C. 8
        D. The code does not compile.

46. What is the output of the following application?
        public class ChooseWisely {
        public ChooseWisely() { super(); }
        public int choose(int choice) { return 5; }
        public int choose(short choice) { return 2; }
        public int choose(long choice) { return 11; }
        public static void main(String[] path) {
        System.out.print(new ChooseWisely().choose((byte)2+1));
        }
        }
        A. 5
        B. 2
        C. 11
        D. The code does not compile.

47. What is the output of the following application?
        package sports;
        public class Football {
        public static Long getScore(Long timeRemaining) {
        return 2*timeRemaining; // m1
        }
        public static void main(String[] refs) {
        final int startTime = 4;
        System.out.print(getScore(startTime)); // m2
        }
        }
        A. 8
        B. The code does not compile because of line m1.
        C. The code does not compile because of line m2.
        D. The code compiles but throws an exception at runtime.

48. Which of the following is a valid method name in Java?
        A. $sprint()
        B. \jog13()
        C. walk#()
        D. %run()

49. Assume there is a class Bouncer with a protected variable. Methods in which class can access this variable?
        A. Only subclasses of Bouncer
        B. Any subclass of Bouncer or any class in the same package as Bouncer
        C. Only classes in the same package as Bouncer
        D. Any superclass of Bouncer

50. Given the following two classes, each in a different package, which line inserted below allows the second class to compile?
        package commerce;
        public class Bank {
                public void withdrawal(int amountInCents) {}
                public void deposit(int amountInCents) {}
        }
        package employee;
        // INSERT CODE HERE
        public class Teller {
        public void processAccount(int depositSlip, int withdrawalSlip) {
        withdrawal(withdrawalSlip);
        deposit(depositSlip);
        }
        }
        A. import static commerce.Bank.*;
        B. static import commerce.Bank.*;
        C. import static commerce.Bank;
        D. None of the above


===================================================== Answers =============================================
1, C, 2, B, 3, D, 4, D, 5, B, 
6, C, 7, B, 8, B, 9, C, 10, A, 

11, B, 12, D, 13, C, 14, A, 15, C, 
16, B, 17, D, 18, A, 19, B, 20, D, 

21, C, 22, D, 23, B, 24, A, 25, A, 
26, D, 27, B, 28, C, 29, A, 30, C, 

31, D, 32, B, 33, A, 34, B, 35, C, 
36, C, 37, D, 38, A, 39, A, 40, B, 

41, C, 42, D, 43, A, 44, D, 45, D, 
46, A, 47, C, 48, A, 49, B, 50, D

১. সি. `protected` মডিফায়ার সাবক্লাস এবং একই প্যাকেজের সদস্যদের অ্যাক্সেসের অনুমতি দেয়, যখন `package-private` মডিফায়ার শুধুমাত্র একই প্যাকেজের সদস্যদের অ্যাক্সেসের অনুমতি দেয়। সুতরাং, `protected` অ্যাক্সেস মডিফায়ার `package-private` অ্যাক্সেস মডিফায়ারের সমস্ত কিছুর পাশাপাশি সাবক্লাসগুলোর অ্যাক্সেসের অনুমতি দেয়, যা অপশন সি-কে সঠিক উত্তর করে তোলে। অপশন এ, বি, এবং ডি ভুল কারণ প্রথম শব্দটি দ্বিতীয়টির চেয়ে বেশি সীমাবদ্ধ অ্যাক্সেস মডিফায়ার।
২. বি. `super()` স্টেটমেন্ট একটি প্যারেন্ট ক্লাসে একটি কনস্ট্রাক্টর কল করতে ব্যবহৃত হয়, যখন `this()` স্টেটমেন্ট একই ক্লাসে একটি কনস্ট্রাক্টর কল করতে ব্যবহৃত হয়, যা অপশন বি-কে সঠিক এবং অপশন এ-কে ভুল করে তোলে। অপশন সি এবং ডি ভুল কারণ সেগুলো কনস্ট্রাক্টর নয়।
৩. ডি. `sell()` মেথডটি কম্পাইল হবে না কারণ যদি উভয় `if-then` স্টেটমেন্টের কন্ডিশনাল এক্সপ্রেশন মিথ্যা হয় তবে এটি কোনো মান ফেরত দেয় না। যদিও যৌক্তিকভাবে এটি সত্য যে দাম হয় 10-এর কম অথবা 10-এর বেশি বা সমান, কম্পাইলার তা জানে না। এটি কেবল জানে যে যদি উভয় `if-then` স্টেটমেন্ট মিথ্যা হয়, তবে এটির কোনো রিটার্ন মান নেই, তাই এটি কম্পাইল হয় না।
৪. ডি. `nested()`-এর তিনটি ওভারলোডেড সংস্করণ কোনো সমস্যা ছাড়াই কম্পাইল হয়, কারণ প্রতিটি মেথড ইনপুট আর্গুমেন্টের একটি ভিন্ন সেট নেয়, যা অপশন বি এবং সি-কে ভুল করে তোলে। 
        তবে, `main()` মেথডের প্রথম লাইনের কারণে কোডটি কম্পাইল হয় না, যা অপশন এ-কে ভুল করে তোলে। 
        `nested()` মেথডের নো-আর্গুমেন্ট সংস্করণ কোনো মান ফেরত দেয় না, এবং `print()` মেথডে একটি `void` রিটার্ন টাইপ আউটপুট করার চেষ্টা করলে রানটাইমে একটি ব্যতিক্রম থ্রো হয়।
৫. বি. জাভাতে মেথডে ডেটা pass-by-value এর মাধ্যমে পাঠানো হয়।
         01. Primitive Data Types: যখন আপনি কোনো প্রিমিটিভ ডেটা টাইপ (যেমন int, float, boolean, ইত্যাদি) মেথডে পাঠান, তখন ঐ ভ্যালুর একটি কপি মেথডে পাঠানো হয়। 
            মেথডের ভেতরে ঐ প্যারামিটারের মান পরিবর্তন করলে, মেথডের বাইরের মূল ভেরিয়েবলের মানের কোনো পরিবর্তন হয় না।
         02. Reference Types: যেমন অবজেক্ট (Object), অ্যারে (Array) ইত্যাদি। যখন এই ধরনের ভেরিয়েবলকে মেথডে পাঠানো হয়, তখন তাদের রেফারেন্সের মান কপি হয়।(রেফারেন্স হলো মেমোরিতে অবজেক্টের অবস্থানের ঠিকানা।)
            যেহেতু রেফারেন্সের মান কপি করা হচ্ছে, তাই মেথডের ভেতরের প্যারামিটার এবং বাইরের আর্গুমেন্ট একই অবজেক্টকে নির্দেশ করে। মেথডে অবজেক্টের ভেতরের পরিবর্তন বাইরেও দেখা যায়। 
             তবে রেফারেন্স পরিবর্তন করলে বাইরের রেফারেন্স অপরিবর্তিত থাকে।
         *** জাভা সব ডেটা টাইপের জন্যই pass-by-value ব্যবহার করে। রেফারেন্স টাইপের ক্ষেত্রে পাঠানো "ভ্যালু" হলো মেমরি অ্যাড্রেস, তাই অবজেক্টের স্টেট পরিবর্তনের আচরণ pass-by-reference এর মতো মনে হতে পারে।

       public class PassByValueReference {

    // প্রিমিটিভ ডেটা টাইপের উদাহরণ
    public static void changeInt(int num) {
        System.out.println("changeInt মেথডের ভেতরে num এর আগের মান: " + num);
        num = 100;
        System.out.println("changeInt মেথডের ভেতরে num এর পরের মান: " + num);
    }

    // রেফারেন্স ডেটা টাইপের উদাহরণ (অ্যারে)
    public static void changeArray(int[] arr) {
        System.out.println("changeArray মেথডের ভেতরে arr[0] এর আগের মান: " + arr[0]);
        arr[0] = 500;
        System.out.println("changeArray মেথডের ভেতরে arr[0] এর পরের মান: " + arr[0]);
        arr = new int[]{1, 2, 3}; // নতুন রেফারেন্স অ্যাসাইন করা হচ্ছে (বাইরের ভেরিয়েবলে প্রভাব ফেলবে না)
        System.out.println("changeArray মেথডের ভেতরে arr এর নতুন রেফারেন্সের arr[0]: " + arr[0]);
    }

    public static void main(String[] args) {
        // প্রিমিটিভ ডেটা টাইপের ব্যবহার
        int number = 50;
        System.out.println("main মেথডে number এর আগের মান: " + number); 
        changeInt(number);
        System.out.println("main মেথডে number এর পরের মান: " + number);
          ------------------ আউটপুট: ----------------------------      
               -main মেথডে number এর আগের মান: 50
               -changeInt মেথডের ভেতরে num এর আগের মান: 50
               -changeInt মেথডের ভেতরে num এর পরের মান: 100
               -main মেথডে number এর পরের মান: 50

        // রেফারেন্স ডেটা টাইপের ব্যবহার (অ্যারে)
        int[] numbers = {100, 200, 300};
        System.out.println("main মেথডে numbers[0] এর আগের মান: " + numbers[0]);
        changeArray(numbers);
        System.out.println("main মেথডে numbers[0] এর পরের মান: " + numbers[0]);
             ------------------ আউটপুট: ----------------------------     
            -main মেথডে numbers[0] এর আগের মান: 100
            -changeArray মেথডের ভেতরে arr[0] এর আগের মান: 100
            -changeArray মেথডের ভেতরে arr[0] এর পরের মান: 500
            -changeArray মেথডের ভেতরে arr এর নতুন রেফারেন্সের arr[0]: 1
            -main মেথডে numbers[0] এর পরের মান: 500
    }
}
      

৬. সি. অপশন এ ভুল কারণ গেটারের একটি মান ফেরত দেওয়া উচিত। অপশন বি ভুল কারণ সেটারের একটি মান নেওয়া উচিত। অপশন ডি ভুল কারণ সেটারের `set` দিয়ে শুরু করা উচিত এবং কোনো মান ফেরত দেওয়া উচিত নয়। অপশন সি একটি সঠিক সেটার ঘোষণা কারণ এটি একটি মান নেয়, `void` রিটার্ন টাইপ ব্যবহার করে এবং সঠিক নামকরণ রীতি ব্যবহার করে।
৭. বি. অপশন এ, সি, এবং ডি একটি কনস্ট্রাক্টরের ভিতরে `this()` কল করা সম্পর্কে সত্য স্টেটমেন্ট। অপশন বি ভুল কারণ একটি কনস্ট্রাক্টর কনস্ট্রাক্টরের প্রথম লাইনে শুধুমাত্র `this()` বা `super()` কল করতে পারে, তবে একই কনস্ট্রাক্টরে কখনই উভয়ই নয়। যদি উভয় কনস্ট্রাক্টরকে কল করার অনুমতি দেওয়া হত, তবে `super()`-এর দুটি পৃথক কল হত, যার ফলে প্যারেন্ট কনস্ট্রাক্টরের ডুপ্লিকেট ইনিশিয়ালাইজেশন হত, কারণ `this()` দ্বারা রেফারেন্স করা অন্য কনস্ট্রাক্টরটিও `super()` কল করত (বা এমন একটির সাথে চেইন করা হত যা অবশেষে `super()` কল করে)।
৮. বি. অপশন এ ভুল কারণ `public` অ্যাক্সেস মডিফায়ার ছোট হাতের অক্ষর দিয়ে শুরু হয়। অপশন সি এবং ডি ভুল কারণ রিটার্ন টাইপ, `void` এবং `String`, মেথড বডির সাথে অসামঞ্জস্যপূর্ণ যা 10-এর একটি পূর্ণসংখ্যা মান ফেরত দেয়। অপশন বি সঠিক এবং প্যাকেজ-প্রাইভেট অ্যাক্সেস রয়েছে। এটি `Long`-এর একটি রিটার্ন টাইপও ব্যবহার করে যা 10-এর পূর্ণসংখ্যা মানটি কোনো সুস্পষ্ট কাস্ট ছাড়াই সহজেই অ্যাসাইন করা যেতে পারে।
৯. সি. ক্লাসের সমস্ত ইনস্ট্যান্সের জন্য সর্বদা উপলব্ধ একমাত্র ভেরিয়েবলগুলো হল যেগুলোকে `static` ঘোষণা করা হয়েছে; সুতরাং, অপশন সি সঠিক উত্তর। অপশন এ সঠিক মনে হতে পারে, তবে পাবলিক ভেরিয়েবলগুলো শুধুমাত্র তখনই উপলব্ধ যদি সমস্ত ইনস্ট্যান্সের মধ্যে অবজেক্টের একটি রেফারেন্স বজায় থাকে। অপশন বি ভুল কারণ জাভাতে কোনো `local` কীওয়ার্ড নেই। অপশন ডি-ও ভুল কারণ একটি প্রাইভেট ইনস্ট্যান্স ভেরিয়েবল শুধুমাত্র সেই ইনস্ট্যান্সের মধ্যেই অ্যাক্সেসযোগ্য যা এটি তৈরি করেছে।
১০. এ. প্রথমত, সমস্ত লাইন কম্পাইল হয় তবে সেগুলো বিভিন্ন ভিন্ন ফলাফল তৈরি করে। মনে রাখবেন যে একটি বুলিয়ান ইনস্ট্যান্স ভেরিয়েবলের ডিফল্ট ইনিশিয়ালাইজেশন হল `false`, যা লাইন p1-এ `outside` কে `false` করে তোলে। সুতরাং, `this(4)` এর কারণে `rope` 5-এ সেট হবে, যখন `this(5)` এর কারণে `rope` 6-এ সেট হবে। যেহেতু 5 হল সেই সংখ্যা যা আমরা খুঁজছি, অপশন এ সঠিক এবং অপশন সি ভুল। অপশন বি ভুল। যদিও স্টেটমেন্টটি `Jump`-এর একটি নতুন ইনস্ট্যান্স তৈরি করে, যার `rope`-এর মান 5, সেই ইনস্ট্যান্সটি নেস্টেড এবং `rope`-এর মান `Jump`-এর পার্শ্ববর্তী ইনস্ট্যান্সকে প্রভাবিত করে না যেখানে কনস্ট্রাক্টর কল করা হয়েছিল। অপশন ডি-ও ভুল। `rope`-এ অ্যাসাইন করা মান 4, লক্ষ্য 5 নয়।

১১. বি. অপশন এ, সি, এবং ডি সত্য স্টেটমেন্ট। বিশেষ করে, অপশন সি আমাদের দুটি অবজেক্টের মধ্যে `equals()` মেথড লিখতে অনুমতি দেয় যা ক্লাসের প্রাইভেট অ্যাট্রিবিউটগুলোর তুলনা করে। অপশন ডি সত্য কারণ `protected` অ্যাক্সেস প্যাকেজ-প্রাইভেট অ্যাক্সেসও প্রদান করে। অপশন বি মিথ্যা। প্যাকেজ-প্রাইভেট অ্যাট্রিবিউটগুলো শুধুমাত্র তখনই দৃশ্যমান যদি দুটি ক্লাস একই প্যাকেজে থাকে, একটি অন্যটিকে এক্সটেন্ড করে কিনা তা নির্বিশেষে।
১২. ডি. stuff ভেরিয়েবল public এর মানে হলো ক্লাসের বাইরের যেকোনো কোড সরাসরি stuff ভেরিয়েবলের মান পড়তে এবং পরিবর্তন করতে পারবে। এটি এনক্যাপসুলেশনের নীতি লঙ্ঘন করে, কারণ ডেটার উপর কোনো নিয়ন্ত্রণ থাকে না। তাই অপশন A সঠিক উত্তর নয়।
১৩. সি. অপশন এ ভুল কারণ যদি ক্লাসে অন্য কোনো কনস্ট্রাক্টর না থাকে তবে জাভা কেবল একটি নো-আর্গুমেন্ট কনস্ট্রাক্টর যুক্ত করে। 
        অপশন বি ভুল কারণ প্যারেন্টের একটি ডিফল্ট নো-আর্গুমেন্ট কনস্ট্রাক্টর থাকতে পারে, যা কম্পাইলার দ্বারা যুক্ত করা হয় এবং চাইল্ড ক্লাসে অ্যাক্সেসযোগ্য। 
        অপশন সি সঠিক। যদি একটি সুপারক্লাসে শুধুমাত্র একটি কনস্ট্রাক্টর থাকে যা আর্গুমেন্ট গ্রহণ করে, তাহলে সাবক্লাসের কনস্ট্রাক্টরকে অবশ্যই স্পষ্টভাবে super() কল করে সেই আর্গুমেন্টযুক্ত কনস্ট্রাক্টরকে কল করতে হবে। 
               ** যদি সাবক্লাসে কোনো কনস্ট্রাক্টর স্পষ্টভাবে ঘোষণা করা না হয়, তবে কম্পাইলার একটি ডিফল্ট নো-আর্গুমেন্ট কনস্ট্রাক্টর তৈরি করার চেষ্টা করবে, যা সুপারক্লাসের আর্গুমেন্টযুক্ত কনস্ট্রাক্টরের সাথে সঙ্গতিপূর্ণ হবে না এবং এরর সৃষ্টি করবে। 
                 তাই, এই পরিস্থিতিতে সাবক্লাসকে অবশ্যই অন্তত একটি কনস্ট্রাক্টর ঘোষণা করতে হবে।
        অবশেষে, অপশন ডি ভুল। দুটি নো-আর্গুমেন্ট কনস্ট্রাক্টর ধারণকারী একটি ক্লাস কম্পাইল হবে না কারণ তাদের একই স্বাক্ষর থাকবে। 
১৪. এ. একটি মেথডে সর্বাধিক একটি ভেরিয়েবল আর্গুমেন্ট প্যারামিটার থাকতে পারে এবং এটি তালিকার শেষ আর্গুমেন্ট হিসাবে উপস্থিত হতে হবে। এই কারণে, অপশন এ সঠিক এবং অপশন বি, সি, এবং ডি ভুল।
১৫. সি. এই সমস্যাটি সমাধানের জন্য, এটি মনে রাখা সহায়ক যে জাভা একটি পাস-বাই-ভ্যালু ভাষা যেখানে প্রিমিটিভ এবং অবজেক্ট রেফারেন্সের কপি মেথডে পাঠানো হয়। এর অর্থ হল একটি অবজেক্টের ডেটা একটি মেথডের মধ্যে পরিবর্তন করা যেতে পারে এবং কলারের সাথে শেয়ার করা যেতে পারে, তবে অবজেক্টের রেফারেন্স নয়। মেথডের মধ্যে অবজেক্টের রেফারেন্সে কোনো পরিবর্তন কলারের কাছে বহন করা হয় না। `slalom()` মেথডে, `Ski` অবজেক্টটি 18-এর `age` মান দিয়ে আপডেট করা হয়। যদিও, `slalom()` মেথডের শেষ লাইন ভেরিয়েবলের মানকে `null` করে দেয়, তবে এটি `main()` মেথডের `mySkier` অবজেক্ট বা রেফারেন্সকে প্রভাবিত করে না। সুতরাং, `mySkier` অবজেক্টটি নাল নয় এবং `age` ভেরিয়েবলটি 18-এ সেট করা হয়েছে, যা অপশন এ এবং ডি-কে ভুল করে তোলে। এর পরে, `name` ভেরিয়েবলটি `Wendy` অবজেক্টে পুনরায় অ্যাসাইন করা হয়েছে, তবে এটি `main()` মেথডের রেফারেন্স পরিবর্তন করে না, তাই `myName` `Rosie` থাকে। অবশেষে, `speed` অ্যারে একটি নতুন অবজেক্ট অ্যাসাইন করা হয়েছে এবং আপডেট করা হয়েছে। যেহেতু রেফারেন্স পুনরায় অ্যাসাইন করার পরে অ্যারে আপডেট করা হয়েছে, তাই এটি `main()` মেথডের `mySpeed` অ্যারেটিকে প্রভাবিত করে না। এর ফলে `mySpeed`-এর ডিফল্ট `int` মান 0 সহ একটি একক উপাদান থাকে। এই কারণে, অপশন বি ভুল এবং অপশন সি সঠিক।

১৬. বি. অপশন এ এবং ডি ক্লাসটিকে কম্পাইল করার অনুমতি দেবে না কারণ ক্লাসের দুটি মেথডের একই নাম এবং আর্গুমেন্ট থাকতে পারে না, তবে একটি ভিন্ন রিটার্ন মান থাকতে পারে। অপশন সি ক্লাসটিকে কম্পাইল করার অনুমতি দেবে, তবে এটি আমাদের `findAverage()` মেথডের একটি বৈধ ওভারলোডেড ফর্ম নয় কারণ এটি একটি ভিন্ন মেথডের নাম ব্যবহার করে। অপশন বি `findAverage()` মেথডের একটি বৈধ ওভারলোডেড সংস্করণ, কারণ নামটি একই তবে আর্গুমেন্ট তালিকা ভিন্ন।
১৭. ডি. এনক্যাপসুলেশন বাস্তবায়ন একটি ক্লাসের অভ্যন্তরীণ অ্যাট্রিবিউটগুলোকে সরাসরি পরিবর্তন করা থেকে বাধা দেয়, তাই অপশন সি একটি সত্য স্টেটমেন্ট। অভ্যন্তরীণ অ্যাট্রিবিউটগুলোতে অ্যাক্সেস প্রতিরোধ করে, আমরা উপাদানগুলোর মধ্যে ক্লাসের ডেটাIntegrity বজায় রাখতে পারি, যা অপশন বি-কে একটি সত্য স্টেটমেন্ট করে তোলে। অপশন এ-ও এনক্যাপসুলেশন সম্পর্কে একটি সত্য স্টেটমেন্ট, যেহেতু ভালোভাবে এনক্যাপসুলেটেড ক্লাসগুলো প্রায়শই ব্যবহার করা সহজ। অপশন ডি একটি ভুল স্টেটমেন্ট। এনক্যাপসুলেশন কর্মক্ষমতা এবং কনকারেন্সি সম্পর্কে কোনো গ্যারান্টি দেয় না।
১৮. এ. অপশন বি ভুল কারণ `String` মানগুলো অপরিবর্তনীয় এবং পরিবর্তন করা যায় না। অপশন সি এবং ডি-ও ভুল কারণ জাভাতে ভেরিয়েবলগুলো রেফারেন্স দ্বারা নয়, মান দ্বারা পাস করা হয়। অপশন এ সঠিক উত্তর। যখন কোনো মেথডে একটি অ্যারে পাস করা হয় তখন অ্যারের বিষয়বস্তু পরিবর্তন করা যেতে পারে, কারণ অবজেক্টের রেফারেন্সের একটি কপি পাস করা হয়। উদাহরণস্বরূপ, মেথডটি একটি অ-খালি অ্যারের প্রথম উপাদান পরিবর্তন করতে পারে।
১৯. বি. অপশন এ জাভাতে বৈধ সিনট্যাক্স নয়। অপশন সি সঠিক হত যদি একটি `static import` থাকত, তবে প্রশ্নটি বিশেষভাবে বলে যে কোনোটি নেই। অপশন ডি প্রায় সঠিক, কারণ এটি মেথড কল করার একটি উপায়, তবে প্রশ্নটি মেথড কল করার সর্বোত্তম উপায় জিজ্ঞাসা করে। সেই ক্ষেত্রে, অপশন বি মেথড কল করার সর্বোত্তম উপায়, কারণ আমাদের দেওয়া হয়েছে যে দুটি ক্লাস একই প্যাকেজে রয়েছে, তাই প্যাকেজের নামের প্রয়োজন হবে না।
২০. ডি. অপশন এ এবং বি ভুল কারণ একটি নন-ভয়েড রিটার্ন টাইপ সহ একটি মেথডের `return` স্টেটমেন্ট ব্যবহার করে একটি মান ফেরত দেওয়া প্রয়োজন। অপশন সি-ও ভুল কারণ একটি `void` রিটার্ন টাইপ সহ একটি মেথড এখনও কোনো মান ছাড়াই `return` কমান্ড কল করতে এবং মেথড থেকে বেরিয়ে আসতে পারে। সুতরাং, অপশন ডি সঠিক উত্তর।

২১. সি. final int result = score++ < 5 ? 2 : win; score++ চেষ্টা করছে score এর মান বৃদ্ধি করতে, যা final ঘোষণার নিয়ম লঙ্ঘন করে। return result+=win; final int result ভেরিয়েবলের মান একবার নির্ধারণ করার পরে আর পরিবর্তন করা যায় না। 
         - `final` with Classes: তখন সেই ক্লাসকে আর কোনো সাবক্লাস তৈরি করা যায় না। অর্থাৎ, এটি একটি অপরিবর্তনীয় ক্লাস (immutable class) হিসেবে কাজ করে যার কোনো চাইল্ড ক্লাস থাকতে পারে না।
         - `final` with Variables: তখন তার মান একবার নির্ধারণ করার পর আর পরিবর্তন করা যায় না। অর্থাৎ, এটি একটি ধ্রুবক (constant) হিসেবে কাজ করে।
                                    *** final ভেরিয়েবলকে অবশ্যই ঘোষণার সময় অথবা কনস্ট্রাক্টরের মধ্যে ইনিশিয়ালাইজ করতে হবে।
         - `final` with Methods: তখন সেই মেথডকে কোনো সাবক্লাস ওভাররাইড (override) করতে পারে না।
         - `final` with Parameter: তখন প্যারামিটারের মান মেথডের ভেতরে আর পরিবর্তন করা যায় না। 
               public static int finish(final int score) {
                   // score = score + 10; // এটি একটি কম্পাইল-টাইম এরর তৈরি করবে
                   int finalScore = score + 5;
                   return finalScore;
               }
২২. ডি. `super()` স্টেটমেন্ট প্যারেন্ট ক্লাসে একটি কনস্ট্রাক্টর কল করতে ব্যবহৃত হয়, যখন `super` প্যারেন্ট ক্লাসের একটি সদস্যকে রেফারেন্স করতে ব্যবহৃত হয়। `this()` স্টেটমেন্ট বর্তমান ক্লাসে একটি কনস্ট্রাক্টর কল করতে ব্যবহৃত হয়, যখন `this` বর্তমান ক্লাসের একটি সদস্যকে রেফারেন্স করতে ব্যবহৃত হয়। এই কারণে, অপশন ডি সঠিক উত্তর।
২৩. বি. মেথড স্বাক্ষরের প্যাকেজ-প্রাইভেট, বা ডিফল্ট, অ্যাক্সেস রয়েছে; সুতরাং, এটি একই প্যাকেজের ক্লাসগুলোর কাছে অ্যাক্সেসযোগ্য, যা অপশন বি-কে সঠিক উত্তর করে তোলে।
২৪. এ. `strength`-এর অ্যাক্সেস মডিফায়ার `protected`, যার অর্থ সাবক্লাস এবং একই প্যাকেজের ক্লাসগুলো এটিকে পরিবর্তন করতে পারে। মানটিকে `private`-এ পরিবর্তন করলে `Protect` ক্লাসটিকে সরাসরি এটি পরিবর্তন করতে সক্ষম একমাত্র ক্লাস করে এনক্যাপসুলেশন উন্নত হবে। এই কারণে, প্রথম স্টেটমেন্টটি সঠিক। বিকল্পভাবে, দ্বিতীয় এবং তৃতীয় স্টেটমেন্টগুলো ক্লাসের এনক্যাপসুলেশন উন্নত করে না। প্রাইভেট ভেরিয়েবলগুলোর জন্য গেটার এবং সেটার থাকা সহায়ক হলেও, সেগুলো বাধ্যতামূলক নয়। এনক্যাপসুলেশন ডেটা উপাদানগুলোকে রক্ষা করার বিষয়ে। এটি মনে রেখে, এটি স্পষ্ট যে `material` ভেরিয়েবলটি ইতিমধ্যেই `protected`। সুতরাং, অপশন এ সঠিক উত্তর।
২৫. এ. অপশন এ সঠিক কারণ মেথডের নামে আন্ডারস্কোর `_` অক্ষর এবং ডলার `$` চিহ্ন উভয়ই অন্তর্ভুক্ত থাকতে পারে। মনে রাখবেন যে কোনো মেথডের ছোট হাতের অক্ষর দিয়ে শুরু করার কোনো নিয়ম নেই; এটি কেবল সম্প্রদায়ের দ্বারা গৃহীত একটি অনুশীলন। অপশন বি ভুল কারণ হাইফেন `-` অক্ষর মেথডের নামের অংশ হতে পারে না। অপশন সি ভুল কারণ `new` জাভাতে একটি সংরক্ষিত শব্দ। অবশেষে, অপশন ডি ভুল। একটি মেথডের নাম একটি অক্ষর, ডলার `$` চিহ্ন, বা আন্ডারস্কোর `_` অক্ষর দিয়ে শুরু হতে হবে।

২৬. ডি. লাইনে যাই ঢোকানো হোক না কেন কোডটি কম্পাইল হবে না কারণ মেথডের স্বাক্ষর অবৈধ। রিটার্ন টাইপ, `int`, মেথডের নামের আগে এবং যেকোনো অ্যাক্সেস, `final`, বা `static` মডিফায়ারের পরে যাওয়া উচিত। সুতরাং, অপশন ডি সঠিক উত্তর। যদি মেথড ঘোষণার `int` এবং `static`-এর ক্রম পরিবর্তন করে মেথডটি ঠিক করা হত, তবে অপশন সি সঠিক উত্তর হত। তবে, অপশন এ এবং বি এখনও ভুল, কারণ প্রতিটি এমন একটি রিটার্ন টাইপ ব্যবহার করে যা অন্তর্নিহিতভাবে `int`-এ রূপান্তরিত হতে পারে না।
২৭. বি. জাভা পাস-বাই-ভ্যালু ব্যবহার করে, যখন আপনি একটি অবজেক্ট একটি মেথডে পাস করেন, তখন সেই অবজেক্টের রেফারেন্সের একটি কপি পাস করা হয়। কলিং মেথডের রেফারেন্স এবং কল করা মেথডের কপির রেফারেন্স উভয়ই মেমরিতে একই অবজেক্টকে নির্দেশ করে। সেইজন্য, যদি আপনি মেথডের ভিতরে কপির রেফারেন্সের মাধ্যমে সেই অবজেক্টের অবস্থা (ভেতরের ডেটা) পরিবর্তন করেন, তবে সেই পরিবর্তনগুলি কলিং মেথডের মূল রেফারেন্সের মাধ্যমে দৃশ্যমান হবে।
২৮. সি. জাভাতে, একটি final ইনস্ট্যান্স ভেরিয়েবলকে অবশ্যই তার ঘোষণার সময় অথবা ক্লাসের কনস্ট্রাক্টরের মধ্যে একটি মান নির্ধারণ করতে হবে। যেহেতু contents কে এই দুটি জায়গার কোনওটিতেই ইনিশিয়ালাইজ করা হয়নি এবং setContents() মেথডটি অবজেক্ট তৈরি হওয়ার পরে এটিকে একটি মান নির্ধারণ করার চেষ্টা করছে, তাই কম্পাইলার এটিকে একটি ত্রুটি হিসাবে চিহ্নিত করবে।
২৯. এ. জাভাBean মেথডগুলো বুলিয়ান মানের জন্য `get`, `set`, এবং `is` উপসর্গ ব্যবহার করে, যা অপশন এ-কে সঠিক পছন্দ করে তোলে।
৩০. সি. অপশন এ ভুল কারণ `static` এবং `import` কীওয়ার্ডগুলো বিপরীত ক্রমে রয়েছে। `Closet` ক্লাস `Store` ক্লাসের নামের কোনো রেফারেন্স ছাড়াই `getClothes()` মেথড ব্যবহার করে, তাই একটি `static import` প্রয়োজন। এই কারণে, অপশন বি ভুল কারণ এতে `static` কীওয়ার্ড অনুপস্থিত। অপশন ডি-ও ভুল কারণ `static import` ক্লাসের সদস্যদের সাথে ব্যবহৃত হয়, ক্লাসের নামের সাথে নয়। অবশেষে, অপশন সি সঠিক উত্তর কারণ এটি `static import` ব্যবহার করে মেথডটিকে সঠিকভাবে ক্লাসে ইম্পোর্ট করে।

৩১. ডি. জাভাতে, অ্যাক্সেস মডিফায়ারের অভাব নির্দেশ করে যে সদস্যটি প্যাকেজ-প্রাইভেট, সুতরাং অপশন ডি সঠিক। মনে রাখবেন যে `default` কীওয়ার্ড ইন্টারফেস এবং `switch` স্টেটমেন্টের জন্য ব্যবহৃত হয় এবং এটি কোনো অ্যাক্সেস মডিফায়ার নয়।
৩২. বি. কোডটি কম্পাইল হবে না। super() কলটি শুধুমাত্র কনস্ট্রাক্টরের প্রথম স্টেটমেন্ট হিসেবে ব্যবহার করা যেতে পারে। যেহেতু ৪ নম্বর লাইনের Stars() একটি মেথড, কনস্ট্রাক্টর নয়, তাই এখানে super() কলটি অবৈধ।
৩৩. এ. একটি ইনস্ট্যান্স মেথড বা কনস্ট্রাক্টরের সমস্ত স্ট্যাটিক ভেরিয়েবলের অ্যাক্সেস থাকে, যা অপশন এ-কে সঠিক করে তোলে। অন্যদিকে, স্ট্যাটিক মেথড এবং স্ট্যাটিক ইনিশিয়ালাইজার ইনস্ট্যান্স ভেরিয়েবলকে রেফারেন্স করতে পারে না কারণ সেগুলো সমস্ত ইনস্ট্যান্স জুড়ে সংজ্ঞায়িত, যা অপশন বি এবং সি-কে ভুল করে তোলে। মনে রাখবেন যে যদি তাদের একটি নির্দিষ্ট ইনস্ট্যান্সের রেফারেন্স পাস করা হয় তবে তারা ইনস্ট্যান্স ভেরিয়েবল অ্যাক্সেস করতে পারে, তবে সাধারণ ক্ষেত্রে নয়। অবশেষে, অপশন ডি ভুল কারণ স্ট্যাটিক ফাইনাল ভেরিয়েবলগুলো ঘোষণা করার সময় বা একটি স্ট্যাটিক ইনিশিয়ালাইজেশন ব্লকে সেট করতে হবে।
৩৪. বি. একটি Byte অবজেক্ট (যা আনবক্স হয়ে একটি byte-এ পরিণত হবে) ফেরত দেওয়া একটি short মেথডের জন্য বৈধ রিটার্ন টাইপ। return new Byte((byte)6);: Byte হল প্রিমিটিভ byte-এর র‍্যাপার ক্লাস। একটি byte হল short-এর চেয়ে ছোট ডেটা টাইপ এবং এটিকে অন্তর্নিহিতভাবে short-এ উন্নীত করা যেতে পারে।
৩৫. সি. ওভারলোডেড মেথডগুলোর নাম একই থাকে তবে প্যারামিটারের তালিকা ভিন্ন থাকে, যা প্রথম এবং তৃতীয় স্টেটমেন্টকে সত্য করে তোলে। দ্বিতীয় স্টেটমেন্টটি মিথ্যা, কারণ ওভারলোডেড মেথডগুলোর রিটার্ন টাইপ একই বা ভিন্ন হতে পারে। সুতরাং, অপশন সি সঠিক উত্তর।

৩৬. সি. `monday`-এর ঘোষণা কম্পাইল হবে না, কারণ একটি স্ট্যাটিক ফাইনাল ভেরিয়েবলের মান ঘোষণা করার সময় বা একটি স্ট্যাটিক ইনিশিয়ালাইজেশন ব্লকে সেট করতে হবে। `tuesday`-এর ঘোষণা ঠিক আছে এবং কোনো সমস্যা ছাড়াই কম্পাইল হয়। `wednesday`-এর ঘোষণা কম্পাইল হবে না কারণ ভেরিয়েবলের কোনো ডেটা টাইপ নেই। অবশেষে, `thursday`-এর ঘোষণা কম্পাইল হবে না কারণ `final` মডিফায়ার অ্যাক্সেস মডিফায়ারের আগে আসতে পারে না। এই কারণে, অপশন সি সঠিক উত্তর।
৩৭. ডি. `Puppy` ক্লাস কোনো কনস্ট্রাক্টর ঘোষণা করে না, তাই ডিফল্ট নো-আর্গুমেন্ট কনস্ট্রাক্টর স্বয়ংক্রিয়ভাবে কম্পাইলার দ্বারা যুক্ত করা হয়। ক্লাসে যা কনস্ট্রাক্টরের মতো দেখাচ্ছে তা আসলে `void` রিটার্ন টাইপের একটি মেথড। সুতরাং, `main()` মেথডের `new Puppy(2)` অবজেক্ট তৈরি করার লাইনটি কম্পাইল হবে না, কারণ একটি `int` মান নিতে সক্ষম কোনো কনস্ট্রাক্টর নেই, যা অপশন ডি-কে সঠিক উত্তর করে তোলে।
৩৮. এ. `public` মডিফায়ার একই ক্লাস, প্যাকেজ, সাবক্লাস, বা এমনকি অন্যান্য প্যাকেজের ক্লাসগুলোর সদস্যদের অ্যাক্সেসের অনুমতি দেয়, যখন `private` মডিফায়ার শুধুমাত্র একই ক্লাসের সদস্যদের অ্যাক্সেসের অনুমতি দেয়। সুতরাং, `public` অ্যাক্সেস মডিফায়ার `private` অ্যাক্সেস মডিফায়ারের সমস্ত কিছুর অ্যাক্সেসের অনুমতি দেয় এবং আরও বেশি, যা অপশন এ-কে সঠিক উত্তর করে তোলে। অপশন বি, সি, এবং ডি ভুল কারণ প্রথম শব্দটি দ্বিতীয়টির চেয়ে বেশি সীমাবদ্ধ অ্যাক্সেস মডিফায়ার।
৩৯. এ. এখানে মূল বিষয় হল জাভা মেথডে অবজেক্ট রেফারেন্স পাঠানোর জন্য পাস বাই ভ্যালু ব্যবহার করে। যেহেতু `sendHome()` মেথডের প্রথম লাইনে `Phone` রেফারেন্স `p` পুনরায় অ্যাসাইন করা হয়েছিল, তাই `p` রেফারেন্সে যেকোনো পরিবর্তন একটি নতুন অবজেক্টে করা হয়েছিল। অন্য কথায়, `sendHome()` মেথডের কোনো পরিবর্তন পাস করা অবজেক্টটিকে প্রভাবিত করেনি। সুতরাং, মেথড কলের আগে এবং পরে `size`-এর মান একই ছিল, যার ফলে আউটপুট 3 হয় এবং অপশন এ সঠিক উত্তর।
৪০. বি. অপশন এ এবং ডি সমতুল্য এবং কোডটিকে কম্পাইল করার অনুমতি দেবে। উভয়ই একটি ইনস্ট্যান্স মেথডের মধ্যে থেকে একটি স্ট্যাটিক মেথড অ্যাক্সেস করার সঠিক উপায়। অপশন বি সঠিক উত্তর। ক্লাসটি কম্পাইল হবে না কারণ `this.Drink`-এর কম্পাইলারের কাছে কোনো অর্থ নেই। অবশেষে, অপশন সি এখনও কোডটিকে কম্পাইল করার অনুমতি দেবে, যদিও এটিকে দুর্বল কোডিং অনুশীলন হিসাবে বিবেচনা করা হয়। যদিও স্ট্যাটিক সদস্যদের স্ট্যাটিক উপায়ে অ্যাক্সেস করা উচিত, তবে এটি বাধ্যতামূলক নয়।

৪১. সি. মেথড স্বাক্ষরের জন্য একটি `int` মান, তারপরে ঠিক একটি `String`, তারপরে `String` ভেরিয়েবল আর্গুমেন্ট, যা `String` মানের একটি অ্যারে বা শূন্য বা একাধিক স্বতন্ত্র `String` মান হতে পারে। শুধুমাত্র অপশন সি এই প্রয়োজনীয়তাগুলো মেনে চলে, যা এটিকে সঠিক উত্তর করে তোলে।
৪২. ডি. অপশন এ শুধুমাত্র ফাইনাল স্ট্যাটিক ভেরিয়েবল সম্পর্কে একটি স্টেটমেন্ট, সমস্ত স্ট্যাটিক ভেরিয়েবল সম্পর্কে নয়। অপশন বি শুধুমাত্র প্রাইভেট, ফাইনাল নয়, স্ট্যাটিক ভেরিয়েবলের ক্ষেত্রে প্রযোজ্য। অপশন সি ভুল কারণ স্ট্যাটিক ইম্পোর্ট ভেরিয়েবল এবং মেথড উভয়কেই রেফারেন্স করতে ব্যবহার করা যেতে পারে। অপশন ডি সঠিক উত্তর কারণ একটি স্ট্যাটিক ভেরিয়েবল ক্লাসের সমস্ত ইনস্ট্যান্সের কাছে অ্যাক্সেসযোগ্য।
৪৩. এ. অপশন এ সঠিক উত্তর কারণ একটি কনস্ট্রাক্টরের প্রথম লাইন `this()` বা `super()` হতে পারে, যা এটিকে একটি অসত্য স্টেটমেন্ট করে তোলে। অপশন বি একটি সত্য স্টেটমেন্ট কারণ যদি কোনো ডিফল্ট নো-আর্গুমেন্ট কনস্ট্রাক্টর সংজ্ঞায়িত না থাকে তবে কম্পাইলার সেটি যুক্ত করবে। অপশন সি-ও একটি সত্য স্টেটমেন্ট, কারণ প্যারেন্ট ক্লাসে যদি এমন কনস্ট্রাক্টর সংজ্ঞায়িত থাকে তবে প্যারেন্ট কনস্ট্রাক্টরে শূন্য বা একাধিক আর্গুমেন্ট পাস করা যেতে পারে। অপশন ডি-ও সত্য। একটি ফাইনাল ইনস্ট্যান্স ভেরিয়েবলের মান ঘোষণা করার সময়, একটি ইনিশিয়ালাইজেশন ব্লকে, বা একটি কনস্ট্রাক্টরে সেট করা উচিত।
৪৪. ডি. শেষ স্ট্যাটিক ইনিশিয়ালাইজেশন ব্লক `height` অ্যাক্সেস করে, যা একটি ইনস্ট্যান্স ভেরিয়েবল, স্ট্যাটিক ভেরিয়েবল নয়। সুতরাং, যতগুলো `final` মডিফায়ার সরানো হোক না কেন কোডটি কম্পাইল হবে না, যা অপশন ডি-কে সঠিক উত্তর করে তোলে। মনে রাখবেন যদি `height = 4;` লাইনটি সরানো হত, তবে ক্লাসটিকে কম্পাইল করার জন্য কোনো `final` মডিফায়ার সরানোর প্রয়োজন হত না।
৪৫. ডি. যেহেতু `RainForest()` কনস্ট্রাক্টরের প্রথম লাইন কনস্ট্রাক্টর কল নয়, তাই কম্পাইলার নো-আর্গুমেন্ট `super()` কল যুক্ত করে। যেহেতু প্যারেন্ট ক্লাস, `Forest`, কোনো নো-আর্গুমেন্ট `super()` কনস্ট্রাক্টর সংজ্ঞায়িত করে না, তাই `RainForest()` কনস্ট্রাক্টর কম্পাইল হবে না এবং অপশন ডি সঠিক।

৪৬. এ. public class ChooseWisely { public ChooseWisely() { super(); } | super() কলটি প্যারেন্ট ক্লাসের (এই ক্ষেত্রে java.lang.Object) কনস্ট্রাক্টরকে স্পষ্টভাবে কল করে। যদি আপনি super() কলটি স্পষ্টভাবে না লেখেন, তবে জাভা কম্পাইলার স্বয়ংক্রিয়ভাবে ডিফল্ট সুপারক্লাস কনস্ট্রাক্টরকে কল করবে।
        .choose((byte)2+1): এখানে (byte)2: ইন্টিজার ২ কে byte টাইপে কাস্ট করে। +1: এখানে একটি byte এবং একটি int (১) এর মধ্যে যোগ অপারেশন হচ্ছে। 
        জাভাতে, যখন একটি গাণিতিক অপারেশনে byte, short, বা char এর সাথে int (বা তার চেয়ে বড় টাইপ) জড়িত থাকে, তখন ছোট টাইপটি স্বয়ংক্রিয়ভাবে int-এ উন্নীত (promoted) হয়। সুতরাং, (byte)2 + 1 এর ফলাফল একটি int হবে।
৪৭. সি. `startTime` ভেরিয়েবলটি কম্পাইলার দ্বারা স্বয়ংক্রিয়ভাবে `Integer`-এ রূপান্তরিত হতে পারে, তবে `Integer` `Long`-এর সাবক্লাস নয়। সুতরাং, লাইন m2-এ `getScore()` মেথডে ভুল ভেরিয়েবল টাইপ পাস করার কারণে কোডটি কম্পাইল হবে না এবং অপশন সি সঠিক।
৪৮. এ. জাভা মেথডগুলো একটি অক্ষর, ডলার `$` চিহ্ন, বা আন্ডারস্কোর `_` অক্ষর দিয়ে শুরু হতে হবে।। হ্যাশট্যাগ (#) চিহ্ন মেথডের নামে অন্তর্ভুক্ত করা যাবে না।
৪৯. বি. `protected` মডিফায়ার যেকোনো সাবক্লাস বা একই প্যাকেজের ক্লাসের অ্যাক্সেসের অনুমতি দেয়, তাই অপশন বি সঠিক উত্তর।
৫০. ডি. একটি স্ট্যাটিক ইম্পোর্ট অন্য ক্লাসের স্ট্যাটিক সদস্যদের ইম্পোর্ট করতে ব্যবহৃত হয়। এই ক্ষেত্রে, `Bank` ক্লাসের `withdrawal()` এবং `deposit()` মেথডগুলো স্ট্যাটিক চিহ্নিত করা হয়নি। সেগুলো ব্যবহারের জন্য `Bank`-এর একটি ইনস্ট্যান্সের প্রয়োজন এবং স্ট্যাটিক মেথড হিসাবে ইম্পোর্ট করা যাবে না। সুতরাং, অপশন ডি সঠিক। যদি `Bank` ক্লাসের দুটি মেথড স্ট্যাটিক চিহ্নিত করা হত, তবে অপশন এ সঠিক উত্তর হত কারণ একাধিক মেথড ইম্পোর্ট করার জন্য স্ট্যাটিক ইম্পোর্টের সাথে ওয়াইল্ডকার্ড ব্যবহার করা যেতে পারে। অপশন বি `static` এবং `import` কীওয়ার্ডগুলো বিপরীত করে, যখন অপশন সি ভুলভাবে একটি ক্লাস ইম্পোর্ট করে, যা স্ট্যাটিক ইম্পোর্টের মাধ্যমে ইম্পোর্ট করা যায় না।













1. C. The protected modifier allows access by subclasses and members within the same package, while the package-private modifier allows access only to members in the same package.
Therefore, the protected access modifier allows access to everything the package-private access modifier, plus subclasses, making Option C the correct answer. Options A, B, and D
are incorrect because the first term is a more restrictive access modifier than the second term.
2. B. The super() statement is used to call a constructor in a parent class, while the this() statement is used to call a constructor in the same class, making Option B correct and
Option A incorrect. Options C and D are incorrect because they are not constructors.
3. D. The sell() method does not compile because it does not return a value if both of the if-then statements’ conditional expressions evaluate to false. While logically, it is true
that price is either less than 10 or greater than or equal to 10, the compiler does not know that. It just knows that if both if-then statements evaluate to false, then it does not have a
return value, therefore it does not compile.
4. D. The three overloaded versions of nested() compile without issue, since each method takes a different set of input arguments, making Options B and C incorrect. The code does
not compile, though, due to the first line of the main() method, making Option A incorrect. The no-argument version of the nested() method does not return a value, and trying
to output a void return type in the print() method throws an exception at runtime.
5. B. Java uses pass-by-value to copy primitives and references of objects into a method. That means changes to the primitive value or reference in the method are not carried to the calling
method. That said, the data within an object can change, just not the original reference itself. Therefore, Option B is the correct answer, and Options C and D are incorrect.
Option A is not a real term.

6. C. Option A is incorrect because the getter should return a value. Option B is incorrect because the setter should take a value. Option D is incorrect because the setter should start
with set and should not return a value. Option C is a correct setter declaration because it takes a value, uses the void return type, and uses the correct naming convention.
7. B. Options A, C, and D are true statements about calling this() inside a constructor. Option B is incorrect because a constructor can only call this() or super() on the first
line of the constructor, but never both in the same constructor. If both constructors were allowed to be called, there would be two separate calls to super(), leading to duplicate initialization
of parent constructors, since the other constructor referenced by this() would also call super() (or be chained to one that eventually calls super()).
8. B. Option A is incorrect because the public access modifier starts with a lowercase letter. Options C and D are incorrect because the return types, void and String, are incompatible
with the method body that returns an integer value of 10. Option B is correct and has package-private access. It also uses a return type of Long that the integer value of 10 can be
easily assigned to without an explicit cast.
9. C. The only variables always available to all instances of the class are those declared static; therefore, Option C is the correct answer. Option A may seem correct, but public
variables are only available if a reference to the object is maintained among all instances. Option B is incorrect because there is no local keyword in Java. Option D is also incorrect
because a private instance variable is only accessible within the instance that created it.
10. A. First off, all of the lines compile but they produce various different results. Remember that the default initialization of a boolean instance variable is false, making outside
false at line p1. Therefore, this(4) will cause rope to be set to 5, while this(5) will cause rope to be set to 6. Since 5 is the number we are looking for, Option A is correct, and
Option C is incorrect. Option B is incorrect. While the statement does create a new instance of Jump, with rope having a value of 5, that instance is nested and the value of rope does
not affect the surrounding instance of Jump that the constructor was called in. Option D is also incorrect. The value assigned to rope is 4, not the target 5.

11. B. Options A, C, and D are true statements. In particular, Option C allows us to write the equals() methods between two objects that compare private attributes of the class.
Option D is true because protected access also provides package-private access. Option B is false. Package-private attributes are only visible if the two classes are in the same package,
regardless of whether one extends the other.
12. D. The class data, stuff, is declared public, allowing any class to modify the stuff variable and making the implementation inherently unsafe for encapsulation. Therefore, there are no
values that can be placed in the two blanks to ensure the class properly encapsulates its data, making Option D correct. Note that if stuff was declared private, Options A, B, and C
would all be correct. Encapsulation does not require JavaBean syntax, just that the internal attributes are protected from outside access, which all of these sets of values do achieve.
13. C. Option A is incorrect because Java only inserts a no-argument constructor if there are no other constructors in the class. Option B is incorrect because the parent can have a
default no-argument constructor, which is inserted by the compiler and accessible in the child class. Finally, Option D is incorrect. A class that contains two no-argument constructors
will not compile because they would have the same signature. Finally, Option C is correct. If a class extends a parent class that does not include a no-argument constructor,
the default no-argument constructor cannot be automatically inserted into the child class by the compiler. Instead, the developer must explicitly declare at least one constructor and
explicitly define how the call to the parent constructor is made.
14. A. A method may contain at most one varargs parameter, and it must appear as the last argument in the list. For this reason, Option A is correct, and Options B, C, and D are incorrect.
15. C. To solve this problem, it helps to remember that Java is a pass-by-value language in which copies of primitives and object references are sent to methods. This also means that
an object’s data can be modified within a method and shared with the caller, but not the reference to the object. Any changes to the object’s reference within the method are not carried
over to the caller. In the slalom() method, the Ski object is updated with an age value of 18. Although, the last line of the slalom() method changes the variable value to
null, it does not affect the mySkier object or reference in the main() method. Therefore, the mySkier object is not null and the age variable is set to 18, making Options A and
D incorrect. Next, the name variable is reassigned to the Wendy object, but this does not change the reference in the main() method, so myName remains Rosie. Finally, the speed
array is assigned a new object and updated. Since the array is updated after the reference is reassigned, it does not affect the mySpeed array in the main() method. The result is that
mySpeed continues to have a single element with the default int value of 0. For these reasons, Option B is incorrect, and Option C is correct.

16. B. Options A and D would not allow the class to compile because two methods in the class cannot have the same name and arguments, but a different return value. Option C would
allow the class to compile, but it is not a valid overloaded form of our findAverage() method since it uses a different method name. Option B is a valid overloaded version of the
findAverage() method, since the name is the same but the argument list differs.
17. D. Implementing encapsulation prevents internal attributes of a class from being modified directly, so Option C is a true statement. By preventing access to internal attributes, we can
also maintain class data integrity between elements, making Option B a true statement. Option A is also a true statement about encapsulation, since well-encapsulated classes are
often easier to use. Option D is an incorrect statement. Encapsulation makes no guarantees about performance and concurrency.
18. A. Option B is incorrect because String values are immutable and cannot be modified. Options C and D are also incorrect since variables are passed by value, not reference, in
Java. Option A is the correct answer. The contents of an array can be modified when passed to a method, since a copy of the reference to the object is passed. For example, the method
can change the first element of a non-empty array.
19. B. Option A is not a valid syntax in Java. Option C would be correct if there was a static import, but the question specifically says there are not any. Option D is almost
correct, since it is a way to call the method, but the question asks for the best way to call the method. In that regard, Option B is the best way to call the method, since we are
given that two classes are in the same package, therefore the package name would not be required.
20. D. Options A and B are incorrect because a method with a non-void return type requires that the method return a value using the return statement. Option C is also incorrect since
a method with a void return type can still call the return command with no values and exit the method. Therefore, Option D is the correct answer.

21. C. The finish() method modifies two variables that are marked final, score and result. The score variable is modified by the post-increment ++ operator, while the
result variable is modified by the compound addition += operator. Removing both final modifiers allows the code to compile. For this reason, Option C is the correct answer.
22. D. The super() statement is used to call a constructor in the parent class, while super is used to reference a member of the parent class. The this() statement is used to call a constructor
in the current class, while this is used to reference a member of the current class. For these reasons, Option D is the correct answer.
23. B. The method signature has package-private, or default, access; therefore, it is accessible to classes in the same package, making Option B the correct answer.
24. A. The access modifier of strength is protected, meaning subclasses and classes within the same package can modify it. Changing the value to private would improve encapsulation
by making the Protect class the only one capable of directly modifying it. For these reasons, the first statement is correct. Alternatively, the second and third statements do not
improve the encapsulation of the class. While having getters and setters for private variables is helpful, they are not required. Encapsulation is about protecting the data elements.
With this in mind, it is clear the material variable is already protected. Therefore, Option A is the correct answer.
25. A. Option A is correct since method names may include the underscore _ character as well as the dollar $ symbol. Note that there is no rule that requires a method start with a lowercase
character; it is just a practice adopted by the community. Option B is incorrect because the hyphen - character may not be part of a method name. Option C is incorrect since new
is a reserved word in Java. Finally, Option D is incorrect. A method name must start with a letter, the dollar $ symbol, or an underscore _ character.

26. D. The code does not compile, regardless of what is inserted into the line because the method signature is invalid. The return type, int, should go before the method name and
after any access, final, or static modifiers. Therefore, Option D is the correct answer. If the method was fixed, by swapping the order of int and static in the method declaration,
then Option C would be the correct answer. Options A and B are still incorrect, though, since each uses a return type that cannot be implicitly converted to int.
27. B. Java uses pass-by-value, so changes made to primitive values and object references passed to a method are not reflected in the calling method. For this reason, Options A
and C are incorrect statements. Option D is also an invalid statement because it is a special case of Option A. Finally, Option B is the correct answer. Changes to the data within
an object are visible to the calling method since the object that the copied reference points to is the same.
28. C. The code contains a compilation problem in regard to the contents instance variable. The contents instance variable is marked final, but there is a setContents()
instance method that can change the value of the variable. Since these two are incompatible, the code does not compile, and Option C is correct. If the final modifier was
removed from the contents variable declaration, then the expected output would be of the form shown in Option A.
29. A. JavaBean methods use the prefixes get, set, and is for boolean values, making Option A the correct choice.
30. C. Option A is incorrect because the keywords static and import are reversed. The Closet class uses the method getClothes() without a reference to the class name Store,
therefore a static import is required. For this reason, Option B is incorrect since it is missing the static keyword. Option D is also incorrect since static imports are used
with members of the class, not a class name. Finally, Option C is the correct answer since it properly imports the method into the class using a static import.

31. D. In Java, the lack of an access modifier indicates that the member is package-private, therefore Option D is correct. Note that the default keyword is used for interfaces and
switch statements, and is not an access modifier.
32. B. The code does not compile, so Option A is incorrect. The class contains two constructors and one method. The first method, Stars(), looks a lot like a no-argument constructor, but
since it has a return value of void, it is a method, not a constructor. Since only constructors can call super(), the code does not compile due to this line. The only constructor in this
class, which takes an int value as input, performs a pointless assignment, assigning a variableto itself. While this assignment has no effect, it does not prevent the code from compiling.
Finally, the main() method compiles without issue since we just inserted the full package name into the class constructor call. This is how a class that does not use an import statement
could call the constructor. Since the method is in the same class, and therefore the same package, it is redundant to include the package name but not disallowed. Because only one
line causes the class to fail to compile, Option B is correct.
33. A. An instance method or constructor has access to all static variables, making Option A correct. On the other hand, static methods and static initializers cannot
reference instance variables since they are defined across all instances, making Options B and C incorrect. Note that they can access instance variables if they are passed a reference
to a specific instance, but not in the general case. Finally, Option D is incorrect because static final variables must be set when they are declared or in a static initialization block.
34. B. The method calculateDistance() requires a return type that can be easily converted to a short value. Options A, C, and D are incorrect because they each use a larger data
type that requires an explicit cast. Option D also does not compile because the Short constructor requires an explicit cast to convert the value of 4, which is assumed to be an int,
to a short, as shown in new Short((short)4). Option B is the correct answer since a byte value can be easily promoted to short and returned by the method.
 ****new Short(4).longValue(), here .longValue() convert Short object as a long primitive type.
35. C. Overloaded methods have the same name but a different list of parameters, making the first and third statements true. The second statement is false, since overloaded methods can
have the same or different return types. Therefore, Option C is the correct answer.

36. C. The declaration of monday does not compile, because the value of a static final variable must be set when it is declared or in a static initialization block. The declaration of
tuesday is fine and compiles without issue. The declaration of wednesday does not compile because there is no data type for the variable. Finally, the declaration of thursday does not
compile because the final modifier cannot appear before the access modifier. For these reasons, Option C is the correct answer.
37. D. The Puppy class does not declare a constructor, so the default no-argument constructor is automatically inserted by the compiler. What looks like a constructor in the class is actually
a method that has a return type of void. Therefore, the line in the main() method to create the new Puppy(2) object does not compile, since there is no constructor capable of
taking an int value, making Option D the correct answer.
38. A. The public modifier allows access to members in the same class, package, subclass, or even classes in other packages, while the private modifier allows access only to members
in the same class. Therefore, the public access modifier allows access to everything the private access modifier does, and more, making Option A the correct answer. Options B,
C, and D are incorrect because the first term is a more restrictive access modifier than the second term.
39. A. The code compiles without issue, so Option D is incorrect. The key here is that Java uses pass by value to send object references to methods. Since the Phone reference p was reassigned
in the first line of the sendHome() method, any changes to the p reference were made to a new object. In other words, no changes in the sendHome() method affected the object
that was passed in. Therefore, the value of size was the same before and after the method call, making the output 3 and Option A the correct answer.
40. B. Options A and D are equivalent and would allow the code to compile. They both are proper ways to access a static method from within an instance method. Option B is the
correct answer. The class would not compile because this.Drink has no meaning to the compiler. Finally, Option C would still allow the code to compile, even though it is considered
a poor coding practice. While static members should be accessed in a static way, it is not required.

41. C. The method signature requires one int value, followed by exactly one String, followed by String varargs, which can be an array of String values or zero or more individual
String values. Only Option C conforms to these requirements, making it the correct answer.
42. D. Option A is a statement about final static variables, not all static variables. Option B only applies to static variables marked private, not final. Option C is false
because static imports can be used to reference both variables and methods. Option D is the correct answer because a static variable is accessible to all instances of the class.
43. A. Option A is the correct answer because the first line of a constructor could be this() or super(), making it an untrue statement. Option B is a true statement because the compiler
will insert the default no-argument constructor if one is not defined. Option C is also a true statement, since zero or more arguments may be passed to the parent constructor, if the
parent class defines such constructors. Option D is also true. The value of a final instance variable should be set when it is declared, in an initialization block, or in a constructor.
44. D. The last static initialization block accesses height, which is an instance variable, not a static variable. Therefore, the code will not compile no matter how many final
modifiers are removed, making Option D the correct answer. Note that if the line height = 4; was removed, then no final modifiers would need to be removed to make
the class compile.
45. D. Since a constructor call is not the first line of the RainForest() constructor, the compiler inserts the no-argument super() call. Since the parent class, Forest, does not define
a no-argument super() constructor, the RainForest() constructor does not compile, and Option D is correct.

46. A. The code compiles without issue, so Option D is incorrect. In the main() method, the value 2 is first cast to a byte. It is then increased by one using the addition + operator.
The addition + operator automatically promotes all byte and short values to int. Therefore, the value passed to the choose() in the main() method is an int. The choose(int)
method is called, returning 5 and making Option A the correct answer. Note that without the addition operation in the main() method, byte would have been used as the parameter
to the choose() method, causing the choose(short) to be selected as the next closest type and outputting 2, making Option B the correct answer.
47. C. The variable startTime can be automatically converted to Integer by the compiler, but Integer is not a subclass of Long. Therefore, the code does not compile due the wrong variable
type being passed to the getScore() method on line m2, and Option C is correct.
48. A. Java methods must start with a letter, the dollar $ symbol, or underscore _ character. For these reasons, Options B and D are incorrect, and Option A is correct. Option C is
incorrect. The hashtag (#) symbol cannot be included in a method name.
49. B. The protected modifier allows access by any subclass or class that is in the same package, therefore Option B is the correct answer.
50. D. A static import is used to import static members of another class. In this case, the withdrawal() and deposit() methods in the Bank class are not marked static. They
require an instance of Bank to be used and cannot be imported as static methods. Therefore, Option D is correct. If the two methods in the Bank class were marked static, then
Option A would be the correct answer since wildcards can be used with static imports to import more than one method. Option B reverses the keywords static and import, while
Option C incorrectly imports a class, which cannot be imported via a static import.



============================================================================================================
                        # Chapter Summary: Java Class Design and Encapsulation
=============================================================================================================









-
