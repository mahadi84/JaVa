
### মেথড ওভাররাইডিং ও ওভারলোডিং (Method Overriding & Overloading)
* ওভাররাইডিংয়ের নিয়ম:** যখন একটি চাইল্ড ক্লাস প্যারেন্ট ক্লাসের কোনো মেথডকে নতুনভাবে সংজ্ঞায়িত করে, তাকে ওভাররাইডিং বলে। এখানে মনে রাখতে হবে:
    * প্যারেন্ট মেথড এবং চাইল্ড মেথডের নাম এবং প্যারামিটার তালিকা (signature) একই** হতে হবে।
    * চাইল্ড মেথডের অ্যাক্সেস মডিফায়ার প্যারেন্ট মেথডের চেয়ে সমান বা বেশি বিস্তৃত হতে পারে। উদাহরণস্বরূপ, যদি প্যারেন্ট মেথড `protected` হয়, তবে চাইল্ড মেথডটি `protected` বা `public` হতে পারে (প্রশ্ন ১ ও ৫)।
* ওভারলোডিং vs. ওভাররাইডিং:** যদি চাইল্ড ক্লাসে প্যারেন্ট মেথডের মতোই একটি মেথড থাকে, কিন্তু প্যারামিটার তালিকা ভিন্ন হয়, তবে সেটি ওভাররাইডিং নয়, বরং ওভারলোডিং। জাভা এটি দুটি ভিন্ন মেথড হিসেবে গণ্য করে (প্রশ্ন ১)।
* পলি morfism:** যখন একটি প্যারেন্ট টাইপের রেফারেন্স চাইল্ড ক্লাসের অবজেক্টকে নির্দেশ করে (যেমন `Animal cat = new Cat();`), তখন মেথড কল করলে প্রকৃত অবজেক্টের** মেথডটিই এক্সিকিউট হয়, যদি তা ওভাররাইড করা থাকে (প্রশ্ন ১ ও ২৮)।

### অ্যাক্সেস মডিফায়ার (Access Modifiers)
* ওভাররাইডিং এবং অ্যাক্সেস:** ওভাররাইড করার সময়, চাইল্ড মেথডের অ্যাক্সেস মডিফায়ার প্যারেন্ট মেথডের চেয়ে কম বিস্তৃত হতে পারে না। যদি প্যারেন্ট মেথড `protected` হয়, চাইল্ড মেথড `protected` বা `public` হতে পারে, কিন্তু ডিফল্ট (default) বা `private` হতে পারবে না (প্রশ্ন ২ ও ১৭)।
* ক্লাস এবং ইন্টারফেস:**
    * টপ-লেভেল ক্লাস শুধুমাত্র `public` বা ডিফল্ট অ্যাক্সেস মডিফায়ার ব্যবহার করতে পারে। `final` ক্লাসকে সাব-ক্লাস করা যায় না (প্রশ্ন ৩)।
    * টপ-লেভেল ইন্টারফেস শুধুমাত্র `public` বা ডিফল্ট হতে পারে (প্রশ্ন ৬)। ইন্টারফেসের মেথডগুলো স্বয়ংক্রিয়ভাবে `public` হয়ে যায়, তাই ইমপ্লিমেন্টিং ক্লাসকে অবশ্যই মেথডগুলোকে `public` হিসেবে ইমপ্লিমেন্ট করতে হবে (প্রশ্ন ৫)।

### কনস্ট্রাক্টর এবং ইনিশিয়ালাইজেশন (Constructors and Initialization)
* `super()` এর নিয়ম: চাইল্ড ক্লাসের কনস্ট্রাক্টর থেকে প্যারেন্ট ক্লাসের কনস্ট্রাক্টরকে কল করা বাধ্যতামূলক**। যদি আপনি নিজে থেকে কল না করেন, কম্পাইলার স্বয়ংক্রিয়ভাবে `super()` (প্যারেন্ট ক্লাসের নো-আর্গুমেন্ট কনস্ট্রাক্টর) যোগ করে দেবে।
* কনস্ট্রাক্টর ওভারলোডিং: একটি ক্লাসে একাধিক কনস্ট্রাক্টর থাকতে পারে। চাইল্ড ক্লাসের কনস্ট্রাক্টর থেকে প্যারেন্ট ক্লাসের নির্দিষ্ট কনস্ট্রাক্টরকে `super(arguments)` ব্যবহার করে কল করা যায় (প্রশ্ন ৭ ও ১১)।
* `this()` এবং `super()`: একটি কনস্ট্রাক্টরের মধ্যে `this()` এবং `super()` উভয়ই থাকতে পারে না। এদের যেকোনো একটিই প্রথম স্টেটমেন্ট হিসেবে থাকতে পারে, তবে কখনোই দুটি একসাথে নয় (প্রশ্ন ৮)।

### স্ট্যাটিক এবং ইনস্ট্যান্স মেম্বার (Static and Instance Members)
* স্ট্যাটিক মেথড: স্ট্যাটিক মেথডগুলো ওভাররাইড করা যায় না, শুধু লুকানো (hidden)** যায়। যখন আপনি একটি স্ট্যাটিক মেথড কল করেন, তখন কোন মেথডটি এক্সিকিউট হবে তা নির্ভর করে রেফারেন্স টাইপের উপর, অবজেক্টের প্রকৃত ধরনের উপর নয় (প্রশ্ন ২৪ ও ২৬)।
* স্ট্যাটিক মেথড এবং ওভাররাইডিং:** একটি ইনস্ট্যান্স মেথড কোনো স্ট্যাটিক মেথডকে ওভাররাইড করতে পারে না। এটি একটি কম্পাইলেশন এরর তৈরি করবে (প্রশ্ন ২৫)।
* স্ট্যাটিক মেম্বার অ্যাক্সেস:** ইন্টারফেসের স্ট্যাটিক ভেরিয়েবলগুলো সরাসরি ইন্টারফেসের নাম (`InterfaceName.variable`) অথবা একটি রেফারেন্সের মাধ্যমে (`object.variable`) অ্যাক্সেস করা যায়। তবে, ইন্টারফেসের স্ট্যাটিক মেথডগুলো শুধুমাত্র ইন্টারফেসের নাম দিয়েই কল করা যায়, কোনো অবজেক্টের রেফারেন্স দিয়ে নয় (প্রশ্ন ৩৩ ও ৩৪)।

### কাস্টিং এবং ব্যতিক্রম (Casting and Exceptions)
* কাস্টিংয়ের নিয়ম: একটি অবজেক্টকে শুধুমাত্র তার নিজস্ব টাইপ বা তার কোনো প্যারেন্ট টাইপে কাস্ট করা সম্ভব। 
               যদি আপনি একটি অবজেক্টকে তার সাথে সম্পর্কহীন (sibling) বা ভুল টাইপে কাস্ট করার চেষ্টা করেন, তাহলে `ClassCastException` নামক রানটাইম ব্যতিক্রম ঘটবে (প্রশ্ন ১৩ ও ১৪)।
* `instanceof` অপারেটর:** কাস্টিং করার আগে `instanceof` অপারেটর ব্যবহার করে নিশ্চিত হওয়া উচিত যে অবজেক্টটি কাস্ট করা সম্ভব কিনা।

### ভ্যারিয়েবল লুকানো (Variable Hiding)
* মেথড ওভাররাইডিংয়ের বিপরীতে, একটি চাইল্ড ক্লাসের ভ্যারিয়েবল প্যারেন্ট ক্লাসের একই নামের ভ্যারিয়েবলকে লুকিয়ে (hide)** রাখে।
* যখন একটি পলি morfism রেফারেন্স (যেমন `Currency c1 = new USDollar();`) ব্যবহার করে ভ্যারিয়েবল অ্যাক্সেস করা হয়,
  তখন কোন ভ্যারিয়েবলটি ব্যবহার হবে তা নির্ভর করে রেফারেন্সের ধরনের (reference type) উপর, অবজেক্টের প্রকৃত ধরনের উপর নয়। 
 `c1.notation` সবসময় `Currency` ক্লাসের ভ্যারিয়েবলটিই নির্দেশ করবে। 
 কিন্তু মেথড কল করলে (`c1.getNotation()`) অবজেক্টের প্রকৃত ধরনের উপর ভিত্তি করে `USDollar` ক্লাসের মেথডটি এক্সিকিউট হবে (প্রশ্ন ২০, ২১, ২২ ও ২৩)।


---------------


1.What will be the result of compiling and executing Circus class?
    //Circus.java
    package com.skillcertpro.oca;

    class Animal {
    protected void jump() {
    System.out.println(“Animal”);
    }
    }

    class Cat extends Animal {
    public void jump(int a) {
    System.out.println(“Cat”);
    }
    }

    class Deer extends Animal {
    public void jump() {
    System.out.println(“Deer”);
    }
    }

    public class Circus {
    public static void main(String[] args) {
    Animal cat = new Cat();
    Animal deer = new Deer();
    cat.jump();
    deer.jump();
    }
    }

    Animal Deer
    Cat Deer
    Animal Animal
    Cat Animal


 2.What will be the result of compiling and executing TestBaseDerived class?
    //TestBaseDerived.java
    package com.skillcertpro.oca;

    class Base {
    protected void m1() {
    System.out.println(“Base: m1()”);
    }
    }

    class Derived extends Base {
    void m1() {
    System.out.println(“Derived: m1()”);
    }
    }

    public class TestBaseDerived {
    public static void main(String[] args) {
    Base b = new Derived();
    b.m1();
    }
    }

3.Which one of these top level classes cannot be sub-classed?
    class Dog {} 
    abstract class Cat {} 
    final class Electronics {} 
    private class Car {}  //a top level class cannot be declared with private modifier.

4. What will be the result of compiling and executing Test class?
package com.skillcertpro.oca;

class Vehicle {
public int getRegistrationNumber() {
return 1;
}
}

class Car {
public int getRegistrationNumber() {
return 2;
}
}

public class Test {
public static void main(String[] args) {
Vehicle obj = new Car();
System.out.println(obj.getRegistrationNumber());
}
}

 1
 2
 An exception is thrown at runtime
 Compilation error(Answer).

5.For the given code:
package com.skillcertpro.oca;

interface I01 {
void m1();
}

public class Implementer extends Object implements I01 {
protected void m1() {

}
}
Which of the statement is true?
    interface I01 gives compilation error as method m1 is not public.
    Implementer class declaration is not correct.
    Method m1() in Implementer class is not implemented correctly.
    None of the other options.


Answer:
হ্যাঁ, public class Implementer extends Object implements I01 { এটি জাভাতে একটি সঠিক সিনট্যাক্স।
ব্যাখ্যা:
public class Implementer: এটি একটি পাবলিক ক্লাস ঘোষণার জন্য স্ট্যান্ডার্ড সিনট্যাক্স।
extends Object: জাভাতে, যদি একটি ক্লাস কোনো ক্লাসকে এক্সটেন্ড না করে, তবে এটি স্বয়ংক্রিয়ভাবে java.lang.Object ক্লাসকে এক্সটেন্ড করে। 
তাই, extends Object explicitly লেখাটি অতিরিক্ত (redundant) হলেও, এটি কোনো সিনট্যাক্স এরর নয়। কম্পাইলার এটিতে কোনো সমস্যা ধরবে না।
implements I01: এটি একটি ক্লাস ইন্টারফেস ইমপ্লিমেন্ট করার জন্য স্ট্যান্ডার্ড সিনট্যাক্স।


6. Which of these access modifiers can be used for a top level interface?
 private
 protected
 public
 All of the other options


7.What will be the result of compiling and executing Test class?
//Test.java
package com.skillcertpro.oca;

abstract class Animal {
private String name;

Animal(String name) {
this.name = name;
}

public String getName() {
return name;
}
}

class Dog extends Animal {
private String breed;

Dog(String breed) {
this.breed = breed;
}

Dog(String name, String breed) {
super(name);
this.breed = breed;
}

public String getBreed() {
return breed;
}
}

public class Test {
public static void main(String[] args) {
Dog dog1 = new Dog(“Beagle”);
Dog dog2 = new Dog(“Bubbly”, “Poodle”);
System.out.println(dog1.getName() + “:” + dog1.getBreed() + “:” +
dog2.getName() + “:” + dog2.getBreed());
}
}

 Compilation error for Animal Class
 Compilation error for Animal(String) constructor
 Compilation error for Dog(String) constructor
 Compilation error for Dog(String, String) constructor
 null:Beagle:Bubbly:Poodle
 :Beagle:Bubbly:Poodle



Answer:
অ্যাবস্ট্রাক্ট ক্লাসে কনস্ট্রাক্টর থাকতে পারে এবং অ্যাবস্ট্রাক্ট মেথড ছাড়াও অ্যাবস্ট্রাক্ট ক্লাস থাকা সম্ভব। তাই, `Animal` ক্লাস নিয়ে কোনো সমস্যা নেই।
যদি `this(...)` বা `super(...)` ব্যবহার করে অন্য কোনো কনস্ট্রাক্টরকে কল না করা হয়, তাহলে জাভা কম্পাইলার কনস্ট্রাক্টরের প্রথম স্টেটমেন্ট হিসেবে `super();` যোগ করে।
`Animal` ক্লাসের কনস্ট্রাক্টরের ভেতরে, কম্পাইলার `super();` যোগ করে => `Animal(String name) { super(); this.name = name; }`। এই ক্ষেত্রে `super()` `Object` ক্লাসের নো-আর্গ কনস্ট্রাক্টরকে ইনভোক করে, 
এবং তাই এখানে কোনো কম্পাইলেশন এরর নেই।

কম্পাইলার `Dog(String)` কনস্ট্রাক্টরকে পরিবর্তন করে: `Dog(String breed) { super(); this.breed = breed; }`। `Animal` ক্লাসে কোনো নো-আর্গ কনস্ট্রাক্টর উপলব্ধ নেই এবং যেহেতু অন্য একটি কনস্ট্রাক্টর প্রদান করা হয়েছে,
 জাভা কম্পাইলার ডিফল্ট কনস্ট্রাক্টর যোগ করে না। তাই `Dog(String)` কনস্ট্রাক্টর কম্পাইলেশন এরর দেয়।

`Dog(String, String)` কনস্ট্রাক্টর নিয়ে কোনো সমস্যা নেই।

08.What will be the result of compiling and executing Test class? 
//Test.java
package com.skillcertpro.oca;

class Parent {
int i = 10;
Parent(int i) {
super();
this.i = i;
}
}

class Child extends Parent {
int j = 20;

Child(int j) {
super(0);
this.j = j;
}

Child(int i, int j) {
super(i);
this(j);
}

}

public class Test {
public static void main(String[] args) {
Child child = new Child(1000, 2000);
System.out.println(child.i + “:” + child.j);
}
}

 Compilation error for Parent(int) constructor
 Compilation error for Child(int) constructor
 Compilation error for Child(int, int) Constructor
 Compilation error for Test class
 1033:20:00
 41.66666667


Ans:
Parent(int) কনস্ট্রাক্টরের ভেতরে থাকা super(); স্টেটমেন্টটি Object ক্লাসের নো-আর্গ কনস্ট্রাক্টরকে কল করে, তাই Parent(int) কনস্ট্রাক্টরের জন্য কোনো কম্পাইলেশন এরর হয় না।
Child(int) কনস্ট্রাক্টরের ভেতরে থাকা super(0); স্টেটমেন্টটি Parent(int) কনস্ট্রাক্টরকে কল করে, যা উপলব্ধ আছে এবং তাই এতে কোনো সমস্যা নেই।
Child(int, int) কনস্ট্রাক্টরের মধ্যে super(i) এবং this(j) উভয় স্টেটমেন্টই আছে। একটি কনস্ট্রাক্টরে super(...) অথবা this(...) এর মধ্যে যেকোনো একটি থাকতে পারে, কিন্তু উভয়ই একসাথে থাকতে পারে না। তাই Child(int, int) কনস্ট্রাক্টরের কারণে কম্পাইলেশন ফেইল হবে।
যেহেতু সমস্ত ক্লাস com.skillcertpro.oca.test প্যাকেজের অধীনে Test.java ফাইলে সংজ্ঞায়িত করা হয়েছে, তাই child.i এবং child.j কোনো কম্পাইলেশন এরর দেবে না। i এবং j প্যাকেজ স্কোপ সহ ঘোষণা করা হয়েছে।



9.Given code of LogHelper.java file:
package com.skillcertpro.oca;

abstract class Helper {
int num = 100;
String operation = null;

protected abstract void help();

void log() {
System.out.println(“Helper-log”);
}
}

public class LogHelper extends Helper {
private int num = 200;
protected String operation = “LOGGING”;

void help() {
System.out.println(“LogHelper-help”);
}

void log() {
System.out.println(“LogHelper-log”);
}

public static void main(String [] args) {
new LogHelper().help();
}
}

Which of the following changes, done independently, allows the code to compile and on execution prints LogHelper-help?
Select ALL that apply.

 Remove the private modifier from the num variable of LogHelper class
 Remove the protected modifier from the operation variable of LogHelper class
 Remove the protected modifier from the help() method of Helper class
 Add the protected modifier to the log() method of Helper class
 Add the protected modifier to the help() method of LogHelper class
 Add the public modifier to the help() method of LogHelper class



 Ans: 
ইনস্ট্যান্স ভ্যারিয়েবলগুলো সাবক্লাস দ্বারা **লুকানো (hidden)** হয়, **ওভাররাইড (overridden)** হয় না। তাই, ওভাররাইডিং নিয়মগুলো ইনস্ট্যান্স ভ্যারিয়েবলের জন্য প্রযোজ্য নয়। 'num' এবং 'operation' ভ্যারিয়েবল নিয়ে কোনো সমস্যা নেই।
`log()` মেথডটি উভয় ক্লাসেই **ডিফল্ট মডিফায়ার** সহ ঘোষণা করা হয়েছে, তাই `log()` মেথড নিয়েও কোনো সমস্যা নেই।
`Helper` ক্লাসে অ্যাবস্ট্রাক্ট মেথড `help()` **প্রোটেক্টেড মডিফায়ার** সহ ঘোষণা করা হয়েছে এবং `LogHelper` ক্লাসে এটি **ডিফল্ট মডিফায়ার** দ্বারা ওভাররাইড করা হয়েছে। এটি **কম্পাইলেশন এরর** সৃষ্টি করবে। এই সমস্যা সমাধানের জন্য নিচের সমাধানগুলো দেখতে পারেন:
1.  `Helper` ক্লাসের `help()` মেথড থেকে **প্রোটেক্টেড মডিফায়ারটি সরিয়ে দিন**: এতে ওভাররিডেন এবং ওভাররাইডিং উভয় মেথডেরই একই ডিফল্ট মডিফায়ার থাকবে, যা অনুমোদিত।
    অথবা
2.  `LogHelper` ক্লাসের `help()` মেথডে **প্রোটেক্টেড মডিফায়ার যোগ করুন**: এতে ওভাররিডেন এবং ওভাররাইডিং উভয় মেথডেরই একই প্রোটেক্টেড মডিফায়ার থাকবে, যা অনুমোদিত।
    অথবা
3.  `LogHelper` ক্লাসের `help()` মেথডে **পাবলিক মডিফায়ার যোগ করুন**: এতে ওভাররিডেন মেথডের প্রোটেক্টেড মডিফায়ার থাকবে এবং ওভাররাইডিং মেথডের পাবলিক মডিফায়ার থাকবে, যা অনুমোদিত।



 10.interface Printable {
public void setMargin();
public void setOrientation();
}

abstract class Paper implements Printable { //Line 7
public void setMargin() {}
//Line 9
}

class NewsPaper extends Paper { //Line 12
public void setMargin() {}
//Line 14
}
Above code is currently giving compilation error. Which 2 modifications, done independently, enable the code to compile?

 Replace the code at Line 7 with: class Paper implements Printable { 
 Insert at Line 9: public abstract void setOrientation(); 
 Replace the code at Line 12 with: abstract class NewsPaper extends Paper { 
 Insert at Line 14: public void setOrientation() {} 


 Ans: 
`NewsPaper` ক্লাসটি একটি **কনক্রিট ক্লাস** এবং এটি `Paper` ক্লাসকে (যা একটি অ্যাবস্ট্রাক্ট ক্লাস) এক্সটেন্ড করে। তাই `NewsPaper` ক্লাসকে অবশ্যই `setOrientation()` মেথডটি **ওভাররাইড** করতে হবে, অথবা এটিকে **অ্যাবস্ট্রাক্ট** ঘোষণা করতে হবে।
লাইন ৯-কে '`public abstract void setOrientation();`' দিয়ে প্রতিস্থাপন করা **অপ্রয়োজনীয়** এবং এটি `NewsPaper` ক্লাসের কম্পাইলেশন এরর সমাধান করবে না।
লাইন ৭-কে '`class Paper implements Printable {`' দিয়ে প্রতিস্থাপন করলে `Paper` ক্লাসের **কম্পাইলেশন ফেইল** হবে, কারণ এটি অ্যাবস্ট্রাক্ট মেথড '`setOrientation`' কে ইনহেরিট করে কিন্তু ইমপ্লিমেন্ট করে না।

11.class PenDrive {
int capacity;
PenDrive(int capacity) {
this.capacity = capacity;
}
}

class OTG extends PenDrive {
String type;
String make;
OTG(int capacity, String type) {
/*INSERT-1*/
}
OTG(String make) {
/*INSERT-2*/
this.make = make;
}
}

public class Test {
public static void main(String[] args) {
OTG obj = new OTG(128, “TYPE-C”);
System.out.println(obj.capacity + “:” + obj.type);
}
}
Currently above code causes compilation error.
Which of the options can successfully print 128:TYPE-C on to the console?

 Replace /*INSERT-1*/ with: super(capacity); Replace /*INSERT-2*/ with: super(128);
 Replace /*INSERT-1*/ with: super.capacity = capacity; this.type = type; Replace /*INSERT-2*/ with: super(128);
 Replace /*INSERT-1*/ with: super(capacity); this.type = type; Replace /*INSERT-2*/ with: super(0);
 Replace /*INSERT-1*/ with: this.type = type; super(capacity); Replace /*INSERT-2*/ with: super(128);
 None of the other options

 Ans:




 12.Consider codes below:
//A.java
package com.skillcertpro.oca;

public class A {
public int i1 = 1;
protected int i2 = 2;
}

//B.java
package com.skillcertpro.oca.test;
import com.skillcertpro.oca.A;

public class B extends A {
public void print() {
A obj = new A();
System.out.println(obj.i1); //Line 8
System.out.println(obj.i2); //Line 9
System.out.println(this.i2); //Line 10
System.out.println(super.i2); //Line 11
}

public static void main(String [] args) {
new B().print();
}
}
One of the statements inside print() method is causing compilation failure. 
Which of the below solutions will help to resolve compilation error?

 Comment the statement at Line 8
 Comment the statement at Line 9
 Comment the statement at Line 10
 Comment the statement at Line 11



Ans:
`A` ক্লাসটি **পাবলিক** হিসেবে ঘোষণা করা হয়েছে এবং `com.skillcertpro.oca` প্যাকেজে সংজ্ঞায়িত। তাই `com.skillcertpro.oca` প্যাকেজের বাইরে থেকে `A` ক্লাস অ্যাক্সেস করতে কোনো সমস্যা নেই।
`B` ক্লাসটি `com.skillcertpro.oca.test` প্যাকেজে সংজ্ঞায়িত। `A` ক্লাস থেকে এক্সটেন্ড করার জন্য হয় `import com.skillcertpro.oca.A;` স্টেটমেন্টটি ব্যবহার করতে হবে অথবা ক্লাসটির সম্পূর্ণ যোগ্য নাম `com.skillcertpro.oca.A` ব্যবহার করতে হবে। এই ক্লাস সংজ্ঞা নিয়েও কোনো সমস্যা নেই।
ভ্যারিয়েবল `i1` ক্লাস `A`-তে **পাবলিক** হিসেবে ঘোষণা করা হয়েছে, তাই লাইন ৮ কোনো কম্পাইলেশন এরর সৃষ্টি করবে না। ভ্যারিয়েবল `i2` **প্রোটেক্টেড** হিসেবে ঘোষণা করা হয়েছে, তাই এটি শুধুমাত্র ইনহেরিটেন্স ব্যবহার করে সাবক্লাসের মাধ্যমে অ্যাক্সেস করা যেতে পারে, কিন্তু অবজেক্ট রেফারেন্স ভ্যারিয়েবল ব্যবহার করে নয়। `obj.i2` এর কারণে কম্পাইলেশন ফেইল হবে।
`B` ক্লাস `A` ক্লাস থেকে ভ্যারিয়েবল `i2` ইনহেরিট করে, তাই `B` ক্লাসের ভেতরে এটিকে `this` অথবা `super` ব্যবহার করে অ্যাক্সেস করা যেতে পারে। লাইন ১০ এবং লাইন ১১ কোনো কম্পাইলেশন এরর সৃষ্টি করবে না।


13.Consider codes below:
//A.java
package com.skillcertpro.oca;

public class A {
public void print() {
System.out.println(“A”);
}
}

//B.java
package com.skillcertpro.oca;

public class B extends A {
public void print() {
System.out.println(“B”);
}
}

//C.java
package com.skillcertpro.oca;

public class C extends A {
public void print() {
System.out.println(“C”);
}
}

//Test.java
package com.skillcertpro.oca.test;

import com.skillcertpro.oca.*;

public class Test {
public static void main(String[] args) {
A obj1 = new C();
A obj2 = new B();
C obj3 = (C)obj1;
C obj4 = (C)obj2;
obj3.print();
}
}
What will be the result of compiling and executing Test class?

 A
 B
 C
 Compilation error
 ClassCastException is thrown at runtime


Answer:
Incorrect
Class A, B and C are declared public and inside same package com.skillcertpro.oca. Method print() of class A has correctly been overridden by B and C.
print() method is public so no issues in accessing it anywhere.

Let’s check the code inside main method.
A obj1 = new C(); => obj1 refers to an instance of C class, it is polymorphism. 
A obj2 = new B(); => obj2 refers to an instance of B class, it is polymorphism. 
C obj3 = (C)obj1; => obj1 actually refers to an instance of C class, so at runtime obj3 (C type) will refer to an instance of C class. As obj1 is of A type so explicit typecasting is necessary. 
C obj4 = (C)obj2; => obj2 actually refers to an instance of B class, so at runtime obj4 (C type) will refer to an instance of B class. B and C are siblings and can’t refer to each other, so this statement will throw ClassCastException at runtime.

14.Consider codes below:
//A.java
package com.skillcertpro.oca;

public class A {
public void print() {
System.out.println(“A”);
}
}

//B.java
package com.skillcertpro.oca;

public class B extends A {
public void print() {
System.out.println(“B”);
}
}

//Test.java
package com.skillcertpro.oca.test;

import com.skillcertpro.oca.*;

public class Test {
public static void main(String[] args) {
A obj1 = new A();
B obj2 = (B)obj1;
obj2.print();
}
}
What will be the result of compiling and executing Test class?

 A
 B
 Compilation error
 ClassCastException is thrown at runtime

 Answer:
 A obj1 = new A(); => obj1 ক্লাস A-এর একটি ইনস্ট্যান্সকে নির্দেশ করে।
 B obj2 = (B)obj1; => obj1 হচ্ছে A টাইপের এবং এটিকে obj2 (যা B টাইপের) তে অ্যাসাইন করা হচ্ছে, তাই এক্সপ্লিসিট কাস্টিং (explicit casting) প্রয়োজন। obj1 ক্লাস A-এর একটি ইনস্ট্যান্সকে নির্দেশ করে, তাই রানটাইমে obj2-ও ক্লাস A-এর একটি ইনস্ট্যান্সকে নির্দেশ করবে। সাবটাইপ সুপারটাইপের একটি অবজেক্টকে নির্দেশ করতে পারে না। অতএব, রানটাইমে B obj2 = (B)obj1; লাইনটি একটি ClassCastException থ্রো করবে।

 15. Consider below code of Test.java file:
package com.skillcertprokhattry.oca;

class Super {
void Super() {
System.out.print(“KEEP_”);
}
}

class Base extends Super {
Base() {
Super();
System.out.print(“GOING_”);
}
}

public class Test {
public static void main(String[] args) {
new Base();
}
}

What will be the result of compiling and executing above code?

 Compilation Error in Super class
 Compilation Error in Base class
 Compilation Error in Test class
 It prints KEEP_GOING_ on to the console
 It prints GOING_KEEP_ on to the console

 Answer:
এই কোডটি সফলভাবে কম্পাইল হবে এবং রান করার পর কনসোলে KEEP_GOING_ প্রিন্ট করবে।


 16.Consider below codes of 3 java files:
//Animal.java
package a;

public class Animal {
Animal() {
System.out.print(“ANIMAL-“);
}
}

//Dog.java
package d;

import a.Animal;

public class Dog extends Animal {
public Dog() {
System.out.print(“DOG”);
}
}

//Test.java
package com.skillcertprokhattry.oca;

import d.Dog;

public class Test {
public static void main(String[] args) {
new Dog();
}
}

What will be the result of compiling and executing Test class?

 Compilation error in Animal.java file
 Compilation error in Dog.java file
 Compilation error in Test.java file
 It executes successfully and prints ANIMAL-DOG on to the console
 It executes successfully and prints DOG on to the console
 It executes successfully but nothing is printed on to the console


 17.Consider below code fragment:
package com.skillcertprokhattry.oca;

abstract class Food {
protected abstract double getCalories();
}

class JunkFood extends Food {
double getCalories() {
return 200.0;
}
}

Which 3 modifications, done independently, enable the code to compile?

 Make the getCalories() method of Food class public
 Remove the protected access modifier from the getCalories() method of Food class
 Make the getCalories() method of Food class private
 Make the getCalories() method of JunkFood class protected
 Make the getCalories() method of JunkFood class public
 Make the getCalories() method of JunkFood class private

 Ans:
 2,4,5


 18.Consider below code of Test.java file:
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
P p = new R(); //Line n1
System.out.println(p.compute(“Go”)); //Line n2
}
}

class P {
String compute(String str) {
return str + str + str;
}
}

class Q extends P {
String compute(String str) {
return super.compute(str.toLowerCase());
}
}

class R extends Q {
String compute(String str) {
return super.compute(str.replace(‘o’, ‘O’)); //2nd argument is uppercase O
}
}

What will be the result of compiling and executing Test class?

 gOgOgO
 gogogo
 GoGoGo
 GOGOGO
 Go
 GO


 19.Given code of Test.java file:
package com.skillcertprokhattry.oca;

class X {
void A() {
System.out.print(“A”);
}
}

class Y extends X {
void A() {
System.out.print(“A-“);
}

void B() {
System.out.print(“B-“);
}

void C() {
System.out.print(“C-“);
}
}

public class Test {
public static void main(String[] args) {
X obj = new Y(); //Line n1
obj.A(); //Line n2
obj.B(); //Line n3
obj.C(); //Line n4
}
}

What will be the result of compiling and executing above code?

 A-B-C-
 AB-C-
 Compilation error in class Y
 Compilation error in class Test


Ans:
Class Y correctly extends class X and it overrides method A() and provides two new methods B() and C().
At Line n1, obj is of X type and therefore obj.B(); and obj.C(); cause compilation error as these methods are not defined in class X.


20. Consider below code of Test.java file:
package com.skillcertprokhattry.oca;

class Currency {
String notation = “-“; //Line n1

String getNotation() { //Line n2
return notation;
}
}

class USDollar extends Currency {
String notation = “$”; //Line n3

String getNotation() { //Line n4
return notation;
}
}

class Euro extends Currency {
protected String notation = “€”; //Line n5

protected String getNotation() { //Line n6
return notation;
}
}

public class Test {
public static void main(String[] args) {
Currency c1 = new USDollar();
System.out.println(c1.notation + “:” + c1.getNotation());

Currency c2 = new Euro();
System.out.println(c2.notation + “:” + c2.getNotation());
}
}

What will be the result of compiling and executing above code?

 -:$ -:€
 -:- -:-
 $:$ €:€
 Compilation error in USDollar class
 Compilation error in Euro class


 21.Consider below code of Test.java file:
package com.skillcertprokhattry.oca;

class Super {
public String num = “10”; //Line n1
}

class Sub extends Super {
protected int num = 20; //Line n2
}

public class Test {
public static void main(String[] args) {
Super obj = new Sub();
System.out.println(obj.num += 2); //Line n3
}
}

What will be the result of compiling and executing above code?

 Compilation error at Line n2
 Compilation error at Line n3
 It executes successfully and prints 12 on to the console
 It executes successfully and prints 22 on to the console
 It executes successfully and prints 102 on to the console
 It executes successfully and prints 202 on to the console



 Ans:
 obj’ is of Super type, hence obj.num refers to num variable at Line n1, which is of String type.
Expression at Line n3:
obj.num += 2
=> obj.num = obj.num + 2
=> obj.num = “10” + 2
=> obj.num = “102”
obj.num refers to “102” and same is printed on to the console.


22.Given code of Test.java file:
package com.skillcertprokhattry.oca;

class Parent {
int var = 1000; // Line n1

int getVar() {
return var;
}
}

class Child extends Parent {
private int var = 2000; // Line n2

int getVar() {
return super.var; //Line n3
}
}

public class Test {
public static void main(String[] args) {
Child obj = new Child(); // Line n4
System.out.println(obj.var); // Line n5
}
}

There is a compilation error in the code.
Which three modifications, done independently, print 1000 on to the console?

 Change Line n1 to private int var = 1000;
 Delete the Line n2
 Change Line n3 to return var;
 Change Line n4 to Parent obj = new Child();
 Delete the method getVar() from the Child class
 Change Line n5 to System.out.println(obj.getVar());





 23.class Base {
String msg = “INHALE”; //Line n1
}

class Derived extends Base {
Object msg = “EXHALE”; //Line n2
}

public class Test {
public static void main(String[] args) {
Base obj1 = new Base(); //Line n3
Base obj2 = new Derived(); //Line n4
Derived obj3 = (Derived) obj2; //Line n5
String text = obj1.msg + “-” + obj2.msg + “-” + obj3.msg; //Line n6
System.out.println(text); //Line n7
}
}

What will be the result of compiling and executing above code?

 Line n2 causes compilation error
 Line n5 throws Exception at runtime
 Line n6 causes compilation error
 It executes successfully and prints INHALE-EXHALE-EXHALE
 It executes successfully and prints INHALE-INHALE-EXHALE
 It executes successfully and prints INHALE-INHALE-INHALE




 24.class Base {
static void print() { //Line n1
System.out.println(“BASE”);
}
}

class Derived extends Base {
static void print() { //Line n2
System.out.println(“DERIVED”);
}
}

public class Test {
public static void main(String[] args) {
Base b = null;
Derived d = (Derived) b; //Line n3
d.print(); //Line n4
}
}

Which of the following statements is true for above code?

 Line n2 causes compilation error
 Line n3 causes compilation error
 Line n4 causes compilation error
 Code compiles successfully and on execution Line n3 throws an exception
 Code compiles successfully and on execution prints BASE on to the console
 Code compiles successfully and on execution prints DERIVED on to the console




 25.lass Paper {
static String getType() { //Line n1
return “GENERIC”;
}
}

class RuledPaper extends Paper {
String getType() { //Line n2
return “RULED”;
}
}

public class Test {
public static void main(String[] args) {
Paper paper = new RuledPaper(); //Line n3
System.out.println(paper.getType()); //Line n4
}
}

Which of the following statements is true for above code?

 Compilation error in RuledPaper class
 Compilation error in Test class
 Code compiles successfully and on execution prints GENERIC on to the console
 Code compiles successfully and on execution prints RULED on to the console


 Ans:
 Instance method of subclass cannot override the static method of superclass.
Instance method at Line n2 tries to override the static method at Line n1 and hence Line n2 causes compilation error.


 26.class M {
public void main(String[] args) { //Line n1
System.out.println(“M”);
}
}

class N extends M {
public static void main(String[] args) { //Line n2
new M().main(args); //Line n3
}
}

public class Test {
public static void main(String[] args) {
N.main(args); //Line n4
}
}

Which of the following statements is true for above code?

 Line n1 causes compilation error
 Line n2 causes compilation error
 Line n3 causes compilation error
 Line n4 causes compilation error
 It executes successfully and prints M on to the console

Ans:
The static method of subclass cannot hide the instance method of superclass. static main(String []) method at Line n2 tries to hide the instance main(String []) method at Line n1 and hence Line n2 causes compilation error.

 27.class Parent {
String quote = “MONEY DOESN’T GROW ON TREES”;
}

class Child extends Parent {
String quote = “LIVE LIFE KING SIZE”;
}

class GrandChild extends Child {
String quote = “PLAY PLAY PLAY”;
}

public class Test {
public static void main(String[] args) {
GrandChild gc = new GrandChild();
System.out.println(/*INSERT*/);
}
}
Which of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print MONEY DOESN’T GROW ON TREES on to the console?
Select ALL that apply.

 gc.quote
 (Parent)gc.quote
 ((Parent)gc).quote
 ((Parent)(Child)gc).quote
 (Parent)(Child)gc.quote

 Ans:
 (Parent)gc.quote => gc.quote will be evaluated first as dot (.) operator has higher precedence than cast. gc.quote refers to String, hence it cannot be casted to Parent type. This would cause compilation error.
((Parent)gc).quote => Variable ‘gc’ is casted to Parent type, so this expression refers to “MONEY DOESN’T GROW ON TREES”. It is one of the correct options.
((Parent)(Child)gc).quote => ‘gc’ is of GrandChild type, it is first casted to Child and then to Parent type and finally quote variable is accessed, so this expression refers to “MONEY DOESN’T GROW ON TREES”. It is also one of the correct options.
(Parent)(Child)gc.quote => gc.quote will be evaluated first as dot (.) operator has higher precedence than cast. gc.quote refers to String, hence it cannot be casted to Child type. This would cause compilation error.

 28.class X {
void greet() {
System.out.println(“Good Morning!”);
}
}

class Y extends X {
void greet() {
System.out.println(“Good Afternoon!”);
}
}

class Z extends Y {
void greet() {
System.out.println(“Good Night!”);
}
}

public class Test {
public static void main(String[] args) {
X x = new Z();
x.greet(); //Line n1
((Y)x).greet(); //Line n2
((Z)x).greet(); //Line n3
}
}

What will be the result of compiling and executing above code?

 Compilation error
 An exception is thrown at runtime
 It compiles successfully and on execution prints below: Good Night! Good Afternoon! Good Morning
 It compiles successfully and on execution prints below: Good Night! Good Night! Good Night!
 It compiles successfully and on execution prints below: Good Morning! Good Morning! Good Morning!

 29.Given code of Test.java file:
package com.skillcertprokhattry.oca;

class Lock {
public void open() {
System.out.println(“LOCK-OPEN”);
}
}

class Padlock extends Lock {
public void open() {
System.out.println(“PADLOCK-OPEN”);
}
}

class DigitalPadlock extends Padlock {
public void open() {
/*INSERT*/
}
}

public class Test {
public static void main(String[] args) {
Lock lock = new DigitalPadlock();
lock.open();
}
}

Which of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print LOCK-OPEN on to the console?

 super.open();
 super.super.open();
 ((Lock)super).open();
 (Lock)super.open();
 None of the other options



Ans:
super.open(); => Using super keyword, you can access methods and variables of immediate parent class, hence if you replace /*INSERT*/ with `super.open();`, then open() method of Padlock class will be invoked.
super.super.open(); => super.super is not allowed in java, it causes compilation error.
((Lock)super).open(); => Not possible to cast super keyword in java, it causes compilation error.
(Lock)super.open(); => super.open(); will be evaluated first as dot (.) operator has higher precedence than cast. super.open(); returns void and hence it cannot be casted to Lock. It also causes compilation error.
In fact, it is not possible to directly reach to 2 levels, super keyword allows to access methods and variables of immediate parent class only (just 1 level up). Hence, correct answer is: ‘None of the other options’

 30.
//Chair.java
package com.skillcertprokhattry.oca;

public class Chair implements Sellable {
public double getPrice() {
return 35;
}

public String symbol() {
return “£”;
}
}

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
Sellable obj = new Chair(); //Line n1
System.out.println(obj.symbol() + obj.getPrice()); //Line n2
}
}

What will be the result of compiling and executing Test class?

 Compilation error in Chair class
 Compilation error in Test class
 It compiles successfully and on execution prints $35 on to the console
 It compiles successfully and on execution prints $35.0 on to the console
 It compiles successfully and on execution prints $35.00 on to the console
 It compiles successfully and on execution prints £35.0 on to the console

31.//I1.java
package com.skillcertprokhattry.oca;

public interface I1 {
int i = 10;
}

//I2.java
package com.skillcertprokhattry.oca;

public interface I2 {
int i = 20;
}

//I3.java
package com.skillcertprokhattry.oca;

public interface I3 extends I1, I2 { //Line n1

}

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
System.out.println(I1.i); //Line n2
System.out.println(I2.i); //Line n3
System.out.println(I3.i); //Line n4
}
}

Which of the following statements is correct?

 Line n1 causes compilation error
 Line n2 causes compilation error
 Line n3 causes compilation error
 Line n4 causes compilation error
 There is no compilation error


Ans:
Variable ‘i’ declared inside interface I1 is implicitly public, static and final and similarly variable i declared inside interface I2 is implicitly public, static and final as well.
In Java a class can extend from only one class but an interface can extend from multiple interfaces. static variables are not inherited and hence there is no issue with Line n1.

I1.i points to variable ‘i’ of interface I1.
I2.i points to variable ‘i’ of interface I2.
I3.i is an ambiguous call as compiler is not sure whether to point to I1.i or I2.i and therefore, Line n4 causes compilation error.


32.Consider below codes of 2 java files:
//Counter.java
package com.skillcertprokhattry.oca;

public interface Counter {
int count = 10; //Line n1
}

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
Counter [] arr = new Counter[2]; //Line n2
for(Counter ctr : arr) {
System.out.print(ctr.count); //Line n3
}
}
}

Which of the following statements is correct?

 Only Line n1 causes compilation error
 Only Line n2 causes compilation error
 Line n1 and Line n2 cause compilation error
 Only Line n3 causes compilation error
 Line n3 throws an exception at runtime
 Test class compiles successfully and on execution prints 1010 on to the console


Ans:
Line n2: Counter [] arr = new Counter[2]; - এটি Counter ইন্টারফেস টাইপের একটি অ্যারে তৈরি করছে। যদিও আপনি ইন্টারফেসের কোনো অবজেক্ট তৈরি করতে পারেন না, কিন্তু ইন্টারফেস টাইপের একটি অ্যারে তৈরি করা সম্ভব। এই অ্যারের প্রতিটি উপাদান ডিফল্টভাবে null দ্বারা ইনিশিয়্যালাইজড হবে। এটিও একটি বৈধ স্টেটমেন্ট।
সুতরাং, কোডটি সফলভাবে কম্পাইল হবে এবং আউটপুট হবে 1010।

33.Consider below codes of 3 java files:
//Shrinkable.java
package com.skillcertprokhattry.oca;

public interface Shrinkable {
public static void shrinkPercentage() {
System.out.println(“80%”);
}
}

//AntMan.java
package com.skillcertprokhattry.oca;

public class AntMan implements Shrinkable { }

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
AntMan.shrinkPercentage();
}
}

Which of the following statements is correct?

 There is a compilation error in Shrinkable.java file
 There is a compilation error in AntMan.java file
 There is a compilation error in Test.java file
 There is no compilation error and on execution, Test class prints 80% on to the console
Incorrect
As per Java 8, default and static methods were added in the interface. There is no issue in Shrinkable.java file.
class AntMan implements Shrinkable interface but as there is no abstract method in Shrinkable interface, hence AntMan class is not needed to implement any method. AntMan.java file compiles successfully.
static method of Shrinkable interface can only be accessed by using Shrinkable.shrinkPercentage(). `AntMan.shrinkPercentage();` causes compilation error.


34.//Buyable.java
package com.skillcertprokhattry.oca;

public interface Buyable {
int salePercentage = 85;

public static String salePercentage() {
return salePercentage + “%”;
}
}

//Book.java
package com.skillcertprokhattry.oca;

public class Book implements Buyable {}

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
Buyable [] arr = new Buyable[2];
for(Buyable b : arr) {
System.out.println(b.salePercentage); //Line n1
System.out.println(b.salePercentage()); //Line n2
}

Book [] books = new Book[2];
for(Book b : books) {
System.out.println(b.salePercentage); //Line n3
System.out.println(b.salePercentage()); //Line n4
}
}
}

Which of the following statements are correct?
Select ALL that apply.

 There is a compilation error in Buyable.java file
 There is a compilation error in Book.java file
 There is a compilation error at Line n1
 There is a compilation error at Line n2
 There is a compilation error at Line n3
 There is a compilation error at Line n4



 35.//Buyable.java
package com.skillcertprokhattry.oca;

public interface Buyable {
int salePercentage = 85;

public static String salePercentage() {
return salePercentage + “%”;
}
}

//Book.java
package com.skillcertprokhattry.oca;

public class Book implements Buyable {}

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
Buyable [] arr = new Buyable[2];
for(Buyable b : arr) {
System.out.println(b.salePercentage); //Line n1
System.out.println(b.salePercentage()); //Line n2
}

Book [] books = new Book[2];
for(Book b : books) {
System.out.println(b.salePercentage); //Line n3
System.out.println(b.salePercentage()); //Line n4
}
}
}

Which of the following statements are correct?
Select ALL that apply.

 There is a compilation error in Buyable.java file
 There is a compilation error in Book.java file
 There is a compilation error at Line n1
 There is a compilation error at Line n2
 There is a compilation error at Line n3
 There is a compilation error at Line n4

 Ans:
 Super type reference variable can refer to an instance of Sub type, therefore the statement `I1 obj = new C1();` compiles successfully.
obj is of I1 type, hence `obj.print(“Java”);` tries to tag the static method of I1 but static print(String) method of I1 can only be invoked by using I1.print(“Java”);.
Therefore, `obj.print(“Java”);` causes compilation error.


 36.//Profitable1.java
package com.skillcertprokhattry.oca;

public interface Profitable1 {
default double profit() {
return 12.5;
}
}

//Profitable2.java
package com.skillcertprokhattry.oca;

public interface Profitable2 {
default double profit() {
return 25.5;
}
}

//Profit.java
package com.skillcertprokhattry.oca;

public abstract class Profit implements Profitable1, Profitable2 {
/*INSERT*/
}

Which of the following needs to be done so that there is no compilation error?

 No need for any modifications, code compiles as is
 Replace /*INSERT*/ with below code: double profit() {     return 50.0; }
 Replace /*INSERT*/ with below code: public default double profit() {     return 50.0; }
 Replace /*INSERT*/ with below code: protected double profit() {     return 50.0; }
 Replace /*INSERT*/ with below code: public double profit() {     return Profitable1.profit(); }
 Replace /*INSERT*/ with below code: public double profit() {     return Profitable2.super.profit(); }

 Ans:
 Replace /*INSERT*/ with below code:
public double profit() {
    return Profitable2.super.profit();
}

 37.interface Perishable1 {
default int maxDays() {
return 1;
}
}

interface Perishable2 extends Perishable1 {
default int maxDays() {
return 2;
}
}

class Milk implements Perishable2, Perishable1 {}

public class Test {
public static void main(String[] args) {
Perishable1 obj = new Milk();
System.out.println(obj.maxDays());
}
}

Which of the following statements is correct?

 Interface Perishable2 causes compilation error
 Class Milk causes compilation error
 Class Test causes compilation error
 Given code compiles successfully and on execution Test class prints 1 on to the console
 Given code compiles successfully and on execution Test class prints 2 on to the console
 
 Ans:
 Method maxDays() is implicitly public in Perishable1.
interface Perishable2 extends Perishable1 and it overrides the default method maxDays() of Document, overriding method in Perishable2 is implicitly public. Interface Perishable2 compiles successfully.
 

 38.interface M {
public static void log() {
System.out.println(“M”);
}
}

abstract class A {
public static void log() {
System.out.println(“N”);
}
}

class MyClass extends A implements M {}

public class Test {
public static void main(String[] args) {
M obj1 = new MyClass();
obj1.log(); //Line n1

A obj2 = new MyClass();
obj2.log(); //Line n2

MyClass obj3 = new MyClass();
obj3.log(); //Line n3
}
}

Which of the following statements is correct?

 There is a compilation error in interface M
 There is a compilation error in class A
 Line n1 causes compilation error
 Line n2 causes compilation error
 Line n3 causes compilation error
 Given code compiles successfully

 Ans:
 obj1 is of M type, hence `obj1.log();` tries to tag the static method of M but static log() method of M can only be invoked by using M.log();.
Therefore, Line n1 causes compilation error.



 39.Consider below code snippet:
interface ILog {
default void log() {
System.out.println(“ILog”);
}
}

abstract class Log {
public static void log() {
System.out.println(“Log”);
}
}

class MyLogger extends Log implements ILog {}

Which of the following statements is correct?

 There is no compilation error in the above code
 There is a compilation error in interface ILog
 There is a compilation error in abstract class Log


Ans:
MyLogger class has instance method log() [inherited from ILog interface] and static method log() [from Log class] and this causes conflict. Static and non-static methods with same signature are not allowed in one scope, therefore class MyLogger fails to compile.




