


#### 1. পলিমরফিজম এবং মেথড ওভাররাইডিং (Polymorphism & Method Overriding)
  -Animal cat = new Cat();`  পলিমরফিজম ।
  -স্ট্যাটিক মেথড ওভাররাইড হয় না, হাইড হয় ।
  -public class abc extends Object  {//Ok. every class we create extends Object

#### 2. ক্লাস এবং ইন্টারফেসের মডিফায়ার (Class & Interface Modifiers)
-একটি abstract ক্লাস যখন একটি ইন্টারফেস ইমপ্লিমেন্ট করে, তখন তাকে হয় ইন্টারফেসের সবগুলো মেথড ইমপ্লিমেন্ট করতে হবে, 
     অথবা যে মেথডগুলো ইমপ্লিমেন্ট করা হয়নি সেগুলোকে abstract হিসেবে ঘোষণা করতে হবে। এই নিয়ম লঙ্ঘনের কারণে কম্পাইলার একটি এরর দেবে।
  
    - `final` ক্লাস সাবক্লাস করা যায় না। 
    - টপ-লেভেল Class/Interface-এ,  private এবং protected বৈধ নয়। শুধুমাত্র `public` বা `default` (package-private) হতে পারে।
          **জাভাতে টপ-লেভেল Class/Interface হলো এমন একটি Class/Interface যা অন্য কোনো ক্লাস বা ইন্টারফেসের ভেতরে নেস্ট করা (nested) থাকে না। সহজভাবে বলতে গেলে, এটি একটি .java ফাইলে সরাসরি ঘোষিত একটি ইন্টারফেস।
    
    - `abstract` ক্লাস ইনস্ট্যান্টিয়েট (new) করা যায় না, কিন্তু কনস্ট্রাক্টর থাকতে পারে।
     - `interface` ইনস্ট্যান্টিয়েট (new) করা যায় না, কনস্ট্রাক্টর থাকতে পারে না।
     - ইন্টারফেসের ভেরিয়েবল ডিফল্টভাবে `public static final`।

#### 3. ইনহেরিটেন্স এবং কনস্ট্রাক্টর (Inheritance & Constructors)
   - একটি কনস্ট্রাক্টরে `super()` এবং `this()` একসাথে থাকতে পারে না।
     - সাবক্লাস কনস্ট্রাক্টরে প্রথম লাইন হতে হবে `super()` বা `this()` (যদি থাকে)।
     - যদি সুপারক্লাসে নো-আর্গ কনস্ট্রাক্টর না থাকে, তবে সাবক্লাস কনস্ট্রাক্টরে `super(args)` কল করতে হবে।

#### 4. ইন্টারফেসের ডিফল্ট এবং স্ট্যাটিক মেথড (Default & Static Methods in Interfaces)
   - একাধিক ইন্টারফেসে একই ডিফল্ট মেথড থাকলে ক্লাসে ওভাররাইড করতে হবে (e.g., `Profitable1.super.profit()`)।
   - ইন্টারফেসের Static মেথড শুধুমাত্র `InterfaceName.method()` দিয়ে কল করা যায়, `obj.method()` দিয়ে নয়।
     - Abstract মেথড বডি থাকে না, Defult মেথড ইন্টারফেসে বডি সহ থাকে, স্ট্যাটিক মেথড ওভাররাইড করা যায় না।
     - `default` মেথড `Object` ক্লাসের মেথড (যেমন `toString`) ওভাররাইড করতে পারে না।

#### 5. ভেরিয়েবল হাইডিং (Variable Hiding)
   - প্যারেন্ট এবং চাইল্ড ক্লাসে একই নামের ভেরিয়েবল থাকলে রেফারেন্স টাইপ অনুযায়ী ভেরিয়েবল অ্যাক্সেস হয় (হাইডিং)।
     - ভেরিয়েবল ওভাররাইড হয় না, হাইড হয়। `super` কিওয়ার্ড দিয়ে প্যারেন্টের ভেরিয়েবল অ্যাক্সেস করা যায়।
     - `Parent obj = new Child();` হলে `obj.var` প্যারেন্টের ভেরিয়েবল দেখাবে।

#### 6. টাইপ কাস্টিং এবং `ClassCastException`
   - `(Child)parentObj` টাইপ কাস্টিং করতে গিয়ে রানটাইমে `ClassCastException` হতে পারে যদি অবজেক্ট টাইপ মেলে না।
     - `instanceof` দিয়ে টাইপ চেক করে কাস্টিং করা নিরাপদ।
     - সিবলিং ক্লাস (যেমন `Dog` এবং `Cat`) একে অপরের সাথে কাস্ট করা যায় না।

#### 7. অ্যাবস্ট্রাক্ট ক্লাস এবং মেথড (Abstract Classes & Methods)
   - অ্যাবস্ট্রাক্ট মেথডের অ্যাক্সেস মডিফায়ার `protected` থেকে `public` বা `protected` করা যেতে পারে, কিন্তু কম রেস্ট্রিক্টিভ নয়।



---------------


1.What will be the result of compiling and executing Test class?
Test.java
com.skillcertpro.oca.test

abstract class Animal {
private String name;

Animal(String name) {
this.name = name;
}

public String getName() {
return name;
}
}

class Dog extends Animal {
private String breed;

Dog(String breed) {
this.breed = breed;
}

Dog(String name, String breed) {
super(name);
this.breed = breed;
}

public String getBreed() {
return breed;
}
}


public class Test {
public static void main(String[] args) {
Dog dog1 = new Dog("Beagle");
Dog dog2 = new Dog("Bubbly", "Poodle");
System.out.println(dog1.getName() + ":" + dog1.getBreed() + ":" +
dog2.getName() + ":" + dog2.getBreed());
}
}

 Compilation error for Animal Class
 Compilation error for Animal(String) constructor
 Compilation error for Dog(String) constructor
 Compilation error for Dog(String, String) constructor
 null:Beagle:Bubbly:Poodle
 :Beagle:Bubbly:Poodle














Answer:
অ্যাবস্ট্রাক্ট ক্লাসে কনস্ট্রাক্টর থাকতে পারে এবং অ্যাবস্ট্রাক্ট মেথড ছাড়াও অ্যাবস্ট্রাক্ট ক্লাস থাকা সম্ভব। তাই, `Animal` ক্লাস নিয়ে কোনো সমস্যা নেই।
যদি `this(...)` বা `super(...)` ব্যবহার করে অন্য কোনো কনস্ট্রাক্টরকে কল না করা হয়, তাহলে জাভা কম্পাইলার কনস্ট্রাক্টরের প্রথম স্টেটমেন্ট হিসেবে `super();` যোগ করে।
`Animal` ক্লাসের কনস্ট্রাক্টরের ভেতরে, কম্পাইলার `super();` যোগ করে => `Animal(String name) { super(); this.name = name; }`। 
এই ক্ষেত্রে `super()` `Object` ক্লাসের নো-আর্গ কনস্ট্রাক্টরকে ইনভোক করে, এবং তাই এখানে কোনো কম্পাইলেশন এরর নেই।

কম্পাইলার `Dog(String)` কনস্ট্রাক্টরকে পরিবর্তন করে: `Dog(String breed) { super(); this.breed = breed; }`। 
`Animal` ক্লাসে কোনো নো-আর্গ কনস্ট্রাক্টর উপলব্ধ নেই এবং যেহেতু অন্য একটি কনস্ট্রাক্টর প্রদান করা হয়েছে,
 জাভা কম্পাইলার ডিফল্ট কনস্ট্রাক্টর যোগ করে না। 
 তাই `Dog(String)` কনস্ট্রাক্টর কম্পাইলেশন এরর দেয়।



2.What will be the result of compiling and executing Test class?
Test.java
com.skillcertpro.oca.test

class Parent {
int i = 10;
Parent(int i) {
super();
this.i = i;
}
}

class Child extends Parent {
int j = 20;

Child(int j) {
super(0);
this.j = j;
}

Child(int i, int j) {
super(i);
this(j);
}

}

public class Test {
public static void main(String[] args) {
Child child = new Child(1000, 2000);
System.out.println(child.i + ":" + child.j);
}
}

 Compilation error for Parent(int) constructor
 Compilation error for Child(int) constructor
 Compilation error for Child(int, int) Constructor
 Compilation error for Test class
 1033:20:00
 41.66666667














Ans:
প্রদত্ত কোডে Child(int i, int j) কনস্ট্রাকটরে super(i) এবং this(j) উভয়ই আছে, যা নিয়ম লঙ্ঘন করে। এটি একটি কম্পাইল টাইম এরর দেবে এবং প্রোগ্রামটি রান করা যাবে না।


3.Given code of LogHelper.java file:
package com.skillcertpro.oca;

abstract class Helper {
int num = 100;
String operation = null;

protected abstract void help();

void log() {
System.out.println("Helper-log");
}
}

public class LogHelper extends Helper {
private int num = 200;
protected String operation = "LOGGING";

void help() {
System.out.println("LogHelper-help");
}

void log() {
System.out.println("LogHelper-log");
}

public static void main(String [] args) {
new LogHelper().help();
}
}

Which of the following changes, done independently, allows the code to compile and on execution prints LogHelper-help?
Select ALL that apply.

 Remove the private modifier from the num variable of LogHelper class
 Remove the protected modifier from the operation variable of LogHelper class
 Remove the protected modifier from the help() method of Helper class
 Add the protected modifier to the log() method of Helper class
 Add the protected modifier to the help() method of LogHelper class
 Add the public modifier to the help() method of LogHelper class













Answer: 
সঠিক বিকল্পগুলো হলো:
Add the protected modifier to the help() method of LogHelper class
Add the public modifier to the help() method of LogHelper class


 4.interface Printable {
      public void setMargin();
      public void setOrientation();
      }

      abstract class Paper implements Printable { //Line 7
      public void setMargin() {}
      //Line 9
      }

      class NewsPaper extends Paper { //Line 12
      public void setMargin() {}
      //Line 14
      }
      Above code is currently giving compilation error. Which 2 modifications, done independently, enable the code to compile?

      Replace the code at Line 7 with: class Paper implements Printable { 
      Insert at Line 9: public abstract void setOrientation(); 
      Replace the code at Line 12 with: abstract class NewsPaper extends Paper { 
      Insert at Line 14: public void setOrientation() {} 


 
 
 
 
 
 
 
 
 
 
 
 
 Ans: 
দুটি সঠিক সমাধান হলো:
Insert at Line 9: public abstract void setOrientation();
Insert at Line 14: public void setOrientation() {}

কারণ বিশ্লেষণ:
একটি abstract ক্লাস যখন একটি ইন্টারফেস ইমপ্লিমেন্ট করে, তখন তাকে হয় ইন্টারফেসের সবগুলো মেথড ইমপ্লিমেন্ট করতে হবে, 
অথবা যে মেথডগুলো ইমপ্লিমেন্ট করা হয়নি সেগুলোকে abstract হিসেবে ঘোষণা করতে হবে।
এই নিয়ম লঙ্ঘনের কারণে কম্পাইলার একটি এরর দেবে, কারণ Paper ক্লাসে setOrientation() মেথডটি ইমপ্লিমেন্ট করা হয়নি এবং এটিকে abstract হিসেবেও ঘোষণা করা হয়নি।

প্রদত্ত কোডটিতে একটি কম্পাইল টাইম এরর আছে। এর কারণ হলো:
Paper ক্লাসটি একটি abstract ক্লাস যা Printable ইন্টারফেসকে ইমপ্লিমেন্ট করছে।
Printable ইন্টারফেসে দুটি মেথড রয়েছে: setMargin() এবং setOrientation()।
Paper ক্লাসে শুধুমাত্র setMargin() মেথডটি ইমপ্লিমেন্ট করা হয়েছে (public void setMargin() {})। কিন্তু setOrientation() মেথডটি ইমপ্লিমেন্ট করা হয়নি।




4.class PenDrive {
int capacity;
PenDrive(int capacity) {
this.capacity = capacity;
}
}

class OTG extends PenDrive {
String type;
String make;
OTG(int capacity, String type) {
/*INSERT-1*/
}
OTG(String make) {
/*INSERT-2*/
this.make = make;
}
}

public class Test {
public static void main(String[] args) {
OTG obj = new OTG(128, "TYPE-C");
System.out.println(obj.capacity + ":" + obj.type);
}
}
Currently above code causes compilation error.
Which of the options can successfully print 128:TYPE-C on to the console?

 Replace /*INSERT-1*/ with: super(capacity); Replace /*INSERT-2*/ with: super(128);
 Replace /*INSERT-1*/ with: super.capacity = capacity; this.type = type; Replace /*INSERT-2*/ with: super(128);
 Replace /*INSERT-1*/ with: super(capacity); this.type = type; Replace /*INSERT-2*/ with: super(0);
 Replace /*INSERT-1*/ with: this.type = type; super(capacity); Replace /*INSERT-2*/ with: super(128);
 None of the other options

 
 
 
 
 
 
 
 
 
 
 
 
 Ans:
কেবল তৃতীয় বিকল্পটিই জাভার নিয়ম মেনে চলে এবং সঠিক ফলাফল দেয়।

সঠিক বিকল্পের ব্যাখ্যা:
Replace /*INSERT-1*/ with: super(capacity); this.type = type;: 
এই লাইনটি PenDrive ক্লাসের কনস্ট্রাকটরকে কল করে capacity কে 128 দ্বারা ইনিশিয়ালাইজ করে এবং OTG ক্লাসের type ভ্যারিয়েবলকে "TYPE-C" দ্বারা ইনিশিয়ালাইজ করে। 
এটিই একমাত্র বিকল্প যা main() মেথডের জন্য প্রয়োজনীয় ফলাফল দেবে।
Replace /*INSERT-2*/ with: super(0);: এই পরিবর্তনটি OTG(String make) কনস্ট্রাকটরের জন্য একটি বৈধ প্যারেন্ট কনস্ট্রাক্টর কল নিশ্চিত করে, যা কোডকে কম্পাইল করতে সাহায্য করবে।





 6.Consider codes below:
//A.java
package com.skillcertpro.oca;

public class A {
public int i1 = 1;
protected int i2 = 2;
}

//B.java
package com.skillcertpro.oca.test;
import com.skillcertpro.oca.A;

public class B extends A {
public void print() {
A obj = new A();
System.out.println(obj.i1); //Line 8
System.out.println(obj.i2); //Line 9
System.out.println(this.i2); //Line 10
System.out.println(super.i2); //Line 11
}

public static void main(String [] args) {
new B().print();
}
}
One of the statements inside print() method is causing compilation failure. 
Which of the below solutions will help to resolve compilation error?

 Comment the statement at Line 8
 Comment the statement at Line 9
 Comment the statement at Line 10
 Comment the statement at Line 11















Ans:

Line 9: System.out.println(obj.i2);
`A` ক্লাসটি **পাবলিক** হিসেবে ঘোষণা করা হয়েছে এবং `com.skillcertpro.oca` প্যাকেজে সংজ্ঞায়িত। তাই `com.skillcertpro.oca` প্যাকেজের বাইরে থেকে `A` ক্লাস অ্যাক্সেস করতে কোনো সমস্যা নেই।
  i2 ভেরিয়েবলটি protected হিসেবে ঘোষিত। protected মেম্বার দুটি উপায়ে অ্যাক্সেস করা যায়:
  -একই প্যাকেজের মধ্যে।
  -ভিন্ন প্যাকেজের সাবক্লাস দ্বারা, শুধুমাত্র উত্তরাধিকারসূত্রে প্রাপ্ত মেম্বারের ক্ষেত্রে (inherited members)।
  এখানে B ক্লাসটি A ক্লাসের একটি অবজেক্ট (obj) তৈরি করছে। obj হলো A ক্লাসের একটি ইনস্ট্যান্স, B ক্লাসের নয়। B ক্লাসটি A ক্লাসের সাবক্লাস হলেও, এটি A ক্লাসের অবজেক্টের protected মেম্বারকে সরাসরি অ্যাক্সেস করতে পারে না, কারণ তারা ভিন্ন প্যাকেজে অবস্থিত।



7.Consider codes below:
//A.java
package com.skillcertpro.oca;

public class A {
public void print() {
System.out.println("A");
}
}

//B.java
package com.skillcertpro.oca;

public class B extends A {
public void print() {
System.out.println("B");
}
}

//C.java
package com.skillcertpro.oca;

public class C extends A {
public void print() {
System.out.println("C");
}
}

//Test.java
package com.skillcertpro.oca.test;

import com.skillcertpro.oca.*;

public class Test {
public static void main(String[] args) {
A obj1 = new C();
A obj2 = new B();
C obj3 = (C)obj1;
C obj4 = (C)obj2;
obj3.print();
}
}
What will be the result of compiling and executing Test class?

 A
 B
 C
 Compilation error
 ClassCastException is thrown at runtime













Answer:
Incorrect
Class A, B and C are declared public and inside same package com.skillcertpro.oca. Method print() of class A has correctly been overridden by B and C.
print() method is public so no issues in accessing it anywhere.

Let’s check the code inside main method.
A obj1 = new C(); => obj1 refers to an instance of C class, it is polymorphism. 
A obj2 = new B(); => obj2 refers to an instance of B class, it is polymorphism. 
C obj3 = (C)obj1; => obj1 actually refers to an instance of C class, so at runtime obj3 (C type) will refer to an instance of C class. As obj1 is of A type so explicit typecasting is necessary. 
C obj4 = (C)obj2; => obj2 actually refers to an instance of B class, so at runtime obj4 (C type) will refer to an instance of B class. B and C are siblings and can’t refer to each other, so this statement will throw ClassCastException at runtime.

8.Consider codes below:
//A.java
package com.skillcertpro.oca;

public class A {
public void print() {
System.out.println("A");
}
}

//B.java
package com.skillcertpro.oca;

public class B extends A {
public void print() {
System.out.println("B");
}
}

//Test.java
package com.skillcertpro.oca.test;

import com.skillcertpro.oca.*;

public class Test {
public static void main(String[] args) {
A obj1 = new A();
B obj2 = (B)obj1;
obj2.print();
}
}
What will be the result of compiling and executing Test class?

 A
 B
 Compilation error
 ClassCastException is thrown at runtime

 
 
 
 
 
 
 
 
 
 
 
 Answer:
 A obj1 = new A(); => obj1 ক্লাস A-এর একটি ইনস্ট্যান্সকে নির্দেশ করে।
 B obj2 = (B)obj1; => obj1 হচ্ছে A টাইপের এবং এটিকে obj2 (যা B টাইপের) তে অ্যাসাইন করা হচ্ছে, তাই এক্সপ্লিসিট কাস্টিং (explicit casting) প্রয়োজন। obj1 ক্লাস A-এর একটি ইনস্ট্যান্সকে নির্দেশ করে, তাই রানটাইমে obj2-ও ক্লাস A-এর একটি ইনস্ট্যান্সকে নির্দেশ করবে। সাবটাইপ সুপারটাইপের একটি অবজেক্টকে নির্দেশ করতে পারে না। অতএব, রানটাইমে B obj2 = (B)obj1; লাইনটি একটি ClassCastException থ্রো করবে।

 9. Consider below code of Test.java file:
package com.skillcertprokhattry.oca;

class Super {
void Super() {
System.out.print("KEEP_");
}
}

class Base extends Super {
Base() {
Super();
System.out.print("GOING_");
}
}

public class Test {
public static void main(String[] args) {
new Base();
}
}

What will be the result of compiling and executing above code?

 Compilation Error in Super class
 Compilation Error in Base class
 Compilation Error in Test class
 It prints KEEP_GOING_ on to the console
 It prints GOING_KEEP_ on to the console

 
 
 
 
 
 
 
 
 
 
 
 Answer:
এই কোডটি সফলভাবে কম্পাইল হবে এবং রান করার পর কনসোলে KEEP_GOING_ প্রিন্ট করবে।


 10.Consider below codes of 3 java files:
//Animal.java
package a;

public class Animal {
Animal() {
System.out.print("ANIMAL-");
}
}

//Dog.java
package d;

import a.Animal;

public class Dog extends Animal {
public Dog() {
System.out.print("DOG");
}
}

//Test.java
package com.skillcertprokhattry.oca;

import d.Dog;

public class Test {
public static void main(String[] args) {
new Dog();
}
}

What will be the result of compiling and executing Test class?

 Compilation error in Animal.java file
 Compilation error in Dog.java file
 Compilation error in Test.java file
 It executes successfully and prints ANIMAL-DOG on to the console
 It executes successfully and prints DOG on to the console
 It executes successfully but nothing is printed on to the console


 11.Consider below code fragment:
package com.skillcertprokhattry.oca;

abstract class Food {
protected abstract double getCalories();
}

class JunkFood extends Food {
double getCalories() {
return 200.0;
}
}

Which 3 modifications, done independently, enable the code to compile?

 Make the getCalories() method of Food class public
 Remove the protected access modifier from the getCalories() method of Food class
 Make the getCalories() method of Food class private
 Make the getCalories() method of JunkFood class protected
 Make the getCalories() method of JunkFood class public
 Make the getCalories() method of JunkFood class private

 
 
 
 
 
 
 
 
 
 
 
 
 Ans:
 2,4,5


 12.Consider below code of Test.java file:
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
P p = new R(); //Line n1
System.out.println(p.compute("Go")); //Line n2
}
}

class P {
String compute(String str) {
return str + str + str;
}
}

class Q extends P {
String compute(String str) {
return super.compute(str.toLowerCase());
}
}

class R extends Q {
String compute(String str) {
return super.compute(str.replace(‘o’, ‘O’)); //2nd argument is uppercase O
}
}

What will be the result of compiling and executing Test class?

 gOgOgO
 gogogo
 GoGoGo
 GOGOGO
 Go
 GO


 13.Given code of Test.java file:
package com.skillcertprokhattry.oca;

class X {
void A() {
System.out.print("A");
}
}

class Y extends X {
void A() {
System.out.print("A-");
}

void B() {
System.out.print("B-");
}

void C() {
System.out.print("C-");
}
}

public class Test {
public static void main(String[] args) {
X obj = new Y(); //Line n1
obj.A(); //Line n2
obj.B(); //Line n3
obj.C(); //Line n4
}
}

What will be the result of compiling and executing above code?

 A-B-C-
 AB-C-
 Compilation error in class Y
 Compilation error in class Test














Ans:
Class Y correctly extends class X and it overrides method A() and provides two new methods B() and C().
At Line n1, obj is of X type and therefore obj.B(); and obj.C(); cause compilation error as these methods are not defined in class X.


14. Consider below code of Test.java file:
package com.skillcertprokhattry.oca;

class Currency {
String notation = "-"; //Line n1

String getNotation() { //Line n2
return notation;
}
}

class USDollar extends Currency {
String notation = "$"; //Line n3

String getNotation() { //Line n4
return notation;
}
}

class Euro extends Currency {
protected String notation = "€"; //Line n5

protected String getNotation() { //Line n6
return notation;
}
}

public class Test {
public static void main(String[] args) {
Currency c1 = new USDollar();
System.out.println(c1.notation + ":" + c1.getNotation());

Currency c2 = new Euro();
System.out.println(c2.notation + ":" + c2.getNotation());
}
}

What will be the result of compiling and executing above code?

 -:$ -:€
 -:- -:-
 $:$ €:€
 Compilation error in USDollar class
 Compilation error in Euro class


15.Consider below code of Test.java file:
package com.skillcertprokhattry.oca;

class Super {
public String num = "10"; //Line n1
}

class Sub extends Super {
protected int num = 20; //Line n2
}

public class Test {
public static void main(String[] args) {
Super obj = new Sub();
System.out.println(obj.num += 2); //Line n3
}
}

What will be the result of compiling and executing above code?

 Compilation error at Line n2
 Compilation error at Line n3
 It executes successfully and prints 12 on to the console
 It executes successfully and prints 22 on to the console
 It executes successfully and prints 102 on to the console
 It executes successfully and prints 202 on to the console



 
 
 
 
 
 
 
 
 
 
 
 
 Ans:
 obj’ is of Super type, hence obj.num refers to num variable at Line n1, which is of String type.
Expression at Line n3:
obj.num += 2
=> obj.num = obj.num + 2
=> obj.num = "10" + 2
=> obj.num = "102"
obj.num refers to "102" and same is printed on to the console.


16.Given code of Test.java file:
package com.skillcertprokhattry.oca;

class Parent {
int var = 1000; // Line n1

int getVar() {
return var;
}
}

class Child extends Parent {
private int var = 2000; // Line n2

int getVar() {
return super.var; //Line n3
}
}

public class Test {
public static void main(String[] args) {
Child obj = new Child(); // Line n4
System.out.println(obj.var); // Line n5
}
}

There is a compilation error in the code.
Which three modifications, done independently, print 1000 on to the console?

 Change Line n1 to private int var = 1000;
 Delete the Line n2
 Change Line n3 to return var;
 Change Line n4 to Parent obj = new Child();
 Delete the method getVar() from the Child class
 Change Line n5 to System.out.println(obj.getVar());





 17.class Base {
String msg = "INHALE"; //Line n1
}

class Derived extends Base {
Object msg = "EXHALE"; //Line n2
}

public class Test {
public static void main(String[] args) {
Base obj1 = new Base(); //Line n3
Base obj2 = new Derived(); //Line n4
Derived obj3 = (Derived) obj2; //Line n5
String text = obj1.msg + "-" + obj2.msg + "-" + obj3.msg; //Line n6
System.out.println(text); //Line n7
}
}

What will be the result of compiling and executing above code?

 Line n2 causes compilation error
 Line n5 throws Exception at runtime
 Line n6 causes compilation error
 It executes successfully and prints INHALE-EXHALE-EXHALE
 It executes successfully and prints INHALE-INHALE-EXHALE
 It executes successfully and prints INHALE-INHALE-INHALE




 18.class Base {
static void print() { //Line n1
System.out.println("BASE");
}
}

class Derived extends Base {
static void print() { //Line n2
System.out.println("DERIVED");
}
}

public class Test {
public static void main(String[] args) {
Base b = null;
Derived d = (Derived) b; //Line n3
d.print(); //Line n4
}
}

Which of the following statements is true for above code?

 Line n2 causes compilation error
 Line n3 causes compilation error
 Line n4 causes compilation error
 Code compiles successfully and on execution Line n3 throws an exception
 Code compiles successfully and on execution prints BASE on to the console
 Code compiles successfully and on execution prints DERIVED on to the console




 19.lass Paper {
static String getType() { //Line n1
return "GENERIC";
}
}

class RuledPaper extends Paper {
String getType() { //Line n2
return "RULED";
}
}

public class Test {
public static void main(String[] args) {
Paper paper = new RuledPaper(); //Line n3
System.out.println(paper.getType()); //Line n4
}
}

Which of the following statements is true for above code?

 Compilation error in RuledPaper class
 Compilation error in Test class
 Code compiles successfully and on execution prints GENERIC on to the console
 Code compiles successfully and on execution prints RULED on to the console


 
 
 
 
 
 
 
 
 
 
 
 
 Ans:
 Instance method of subclass cannot override the static method of superclass.
Instance method at Line n2 tries to override the static method at Line n1 and hence Line n2 causes compilation error.


 20.class M {
public void main(String[] args) { //Line n1
System.out.println("M");
}
}

class N extends M {
public static void main(String[] args) { //Line n2
new M().main(args); //Line n3
}
}

public class Test {
public static void main(String[] args) {
N.main(args); //Line n4
}
}

Which of the following statements is true for above code?

 Line n1 causes compilation error
 Line n2 causes compilation error
 Line n3 causes compilation error
 Line n4 causes compilation error
 It executes successfully and prints M on to the console













Ans:
The static method of subclass cannot hide the instance method of superclass. static main(String []) method at Line n2 tries to hide the instance main(String []) method at Line n1 and hence Line n2 causes compilation error.

 21.class Parent {
String quote = "MONEY DOESN’T GROW ON TREES";
}

class Child extends Parent {
String quote = "LIVE LIFE KING SIZE";
}

class GrandChild extends Child {
String quote = "PLAY PLAY PLAY";
}

public class Test {
public static void main(String[] args) {
GrandChild gc = new GrandChild();
System.out.println(/*INSERT*/);
}
}
Which of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print MONEY DOESN’T GROW ON TREES on to the console?
Select ALL that apply.

 gc.quote
 (Parent)gc.quote
 ((Parent)gc).quote
 ((Parent)(Child)gc).quote
 (Parent)(Child)gc.quote

 
 
 
 
 
 
 
 
 
 
 
 
 Ans:
 (Parent)gc.quote => gc.quote will be evaluated first as dot (.) operator has higher precedence than cast. gc.quote refers to String, hence it cannot be casted to Parent type. This would cause compilation error.
((Parent)gc).quote => Variable ‘gc’ is casted to Parent type, so this expression refers to "MONEY DOESN’T GROW ON TREES". It is one of the correct options.
((Parent)(Child)gc).quote => ‘gc’ is of GrandChild type, it is first casted to Child and then to Parent type and finally quote variable is accessed, so this expression refers to "MONEY DOESN’T GROW ON TREES". It is also one of the correct options.
(Parent)(Child)gc.quote => gc.quote will be evaluated first as dot (.) operator has higher precedence than cast. gc.quote refers to String, hence it cannot be casted to Child type. This would cause compilation error.

 22.class X {
void greet() {
System.out.println("Good Morning!");
}
}

class Y extends X {
void greet() {
System.out.println("Good Afternoon!");
}
}

class Z extends Y {
void greet() {
System.out.println("Good Night!");
}
}

public class Test {
public static void main(String[] args) {
X x = new Z();
x.greet(); //Line n1
((Y)x).greet(); //Line n2
((Z)x).greet(); //Line n3
}
}

What will be the result of compiling and executing above code?

 Compilation error
 An exception is thrown at runtime
 It compiles successfully and on execution prints below: Good Night! Good Afternoon! Good Morning
 It compiles successfully and on execution prints below: Good Night! Good Night! Good Night!
 It compiles successfully and on execution prints below: Good Morning! Good Morning! Good Morning!

 23.Given code of Test.java file:
package com.skillcertprokhattry.oca;

class Lock {
public void open() {
System.out.println("LOCK-OPEN");
}
}

class Padlock extends Lock {
public void open() {
System.out.println("PADLOCK-OPEN");
}
}

class DigitalPadlock extends Padlock {
public void open() {
/*INSERT*/
}
}

public class Test {
public static void main(String[] args) {
Lock lock = new DigitalPadlock();
lock.open();
}
}

Which of the following options, if used to replace /*INSERT*/, will compile successfully and on execution will print LOCK-OPEN on to the console?

 super.open();
 super.super.open();
 ((Lock)super).open();
 (Lock)super.open();
 None of the other options















Ans:
super.open(); => Using super keyword, you can access methods and variables of immediate parent class, hence if you replace /*INSERT*/ with `super.open();`, then open() method of Padlock class will be invoked.
super.super.open(); => super.super is not allowed in java, it causes compilation error.
((Lock)super).open(); => Not possible to cast super keyword in java, it causes compilation error.
(Lock)super.open(); => super.open(); will be evaluated first as dot (.) operator has higher precedence than cast. super.open(); returns void and hence it cannot be casted to Lock. It also causes compilation error.
In fact, it is not possible to directly reach to 2 levels, super keyword allows to access methods and variables of immediate parent class only (just 1 level up). Hence, correct 
answer is: ‘None of the other options’

 24.
//Chair.java
package com.skillcertprokhattry.oca;

public class Chair implements Sellable {
public double getPrice() {
return 35;
}

public String symbol() {
return "£";
}
}

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
Sellable obj = new Chair(); //Line n1
System.out.println(obj.symbol() + obj.getPrice()); //Line n2
}
}

What will be the result of compiling and executing Test class?

 Compilation error in Chair class
 Compilation error in Test class
 It compiles successfully and on execution prints $35 on to the console
 It compiles successfully and on execution prints $35.0 on to the console
 It compiles successfully and on execution prints $35.00 on to the console
 It compiles successfully and on execution prints £35.0 on to the console

25.//I1.java
package com.skillcertprokhattry.oca;

public interface I1 {
int i = 10;
}

//I2.java
package com.skillcertprokhattry.oca;

public interface I2 {
int i = 20;
}

//I3.java
package com.skillcertprokhattry.oca;

public interface I3 extends I1, I2 { //Line n1

}

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
System.out.println(I1.i); //Line n2
System.out.println(I2.i); //Line n3
System.out.println(I3.i); //Line n4
}
}

Which of the following statements is correct?

 Line n1 causes compilation error
 Line n2 causes compilation error
 Line n3 causes compilation error
 Line n4 causes compilation error
 There is no compilation error














Ans:
Variable ‘i’ declared inside interface I1 is implicitly public, static and final and similarly variable i declared inside interface I2 is implicitly public, static and final as well.
In Java a class can extend from only one class but an interface can extend from multiple interfaces. static variables are not inherited and hence there is no issue with Line n1.

I1.i points to variable ‘i’ of interface I1.
I2.i points to variable ‘i’ of interface I2.
I3.i is an ambiguous call as compiler is not sure whether to point to I1.i or I2.i and therefore, Line n4 causes compilation error.


26.Consider below codes of 2 java files:
//Counter.java
package com.skillcertprokhattry.oca;

public interface Counter {
int count = 10; //Line n1
}

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
Counter [] arr = new Counter[2]; //Line n2
for(Counter ctr : arr) {
System.out.print(ctr.count); //Line n3
}
}
}

Which of the following statements is correct?

 Only Line n1 causes compilation error
 Only Line n2 causes compilation error
 Line n1 and Line n2 cause compilation error
 Only Line n3 causes compilation error
 Line n3 throws an exception at runtime
 Test class compiles successfully and on execution prints 1010 on to the console














Ans:
Line n2: Counter [] arr = new Counter[2]; - এটি Counter ইন্টারফেস টাইপের একটি অ্যারে তৈরি করছে। যদিও আপনি ইন্টারফেসের কোনো অবজেক্ট তৈরি করতে পারেন না, কিন্তু ইন্টারফেস টাইপের একটি অ্যারে তৈরি করা সম্ভব। এই অ্যারের প্রতিটি উপাদান ডিফল্টভাবে null দ্বারা ইনিশিয়্যালাইজড হবে। এটিও একটি বৈধ স্টেটমেন্ট।
সুতরাং, কোডটি সফলভাবে কম্পাইল হবে এবং আউটপুট হবে 1010।

27.Consider below codes of 3 java files:
//Shrinkable.java
package com.skillcertprokhattry.oca;

public interface Shrinkable {
public static void shrinkPercentage() {
System.out.println("80%");
}
}

//AntMan.java
package com.skillcertprokhattry.oca;

public class AntMan implements Shrinkable { }

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
AntMan.shrinkPercentage();
}
}

Which of the following statements is correct?

 There is a compilation error in Shrinkable.java file
 There is a compilation error in AntMan.java file
 There is a compilation error in Test.java file
 There is no compilation error and on execution, Test class prints 80% on to the console
Incorrect
As per Java 8, default and static methods were added in the interface. There is no issue in Shrinkable.java file.
class AntMan implements Shrinkable interface but as there is no abstract method in Shrinkable interface, hence AntMan class is not needed to implement any method. AntMan.java file compiles successfully.
static method of Shrinkable interface can only be accessed by using Shrinkable.shrinkPercentage(). `AntMan.shrinkPercentage();` causes compilation error.


28.//Buyable.java
package com.skillcertprokhattry.oca;

public interface Buyable {
int salePercentage = 85;

public static String salePercentage() {
return salePercentage + "%";
}
}

//Book.java
package com.skillcertprokhattry.oca;

public class Book implements Buyable {}

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
Buyable [] arr = new Buyable[2];
for(Buyable b : arr) {
System.out.println(b.salePercentage); //Line n1
System.out.println(b.salePercentage()); //Line n2
}

Book [] books = new Book[2];
for(Book b : books) {
System.out.println(b.salePercentage); //Line n3
System.out.println(b.salePercentage()); //Line n4
}
}
}

Which of the following statements are correct?
Select ALL that apply.

 There is a compilation error in Buyable.java file
 There is a compilation error in Book.java file
 There is a compilation error at Line n1
 There is a compilation error at Line n2
 There is a compilation error at Line n3
 There is a compilation error at Line n4



 29.//Buyable.java
package com.skillcertprokhattry.oca;

public interface Buyable {
int salePercentage = 85;

public static String salePercentage() {
return salePercentage + "%";
}
}

//Book.java
package com.skillcertprokhattry.oca;

public class Book implements Buyable {}

//Test.java
package com.skillcertprokhattry.oca;

public class Test {
public static void main(String[] args) {
Buyable [] arr = new Buyable[2];
for(Buyable b : arr) {
System.out.println(b.salePercentage); //Line n1
System.out.println(b.salePercentage()); //Line n2
}

Book [] books = new Book[2];
for(Book b : books) {
System.out.println(b.salePercentage); //Line n3
System.out.println(b.salePercentage()); //Line n4
}
}
}

Which of the following statements are correct?
Select ALL that apply.

 There is a compilation error in Buyable.java file
 There is a compilation error in Book.java file
 There is a compilation error at Line n1
 There is a compilation error at Line n2
 There is a compilation error at Line n3
 There is a compilation error at Line n4

 
 
 
 
 
 
 
 
 
 
 
 
 Ans:
 Super type reference variable can refer to an instance of Sub type, therefore the statement `I1 obj = new C1();` compiles successfully.
obj is of I1 type, hence `obj.print("Java");` tries to tag the static method of I1 but static print(String) method of I1 can only be invoked by using I1.print("Java");.
Therefore, `obj.print("Java");` causes compilation error.


 30.//Profitable1.java
package com.skillcertprokhattry.oca;

public interface Profitable1 {
default double profit() {
return 12.5;
}
}

//Profitable2.java
package com.skillcertprokhattry.oca;

public interface Profitable2 {
default double profit() {
return 25.5;
}
}

//Profit.java
package com.skillcertprokhattry.oca;

public abstract class Profit implements Profitable1, Profitable2 {
/*INSERT*/
}

Which of the following needs to be done so that there is no compilation error?

 No need for any modifications, code compiles as is
 Replace /*INSERT*/ with below code: double profit() {     return 50.0; }
 Replace /*INSERT*/ with below code: public default double profit() {     return 50.0; }
 Replace /*INSERT*/ with below code: protected double profit() {     return 50.0; }
 Replace /*INSERT*/ with below code: public double profit() {     return Profitable1.profit(); }
 Replace /*INSERT*/ with below code: public double profit() {     return Profitable2.super.profit(); }

 
 
 
 
 
 
 
 
 
 
 
 
 Ans:
 Replace /*INSERT*/ with below code:
public double profit() {
    return Profitable2.super.profit();
}

 31.interface Perishable1 {
default int maxDays() {
return 1;
}
}

interface Perishable2 extends Perishable1 {
default int maxDays() {
return 2;
}
}

class Milk implements Perishable2, Perishable1 {}

public class Test {
public static void main(String[] args) {
Perishable1 obj = new Milk();
System.out.println(obj.maxDays());
}
}

Which of the following statements is correct?

 Interface Perishable2 causes compilation error
 Class Milk causes compilation error
 Class Test causes compilation error
 Given code compiles successfully and on execution Test class prints 1 on to the console
 Given code compiles successfully and on execution Test class prints 2 on to the console
 
 
 
 
 
 
 
 
 
 
 
 
 
 Ans:
 Method maxDays() is implicitly public in Perishable1.
interface Perishable2 extends Perishable1 and it overrides the default method maxDays() of Document, overriding method in Perishable2 is implicitly public. Interface Perishable2 compiles successfully.
 

 32.interface M {
      public static void log() {
      System.out.println("M");
      }
      }

      abstract class A {
      public static void log() {
      System.out.println("N");
      }
      }

      class MyClass extends A implements M {}

      public class Test {
      public static void main(String[] args) {
      M obj1 = new MyClass();
      obj1.log(); //Line n1

      A obj2 = new MyClass();
      obj2.log(); //Line n2

      MyClass obj3 = new MyClass();
      obj3.log(); //Line n3
      }
      }

      Which of the following statements is correct?

      There is a compilation error in interface M
      There is a compilation error in class A
      Line n1 causes compilation error
      Line n2 causes compilation error
      Line n3 causes compilation error
      Given code compiles successfully

 
 
 
 
 
 
 
 
 
 
 
 
 Ans:
 obj1 is of M type, hence `obj1.log();` tries to tag the static method of M but static log() method of M can only be invoked by using M.log();.
Therefore, Line n1 causes compilation error.



 33.Consider below code snippet:
interface ILog {
default void log() {
System.out.println("ILog");
}
}

abstract class Log {
public static void log() {
System.out.println("Log");
}
}

class MyLogger extends Log implements ILog {}

Which of the following statements is correct?

 There is no compilation error in the above code
 There is a compilation error in interface ILog
 There is a compilation error in abstract class Log














Ans:
"MyLogger ক্লাসে একটি ইন্সট্যান্স মেথড (`log()`, যা `ILog` ইন্টারফেস থেকে উত্তরাধিকারসূত্রে প্রাপ্ত) এবং একটি স্ট্যাটিক মেথড (`log()`, যা `Log` ক্লাস থেকে উত্তরাধিকারসূত্রে প্রাপ্ত) রয়েছে। 
এর ফলে একটি কনফ্লিক্ট বা দ্বন্দ্ব তৈরি হচ্ছে।

একই স্কোপের মধ্যে একই সিগনেচারযুক্ত স্ট্যাটিক এবং নন-স্ট্যাটিক মেথড একসাথে রাখা জাভাতে অনুমোদিত নয়। তাই MyLogger ক্লাসটি কম্পাইল করতে ব্যর্থ হবে।"



