Date: 28 July ,2025


###0
জাভাতে প্যাকেজ, ক্লাস (এবং কনস্ট্রাক্টর), ভেরিয়েবল এবং মেথডের একই নাম ব্যবহার করা সম্ভব? 
Yes, main as name also compile

কনসোল কল এবং ইনস্ট্যান্টিয়েট করার পরের কলের মধ্যে পার্থক্য ?
-কনসোল কল (Console Call)
	যখন আপনি সরাসরি কনসোল থেকে কোনো প্রোগ্রাম চালান, তখন জাভা ভার্চুয়াল মেশিন (JVM) স্বয়ংক্রিয়ভাবে সেই ক্লাসের main() পদ্ধতিটি খুঁজে বের করে এবং কল করে। 
	এই কলটি স্ট্যাটিক (static) হওয়ায় ক্লাসের কোনো অবজেক্ট তৈরি করার প্রয়োজন হয় না। এটি প্রোগ্রামের প্রবেশপথ (entry point) হিসেবে কাজ করে।
-ইনস্ট্যান্টিয়েট করার পরের কল (Call after Instantiation)
	ইনস্ট্যান্টিয়েট করার পরের কল হলো যখন আপনি একটি ক্লাসের অবজেক্ট তৈরি করেন এবং সেই অবজেক্টের মাধ্যমে ক্লাসের কোনো পদ্ধতিকে কল করেন। 
	এই পদ্ধতিগুলো স্ট্যাটিক নয়। অবজেক্ট তৈরি করা মানে হলো ক্লাসের একটি ইনস্ট্যান্স তৈরি করা, যা ক্লাসের নন-স্ট্যাটিক পদ্ধতি এবং ভেরিয়েবল ব্যবহার করতে পারে।

### 1. multiple main method.
একটি ফাইলে যদি তিনটি ক্লাস থাকে, তবে প্রতিটি ক্লাসে public static void main(String[] args) {} মেথড থাকতে পারে? main method ওভারলোড করা যায়?
Yes, these can. জাভা কম্পাইল করার সময় প্রতিটি ক্লাসকে আলাদা .class ফাইলে রূপান্তরিত করে। 
তাই প্রতিটি ক্লাস স্বতন্ত্রভাবে কার্যকর হতে পারে। তবে, আপনি যখন প্রোগ্রামটি চালাবেন, তখন আপনাকে সুনির্দিষ্টভাবে বলে দিতে হবে যে আপনি কোন ক্লাসের main মেথডটি চালাতে চান।

-অন্যান্য Method মতোই, main method ওভারলোড করা যায়। তবে, JVM দ্বারা কল করা main Method সর্বদা String[] প্যারামিটার সহ থাকে। আউটপুট সবসময় একই হবে।

### 2. কমান্ড-লাইন আর্গুমেন্ট (Command-Line Args)  
মনে রাখতে হবে:  
`main(String[] args)`-এ `args` অ্যারের দৈর্ঘ্য:  
কমান্ড: java YourClassName আর্গুমেন্ট ছাড়া(args.length = 0` → `args[0]`): ArrayIndexOutOfBoundsException
কমান্ড: java YourClassName Hello আর্গুমেন্ট সহ: → `args[0] = "Hello"

- সমাধান: `args.length` চেক না করে `args[0]` এক্সেস করলে রানটাইম এরর।  

---

### 3. মেইন মেথডের সিনট্যাক্স  
মনে রাখতে হবে:  
স্ট্যাটিক (static) এবং পাবলিক (public)-এর অবস্থান পরিবর্তন করা যেতে পারে, তবে রিটার্ন টাইপ অবশ্যই মেথডের নামের ঠিক আগে বসবে।
জেভিএম-এর জন্য মেইন মেথডকে স্ট্যাটিক হতে হয়, যাতে ক্লাসের কোনো ইনস্ট্যান্স ছাড়াই এটিকে কল করা যায়। 

- `public static void main(String[] args)` → একমাত্র ভ্যালিড সিগনেচার।  
- ভ্যারিয়েন্টস:  
  - `public static void main(String args[])` → ভ্যালিড সিগনেচার।  
  - `static public void main(String[] a)` → ভ্যালিড (অর্ডার পরিবর্তন)। 

 
- সমাধান: `main` মেথডের রিটার্ন টাইপ ও প্যারামিটার টাইপ ঠিক আছে কিনা চেক করুন।  

---

### 4. র‍্যাপার ক্লাস ও NullPointerException  
মনে রাখতে হবে:  
- `Boolean.valueOf("abc")` → `false` (কেস-ইনসেনসিটিভ, শুধু "true" হলে `true`)।  
- `Boolean[] arr = new Boolean[2];` → ডিফল্ট মান `null`।  
  - `if(arr[0])` → `NullPointerException` (`null` থেকে `boolean` কনভার্সন)।  
- সমাধান: র‍্যাপার অবজেক্টে `null` চেক করুন।  

---

### 5. টারনারি অপারেটর (Ternary Operator)  
মনে রাখতে হবে:  
- `Boolean.valueOf(s) ? "T" : "F"`:  
  - `s = "TrUe"` → `true` (কেস-ইনসেনসিটিভ)।  
  - `s = null` → `false` (`Boolean.valueOf(null)` রিটার্ন `false`)।  
- সমাধান: টারনারি অপারেটরের কন্ডিশন কী রিটার্ন করছে তা চেক করুন।  

---

### 6. নিউমেরিক টাইপ কনভার্সন  
মনে রাখতে হবে:  
- অটো-বক্সিং/আনবক্সিং: `int` ↔ `Integer`, `double` ↔ `Double`
 টাইপ প্রমোশন: একটি `final int` ভ্যারিয়েবলের মান যদি একটি `short` টাইপের সীমার মধ্যে থাকে, তবে তা সরাসরি `short` এ অ্যাসাইন করা যায়, কিন্তু `final` না হলে বা সীমার বাইরে থাকলে কম্পাইলেশন ত্রুটি হবে।
	- গাণিতিক অপারেশনে ছোট ডেটা টাইপগুলো স্বয়ংক্রিয়ভাবে বড় ডেটা টাইপে উন্নীত হয়। যেমন, `byte`  `short`, এবং char` → `int` (ASCII মান) টাইপগুলো `int` এ উন্নীত হয়। 
    - `short s = 32768;` → কম্পাইল এরর (সর্বোচ্চ মান `32767`)।  
- সমাধান: টাইপ কাস্টিং ও রেঞ্জ চেক করুন।  

---

### 7. লজিক্যাল অপারেটর (&&, ||)   
মনে রাখতে হবে:  
- `&&` এবং `||` শর্ট-সার্কিট অপারেটর:  
  - `a++ == 7 && ++a == 9` → প্রথম অংশ `false` হলে দ্বিতীয় অংশ এক্সিকিউট হয় না।  
  - `a++ == 7 || ++a == 9` → প্রথম অংশ `true` হলে দ্বিতীয় অংশ এক্সিকিউট হয় না।  
- সমাধান: ভ্যারিয়েবল মান পরিবর্তন (`++a`, `a++`) কোথায় হচ্ছে তা ট্র্যাক করুন।  

### 8. মেমরি ম্যানেজমেন্ট এবং গার্বেজ কালেকশন
* গার্বেজ কালেকশন (GC): কোনো অবজেক্ট যদি কোনো সক্রিয় রেফারেন্স দ্বারা অ্যাক্সেসযোগ্য না থাকে, তবে সেটি গার্বেজ কালেকশনের জন্য যোগ্য হয়ে ওঠে।
    * একটি মেথডে তৈরি লোকাল ভ্যারিয়েবলের রেফারেন্স মেথডটি শেষ হওয়ার পর অদৃশ্য হয়ে যায়।
    * একটি রেফারেন্স ভ্যারিয়েবলের মান `null` করলে বা অন্য কোনো অবজেক্টকে অ্যাসাইন করলে, আগের অবজেক্টটি রেফারেন্স হারায়।
	- অবজেক্ট রেফারেন্স ছাড়া (unreachable) হলে GC যোগ্য।  
	  - `p1 = null;` → রেফারেন্স হারায়।  
	  - `p1 = p2;` → পুরানো অবজেক্ট unreachable হয়।  
	- সমাধান: কোন লাইনের পর অবজেক্টের কোনো রেফারেন্স নেই তা খুঁজুন।  

### 9. অন্যান্য গুরুত্বপূর্ণ বিষয়
* লজিক্যাল অপারেটর: `if...else` স্টেটমেন্টে যদি একটিমাত্র স্টেটমেন্ট থাকে, তবে কার্লি ব্রেস `{}` ঐচ্ছিক। তবে যদি `if` ব্লকের পর একাধিক স্টেটমেন্ট থাকে এবং তার পর `else` থাকে, 
             তাহলে কম্পাইলার ভুল করে `if` এর সাথে শুধুমাত্র প্রথম স্টেটমেন্টটিকে সংযুক্ত করে, যার ফলে কম্পাইলেশন ত্রুটি ঘটে।
* সুইচ স্টেটমেন্ট: `switch`-এর এক্সপ্রেশন টাইপ চেক করুন।   `switch` স্টেটমেন্টে `Boolean`, `long`, `float` এবং `double` টাইপের ডেটা ব্যবহার করা যায় না ।

* ইনপুট আর্গুমেন্টের ব্যবহার: যদি `if` স্টেটমেন্টে একটি `Boolean` রেফারেন্স টাইপ (`Boolean[] arr`) ব্যবহার করা হয়, যা ডিফল্টভাবে `null` থাকে, 
     তাহলে রানটাইমে `NullPointerException` ঘটবে কারণ জাভা কম্পাইলার `null` এর উপর `booleanValue()` মেথডটি কল করার চেষ্টা করবে ।
* সংখ্যা লিটারাল: জাভাতে আন্ডারস্কোর (`_`) ব্যবহার করে সংখ্যাকে সহজে পড়া যায়। তবে এটি সংখ্যার শুরুতে, শেষে বা দশমিকের পরে ব্যবহার করা যায় না ।

* ফ্লোটিং-পয়েন্ট অ্যারিথমেটিক: একটি অ্যারিথমেটিক অপারেশনের ফলাফলের ডেটা টাইপ তার অপারেন্ডের ডেটা টাইপের উপর নির্ভর করে। যদি একটি `double` টাইপ অপারেন্ড হিসেবে থাকে, তবে ফলাফল `double` হবে ।





------------------------

1. //Guest.java
    class Message {
    public static void main(String [] args) { //**or without public
    System.out.println(“Welcome ” + args[0] + “!”);
    }
    }

    public class Guest {
    public static void main(String [] args) {
    Message.main(args);
    }
    }
    And the commands:
    javac Guest.java
    java Guest James Gosling
What is the result?












Ans:
Welcome Guest! (Message (Message.main())| ?

2. Does this compile? System.out.println(“Hello”);;;;;;;;;
3. the correct package declaration to declare Test class in com.exam.oca package?












Ans:
2.Yes
3. package com.exam.oca;




4. For the class Test, which options, if used to replace /*INSERT*/, will print “Hurrah! I passed…” on to the console? Select ALL that apply.
      public class Test {
      /*INSERT*/ {
      System.out.println(“Hurrah! I passed…”);
      }
      }

      A. static public void main(String [] args) 
      B. public static void main(String [] a) 
      C. static public void Main(String [] args) 
      D. public void main(String [] args) 
      E. protected static void main(String [] args) 











Ans: 
স্ট্যাটিক (static) এবং পাবলিক (public)-এর অবস্থান পরিবর্তন করা যেতে পারে, তবে রিটার্ন টাইপ অবশ্যই মেথডের নামের ঠিক আগে বসবে।
জেভিএম-এর জন্য মেইন মেথডকে স্ট্যাটিক হতে হয়, যাতে ক্লাসের কোনো ইনস্ট্যান্স ছাড়াই এটিকে কল করা যায়। এর ফলাফল হলো A এবং B।



5. What will be the result if Test class is executed by below command? java Test 10
      public class Test {
          public static void main(String[] args) {
          System.out.println(“ONE”);
          }    
          public static void main(Integer[] args) {
          System.out.println(“TWO”);
          }    
          public static void main(byte [] args) {
          System.out.println(“THREE”);
          }
      }













Ans: 
অন্যান্য Method মতোই, main পদ্ধতিও ওভারলোড করা যায়। তবে, JVM দ্বারা কল করা main পদ্ধতিটি সর্বদা String[] প্যারামিটার সহ থাকে। আউটপুট সবসময় একই হবে।

  
  6. Consider below code of main.java file:
        package main;
        public class main{
        static String main = “ONE”;  
        public main() {
        System.out.println(“TWO”);
        }  
        public static void main(String [] args) {
        main();
        }  
        public static void main() {
        System.out.println(main);
        }
        }
        
        Also consider below statements:
        1. Code doesn’t compile
        2. Code compiles successfully
        3. Only ONE will be printed to the console
        4. Only TWO will be printed to the console
        5. Both ONE and TWO will be printed to the console
  
  How many of the above statements is/are true?
  **console call vs call after instantiate 












Ans:  
যদিও দেওয়া কোডটি দেখতে অদ্ভুত, তবুও জাভাতে প্যাকেজ, ক্লাস (এবং কনস্ট্রাক্টর), ভেরিয়েবল এবং মেথডের একই নাম ব্যবহার করা সম্ভব।
উপরের কোডটি সফলভাবে কম্পাইল করে এবং এক্সিকিউট হলে কনসোলে "ONE" প্রিন্ট করে। কনস্ট্রাক্টরটি কল করা হয় না কারণ new কীওয়ার্ড ব্যবহার করা হয়নি, এবং এই কারণেই "TWO" কনসোলে প্রিন্ট হবে না।


  7. Given code of Test.java file:
      class A {
      public static void main(String[] args) {
      System.out.println(“A”);
      }
      }  
      class B {
      public static void main(String [] args) {
      System.out.println(“B”);
      }
      }  
      class C {
      public static void main(String [] args) {
      System.out.println(“C”);
      }
      }  
      class D {
      public static void main(String [] args) {
      System.out.println(“D”);
      }
      }
  
  Which of the following options is correct?  
   A-To print C on to the console, execute below commands: javac Test.java java Test
   B-To print C on to the console, execute below commands: javac C.java java C
   C-To print C on to the console, execute below commands: javac Test.java java C
   D-Test.java file is not a valid java file as it doesn't contain code for class Test
   E-Test.java file will compile successfully but expected output is not possible












Ans:
C


8. Given code of Test.java file:
    public class Test {
	    public static void main(String[] args) {
	    args[1] = “Day!”;
	    System.out.println(args[0] + ” ” + args[1]);
	    }
    }
    And the commands:
    javac Test.java
    java Test Good

    Does it compile?  This is how, can we assign the value of an array? What is the result?















Ans:
args[1] = “Day!”; is trying to access 2nd array element at index 1,
which is not available and hence an exception is thrown(java.lang.ArrayIndexOutOfBoundsException) at runtime. 







9. Consider the codes of 3 Java files:
    
//Planet.java
    package com.skillcertprokhattry.galaxy;
    public class Planet {
    String name;
    public Planet(String name) {
    	this.name = name;
    }
    public String toString() {
    	return “Planet: ” + name;
    }
    }

//Creator.java
    package com.skillcertprokhattry.oca;
    public class Creator {
    public static Planet create() {
    	return new Planet(“Earth”);
    }
    }

//TestCreator.java
    package com.skillcertprokhattry.oca.test;
    public class TestCreator {
    public static void main(String[] args) {
    	System.out.println(Creator.create());
    }
    }

    And below options:1
    Add below import statement in Creator.java file:
    import com.skillcertprokhattry.galaxy.Planet;
    And below options:2
    Add below import statement in Creator.java file:
    import com.skillcertprokhattry.oca.test.TestCreator;
    And below options:3
    Add below import statement in TestCreator.java file:
    import com.skillcertprokhattry.oca.Creator;
    And below options:4
    Add below import statement in TestCreator.java file:
    import com.skillcertprokhattry.galaxy.Planet;

    Which of the above options needs to be done so that on executing TestCreator class, “Planet: Earth” is printed on to the console?
    Please note: Unnecessary imports are not allowed.













Ans:
1 & 3 only




10. What will be the result of compiling and executing the Test class?
    public class Test {
	    public static void main(String[] args) {
	      byte b1 = (byte) (127 + 21);
	      System.out.println(b1);
	    }
    }
    choose: 148 Or Compilation error  Or -108 Or -128?











Ans:  
-127 + 21 = 148 = 00000000 00000000 00000000 10010100 
-Above binary number is positive, as left most bit is 0. 
-Same binary number after type-casting to byte: 10010100, negative number as left most bit is 1. 
=10010100 = -108.






11. What will be the result of compiling and executing the TestStudent class?
    //TestStudent.java
    class Student {
	    char var1;
    	double var2;
    	float var3;
	    int age;
	    String name;
	    boolean result;



    public class TestStudent {
	    public static void main(String[] args) {
	    Student stud = new Student();
		System.out.println(“>” + stud.var1);
    		System.out.println(“>” + stud.var2);
    		System.out.println(“>” + stud.var3);
	    System.out.println(stud.name + stud.result + stud.age);
    	    }
    }














Ans: 
>  >0.0 >0.0
null0.0false0





12. public class Pen {
    public static void main(String[] args) {
    Pen p1 = new Pen(); //Line 1
    Pen p2 = new Pen(); //Line 2
    p1 = p2; //Line 3
    p1 = null; //Line 4
    }
    }
    When is the Pen object, created at Line 1 eligible for Garbage Collection?












Ans: 
লাইন ১ এ তৈরি Pen অবজেক্টটি , 
-p1 = p2; //লাইন ৩,  p1 আর কোনো Pen অবজেক্টকে নির্দেশ করছে না। এ স্টেটমেন্টটি এক্সিকিউট হওয়ার সাথে সাথে গার্বেজ কালেকশনের জন্য যোগ্য হয়ে ওঠে।
-p1 = null; // লাইন ৪
* অবজেক্ট B এখনও p2 এর মাধ্যমে অ্যাক্সেসযোগ্য। 




13. How many objects of Pen class are eligible for Garbage Collection at Line 4?    
   class Pen {} // একটি সরল ক্লাস যেখানে স্পষ্টভাবে কোনো ফিল্ড বা মেথড সংজ্ঞায়িত করা হয়নি।
    public class TestPen {
	    public static void main(String[] args) {
	        new Pen();          //লাইন ১
	        Pen p = new Pen();  //লাইন ২
	        change(p);          //লাইন ৩
	        System.out.println("About to end."); //লাইন ৪
	    }
	    public static void change(Pen pen) { //লাইন ৫
	        pen = new Pen();    //লাইন ৬
	    }
     }












Ans: 
লাইন ৪: System.out.println(“About to end.”);
লাইন ১: এ তৈরি করা Pen অবজেক্টটি গার্বেজ কালেকশনের জন্য যোগ্য (এটি কখনই রেফারেন্স করা হয়নি)।
লাইন ৩: change(p);  কলটি সম্পূর্ণ হয়ে যায়, তখন জাভা এই মেথডের ভিতরের সমস্ত লোকাল ভেরিয়েবল মেমরি থেকে সরিয়ে দেয়।
	 -এ তৈরি করা Pen অবজেক্টটি (change মেথডের ভিতরে, লাইন 6) গার্বেজ কালেকশনের জন্য যোগ্য (change মেথডটি সম্পূর্ণ হয়েছে এবং এর লোকাল ভেরিয়েবল pen স্কোপের বাইরে)। 
লাইন ২: এ তৈরি করা Pen অবজেক্টটি এখনও main মেথডের p ভেরিয়েবল দ্বারা অ্যাক্সেসযোগ্য।
অতএব, লাইন ৪ এ ২টি Pen ক্লাসের অবজেক্ট গার্বেজ কালেকশনের জন্য যোগ্য।


14. Wrapper classes are defined in which of the following package?











Ans: 
java.lang


15. --




16.class Point {
    int x;
    int y;
    void assign(int x, int y) {
    x = this.x;
    this.y = y;
    }

    public String toString() {
    return “Point(” + x + “, ” + y + “)”;
    }
    }

    public class Test {
    public static void main(String[] args) {
    Point p1 = new Point();
    p1.x = 10;
    p1.y = 20;
    Point p2 = new Point();
    p2.assign(p1.x, p1.y);
    System.out.println(p1.toString() + “;” + p2.toString());
    }
    }
    What will be the result of compiling and executing Test class?














Ans: 
Point(10, 20);Point(0, 20)  **x=this.x(default value of x 0)
	public String toString() {
	return “Point(” + x + “, ” + y + “)”;  //works return type fine as int in the text file
	}


17.public class Counter {
    int count;
    private static void increment(Counter counter) {
    counter.count++;
    }

    public static void main(String [] args) {
    Counter c1 = new Counter();
    Counter c2 = c1;
    Counter c3 = null;
    c2.count = 1000;
    increment(c2);
    }
    }
    On executing Counter class, how many Counter objects are created in the memory?















Ans: 
-Counter c1 = new Counter();এই লাইনটি মেমরিতে প্রথম Counter অবজেক্টটি তৈরি করে। এই অবজেক্টের রেফারেন্স c1 ভেরিয়েবলে সংরক্ষণ করা হয়।
-Counter c3 = null; এটি কোনো Counter অবজেক্ট তৈরি করে না।
-increment(c2);এই লাইনটি increment মেথডকে কল করে, c2 রেফারেন্সটি পাস করে। increment মেথডের ভিতরে, counter.count++ আবার একই Counter অবজেক্টের count ফিল্ডকে পরিবর্তন করে। এই মেথড কলের সময় কোনো নতুন অবজেক্ট তৈরি হয় না।
-main মেথডের পুরো এক্সিকিউশনের সময়, শুধুমাত্র একটি new Counter() কল করা হয়েছে। অতএব, মেমরিতে শুধুমাত্র একটি Counter অবজেক্ট তৈরি হয়।





18. public class Test {
    public static void main(String[] args) {
    Boolean b1 = new Boolean(“tRuE”);
    Boolean b2 = new Boolean(“fAlSe”);
    Boolean b3 = new Boolean(“abc”);
    Boolean b4 = null;
    System.out.println(b1 + “:” + b2 + “:” + b3 + “:” + b4);
    }
    }













Ans: 
Boolean class code uses equalsIgnoreCase method to validate the passed String, so if passed String is “true” (‘t’, ‘r’, ‘u’ and ‘e’ can be in any case), 
then boolean value stored in Boolean object is true otherwise false.
b1 stores true, b2 stores false, b3 stores false and as b4 is of reference type, hence it can store null as well.
Output is: true:false:false:null


19. What will be the result of compiling and executing Test class?
    public class Test {
	    private static void add(double d1, double d2) {
	    	System.out.println(“double version: ” + (d1 + d2));
	    }	
	    private static void add(Double d1, Double d2) {
	    	System.out.println(“Double version: ” + (d1 + d2));
	    }	
	    public static void main(String[] args) {
	    	add(10.0, null);
	    }
    }












Ans: 
add(10.0, null); => কম্পাইলার null কে double প্রিমিটিভ টাইপে রূপান্তর করতে পারে না। তাই দ্বিতীয় আর্গুমেন্টটি Double রেফারেন্স টাইপ হিসেবে ট্যাগ করা হয়।
ফলে, এই মেথড কলটিকে মেলানোর জন্য, 10.0 কে অটো-বক্সিংয়ের মাধ্যমে একটি Double অবজেক্টে রূপান্তরিত করা হয় এবং add(10.0, null); কে add(Double, Double); মেথড হিসেবে ট্যাগ করা হয়।
কিন্তু এক্সিকিউশনের সময়, d2 এর মান null হওয়ায় System.out.println("Double version: " + (d1 + d2)); একটি NullPointerException থ্রো করে।


20. What will be the result of compiling and executing Test class?
    public class Test {
    public static void main(String[] args) {
    Boolean [] arr = new Boolean[2];
    System.out.println(arr[0] + “:” + arr[1]);
    }
    }









Ans: 
অ্যারের উপাদানগুলো তাদের ডিফল্ট মান দিয়ে ইনিশিয়ালাইজ করা হয়।
arr একটি বুলিয়ান (Boolean) টাইপের অ্যারে নির্দেশ করছে, যা একটি রেফারেন্স টাইপ। তাই, অ্যারের উভয় উপাদান null দিয়ে ইনিশিয়ালাইজ করা হয়। আউটপুট হিসেবে null:null প্রিন্ট হবে।



21. What will be the result of compiling and executing Test class?
    public class Test {
    public static void main(String[] args) {
    Double [] arr = new Double[2];
    System.out.println(arr[0] + arr[1]);
    }
    }











Ans:
যেহেতু অ্যারের উপাদানগুলোকে নাল (null) হিসেবে ইনিশিয়ালাইজ করা হয়েছে, তাই arr[0] + arr[1] গণনা করতে গেলে জাভা রানটাইম এই এক্সপ্রেশনটিকে arr[0].doubleValue() + arr[1].doubleValue()-তে রূপান্তর করে।
যেহেতু arr[0] এবং arr[1] উভয়ই null, তাই doubleValue() পদ্ধতিটি কল করলে NullPointerException থ্রো করে।




22. What will be the result of compiling and executing Test class?
    public class Test {
    static Boolean[] arr = new Boolean[1];
    public static void main(String[] args) {
	    if(arr[0]) {
	    System.out.println(true);
    } else {
    	System.out.println(false);
    }}}














Ans: 
"অ্যারের সমস্ত উপাদান তাদের ডিফল্ট মান দিয়ে শুরু হয়। `arr` বুলিয়ান ধরনের (রেফারেন্স টাইপ), তাই `arr[0]` এর মান `null` দিয়ে শুরু হয়।
* `if` এক্সপ্রেশন বুলিয়ান ধরনের ভেরিয়েবলের সাথে কাজ করে, তাই `if(arr[0])` কম্পাইলেশন এরর তৈরি করে না। 
   কিন্তু জাভা রানটাইম `arr[0]`-এ থাকা বুলিয়ান মানটি বের করে আনার চেষ্টা করে এবং এর জন্য `booleanValue()` মেথডটি ব্যবহার করে।
* `arr[0].booleanValue()` এর অর্থ হলো `null` রেফারেন্সের উপর `booleanValue()` মেথডটি কল করা হচ্ছে। এর ফলস্বরূপ, রানটাইমে `NullPointerException` তৈরি হয়।"




23. What will be the result of compiling and executing Test class?
    public class Test {
	    public static void main(String[] args) {
		    Boolean b = new Boolean(“tRUe”);
		    switch(b) {
		    case true:
		    System.out.println(“ONE”);
		    case false:
		    System.out.println(“TWO”);
		    default:
		    System.out.println(“THREE”);
		    }
	    }
    }












Ans: 
Compilation error. switch does not accept Boolean, long, float, double






24. public class Test {
    public static void main(String[] args) {
    char c = ‘Z’;
    long l = 100_00l;
    int i = 9_2;
    float f = 2.02f;
    double d = 10_0.35d;
	    l = c + i;
	    f = c * l * i * f;
	    f = l + i + c;
	    i = (int)d;
	    f = (long)d;
    }
    }
    Does above code compile successfully?

















24.Ans: যখন আপনি বিভিন্ন নিউমেরিক টাইপের ভেরিয়েবল একসাথে কোনো গাণিতিক অপারেশনে (যেমন গুণ) ব্যবহার করেন, 
       তখন জাভা স্বয়ংক্রিয়ভাবে ছোট টাইপের ডেটাকে বড় টাইপের ডেটাতে রূপান্তর (type promotion) করে যাতে কোনো ডেটা লস না হয়। 
      এই প্রক্রিয়াটিকে "Widening Primitive Conversion" বলা হয়।
	       এখানে আপনার ভেরিয়েবলগুলো এবং তাদের টাইপগুলো হলো:
		c (char): 'Z' এর ASCII মান, যা একটি পূর্ণসংখ্যা (integer value)।
	        l (long): 100_00l (যা 10000L এর সমান)।
		i (int): 9_2 (যা 92 এর সমান)।
		f (float): 2.02f।
এখন, যখন f = c * l * i * f; এই এক্সপ্রেশনটি গণনা করা হয়, তখন জাভা প্রথমে বাম দিক থেকে গুণ করা শুরু করে:
c * l: c (char, যার মান ৯০) কে long এ পরিণত করা হয় (widening conversion)। ফলে ফলাফল হয় একটি long।
(c * l) * i: আগের long ফলাফলের সাথে i (int) গুণ করা হয়। এর ফলাফলও একটি long হয়।
(c * l * i) * f: আগের long ফলাফলের সাথে f (float) গুণ করা হয়। একটি long এবং একটি float গুণ করলে ফলাফল একটি float হয়।
-Yes, the above code compiles successfully.





25.What will be the result of compiling and executing Test class?
    public class Test {
	    public static void main(String[] args) {
		String [] arr = {“abc”, “TrUe”, “false”, null, “FALSE”};
		    for(String s : arr) {
		    System.out.print(Boolean.valueOf(s) ? “T” : “F”);
	            }
     	     }
    }












Ans:	চূড়ান্ত আউটপুট: F (abc) + T (TrUe) + F (false) + F (null) + F (FALSE) = FTFFF
	গুরুত্বপূর্ণ নোট:
	-Boolean.valueOf() মেথডটি কেস-ইনসেনসিটিভ, তাই "TrUe" বা "TRUE" সবই true হিসেবে বিবেচিত হয়।
	-null: ইনপুট স্ট্রিং null হলে, মেথডটি false রিটার্ন করে। ternary অপারেটরটি F প্রিন্ট করবে।



26.public class Test {
    public static void main(String[] args) {
    char c1 = ‘a’; //ASCII code of ‘a’ is 97
    int i1 = c1; //Line n1
    System.out.println(i1); //Line n2
    }
    }
    What is the result of compiling and executing Test class?
















Ans: 
97.( it prints char value and if int type value is passed, it prints int value.As i1 is of int type)



27. int x = 5____0;
    int y = ____50;
    int z = 50____;
    float f = 123.76_86f;
    double d = 1_2_3_4;
    How many statements are legal?















Ans: 
Three 5_0,  
float f = 123.76_86f;
double d = 1_2_3_4;



28. Range of short data type is from -32768 to 32767
    Which of the following code segments, written inside main method will compile successfully?
    Select ALL that apply.
      A-short s1 = 10;
      B-short s2 = 32768;
      C-final int i3 = 10; short s3 = i3;
      D-final int i4 = 40000; short s4 = i4;
      E-final int i5 = 10; short s5 = i5 + 100;
      F-final int m = 25000; final int n = 25000; short s6 = m + n;












Ans: A,C,E

29. What will be the result of compiling and executing DivModTest class?
    public class DivModTest {
    public static void main(String[] args) {
    System.out.println( 23 / 2.0 );
    System.out.println( 23 % 2.0 );
    }
    }











Ans: 
As floating point numbers are used in the expression, hence result should be in floating point number. Correct result is:23 / 2.0 = 11.5  and 23 % 2.0 = 1.0



30. What will be the result of compiling and executing Test class?
    public class Test {
    public static void main(String[] args) {
    int a = 7;
    boolean res = a++ == 7 && ++a == 9 || a++ == 9;
    System.out.println(“a = ” + a);
    System.out.println(“res = ” + res);
    }
    }














Ans: 
a = 9 res = true
a++ এই অংশটি কখনোই এক্সিকিউট হয় না, তাই a এর মান 9 থেকে আর বাড়ে না।


31. What will be the result of compiling and executing the Test class?
    public class Test {
    public static void main(String[] args) {
    int grade = 75;
    if(grade > 60)
    System.out.println(“Congratulations”);
    System.out.println(“You passed”);
    else
    System.out.println(“You failed”);
    }
    }
















Ans: 
Compilation error(There should not be anything between if-else block)














-
