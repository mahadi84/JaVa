11 August 2025


এক্সেপশন হ্যান্ডলিং করার সময় (try-catch ব্যবহার করে) কিভাবে মেসেজ পাস করবো এবং মেসেজ দেখাবো?

public static void main(String args[]){}
public static void main(String[] args){}
Same?

startsWith() মেথডটি কেস-সেনসিটিভ (Case Sensitive)?। হ্যাঁ, এটি বড় হাতের (uppercase) এবং ছোট হাতের (lowercase) অক্ষরকে আলাদা হিসেবে বিবেচনা করে।

অ্যারেতে ডেটা ইনসার্ট করার নিয়ম
একটি অ্যারেতে যখন আমরা ডেটা রাখি, তখন তা একটি নির্দিষ্ট ইনডেক্স নম্বর ব্যবহার করে করতে হয়। এই ইনডেক্সগুলি সাধারণত ০ থেকে শুরু হয়। 
আপনি যদি একটি খালি (নতুন তৈরি করা) অ্যারেতে x[1] ইনডেক্সে কোনো মান রাখতে চান, তাহলে জাভা এটি করতে দেবে। কিন্তু এখানে একটি বিষয় মনে রাখতে হবে:

নতুন অ্যারে: new int[10] এর মতো একটি নতুন অ্যারে তৈরি করলে, এর সব ইনডেক্সের ডিফল্ট মান (default value) ০ থাকে।
সরাসরি ইনসার্ট: আপনি সরাসরি x[1] = 5; লিখে মান ইনসার্ট করতে পারেন। এতে x[0] এর মান ০ থাকবে এবং x[1] এর মান ৫ হয়ে যাবে।

public static void main(String[] args) { args[0]="a"; System.out.println( args[0]);}
কেন এই ত্রুটি ঘটবে?
এই অ্যারেটি সাধারণত কমান্ড লাইন থেকে আর্গুমেন্ট (argument) নেওয়ার জন্য ব্যবহৃত হয়। 
যখন আপনি কোনো আর্গুমেন্ট ছাড়াই এই প্রোগ্রামটি রান করবেন, তখন args অ্যারেটি খালি থাকবে, অর্থাৎ এর সাইজ হবে শূন্য।
আপনার কোড args[0]="a"; লেখার মাধ্যমে আপনি অ্যারের প্রথম উপাদানে (ইনডেক্স 0) একটি মান রাখার চেষ্টা করছেন। 
কিন্তু যেহেতু অ্যারেটি খালি, সেখানে কোনো ইনডেক্স 0 নেই। তাই প্রোগ্রামটি একটি ArrayIndexOutOfBoundsException ত্রুটি দেখাবে।


up to q_7.












1. What does the code output?
int waitTime = 46;
try
{
System.out.println(“Try block entered.”);
if (waitTime> 30)
throw new Exception(“Time Limit Exceeded.”);
System.out.println(“Leaving try block.”);
}
catch(Exception e)
{
System.out.println(“Exception: ” + e.getMessage());
}
System.out.println(“After catch block.”);

 Try block entered. Exception: Time Limit Exceeded. After catch block.
 block entered. After catch block.
 Try block entered. Leaving try block. After catch block.
 Will not compile



Explanation:
* প্রথমে, `try` ব্লকে প্রবেশ করার পর "Try block entered." প্রিন্ট হবে।
* তারপর, `if (waitTime > 30)` শর্তটি সত্য হবে কারণ `waitTime` এর মান 46।
* শর্তটি সত্য হওয়ায় একটি `Exception` throw করা হবে "Time Limit Exceeded." মেসেজ সহ।
* `try` ব্লক থেকে বেরিয়ে `catch` ব্লকে যাবে এবং `Exception`টি ধরা হবে।
* `catch` ব্লকে "Exception: " এর সাথে `Exception` এর মেসেজটি ("Time Limit Exceeded.") প্রিন্ট করা হবে।
* সবশেষে, `catch` ব্লক থেকে বেরিয়ে আসার পর "After catch block." প্রিন্ট হবে।
এই কোডটির আউটপুট হবে "Try block entered. Exception: Time Limit Exceeded. After catch block."।



2.Which of the following can fill in the blanks to make this code compile?
__________ d = _________ new (10_000_.00);

 double, Double
 Double, Double
 double, double
 None of these can make the code compiled 


Explanation:
last


3.What is the output of this program?
public static void main(String args[]){
String s = “Hello Java!”;
boolean bool;
bool = s.startsWith(“hel”);
System.out.println(bool);
}

 TRUE
 FALSE
 Code has compilation error
 Code will compile, but throws an exception at runtime


Explanation:
প্রথম পদ্ধতিটি, `String[] args`, বেশি প্রচলিত এবং পছন্দনীয় কারণ এটি টাইপ ইনফরমেশনকে একসাথে রাখে (`String[]` মানে হলো স্ট্রিং-এর একটি অ্যারে)। 
তবে, কার্যকারিতার দিক থেকে দুটিই একই এবং দুটোতেই কোড কম্পাইল ও রান করবে।

* `public static void main(String[] args)`
* `public static void main(String args[])`



4.In the below code, which Java code should be in the indicated line so that the output will be  “99NN 99NN”?
StringBuilder myString = new StringBuilder(“99”);
String s = “99”;

//insert code here

System.out.println(myString + ” ” + s);

 myString.append("NN"); s = s.concat("NN");
 myString.append("NN"); s = s.append("NN");
 myString.append("NN"); s.myString;
 myString.concat("NN"); s = s.concat("NN");


Explanation:
a


5.What is the output of the following application?
package ballroom;
public class Dance {
public static void swing(int… beats) throws ClassCastException {
try {
System.out.print(“1″+beats[2]); // p1
} catch (RuntimeException e) {
System.out.print(“2”);
} catch (Exception e) {
System.out.print(“3”);
} finally {
System.out.print(“4”);
}
}
public static void main(String… music) {
new Dance().swing(0,0); // p2
System.out.print(“5”);
}
}

 145
 1045
 24, followed by a stack trace
 245
 The code does not compile because of line p1.
 The code does not compile because of line p2.


Explanation:
try ব্লকে, System.out.print(“1″+beats[2]); লাইনটি চালানো হয়। এখানে beats[2] অ্যাক্সেস করার চেষ্টা করা হচ্ছে, কিন্তু অ্যারেতে শুধুমাত্র দুটি উপাদান আছে (beats[0] এবং beats[1])। 
তাই IndexOutOfBoundsException ঘটবে, যা RuntimeException-এর একটি সাবক্লাস।
আউটপুট হবে 245।


6.Which code in following would produce output 3  3? 
public class testMimi {
public static void foo(int[] x) {
x[1] +=3 ;
}
public static void main(String[] args) {

int[] a = new int[10];
int[] b = a;
foo(a);

// code goes here
}
}

 System.out.println(a[0] + " " + b[0]); 
 System.out.println(a[1] + " " + b[2]); 
 System.out.println(a[1] + " " + b[1]); 
 System.out.println(a[2] + " " + b[2]); 


Explanation:
* `int[] b = a;` লাইনের কারণে `a` এবং `b` উভয় ভেরিয়েবল একই অ্যারে রেফার করে।
* `foo(a);` কল করার পর অ্যারের দ্বিতীয় উপাদান (`a[1]`) এর মান `0 + 3 = 3` হয়।
* যেহেতু `b` এবং `a` একই অ্যারে নির্দেশ করে, তাই `b[1]` এর মানও `3` হয়।
* সুতরাং, `a[1]` এবং `b[1]` উভয়ই `3` হবে, এবং আউটপুট হবে `3 3`।
`System.out.println(a[1] + " " + b[1]);`


7.What is the output of the following code?
abstract class Bee {
protected static String place = “Cyprus”;
public Bee() {}
public Bee(String place) {this.place = place;}
}

public class Insect extends Bee {
public static String place = “Canada”;
public String getplace() {return super.place;}
public static void main(String[] args) {
System.out.print(new Insect().getplace()); }
}

 Canada
 Compilation error
 Cyprus


Explanation:
Insect ক্লাসের main মেথডে new Insect() ব্যবহার করে একটি নতুন অবজেক্ট তৈরি করা হয়েছে। এই অবজেক্ট তৈরির সময় Insect ক্লাসের কোনো কনস্ট্রাক্টর না থাকায়, 
জাভা স্বয়ংক্রিয়ভাবে ডিফল্ট কনস্ট্রাক্টর (public Insect(){}) ব্যবহার করে।
Insect একটি Bee এর সাবক্লাস হওয়ায়, new Insect() কলটি পরোক্ষভাবে Bee ক্লাসের ডিফল্ট কনস্ট্রাক্টরকে (public Bee() {}) কল করে।

স্বয়ংক্রিয়ভাবে তৈরি হওয়া ডিফল্ট কনস্ট্রাক্টর::
যদি একটি চাইল্ড ক্লাসে আপনি কোনো কনস্ট্রাক্টর তৈরি না করেন, তাহলে জাভা কম্পাইলার স্বয়ংক্রিয়ভাবে তার জন্য একটি ডিফল্ট নো-আর্গুমেন্ট কনস্ট্রাক্টর তৈরি করে দেয়। 
এই ডিফল্ট কনস্ট্রাক্টরটি প্রথমে তার প্যারেন্ট ক্লাসের নো-আর্গুমেন্ট কনস্ট্রাক্টরকে super() কল করে।

class Parent {
    public Parent(String name) {
        System.out.println("প্যারেন্টের আর্গ কনস্ট্রাক্টর কল করা হয়েছে: " + name);
    }
}
class Child extends Parent {
    // কম্পাইলার এখানে একটি ডিফল্ট কনস্ট্রাক্টর যোগ করার চেষ্টা করে:
    // public Child() {
    //     super(); // এই কলটি ব্যর্থ হবে, কারণ প্যারেন্টে কোনো নো-আর্গ কনস্ট্রাক্টর নেই
    //     super('abc'); // successfull call
    // }
}


8.What is the output of this program?
public static void main(String args[]) {
boolean b1 = false;
boolean b2 = true;
if (b2)
System.out.println(!b1);
else
System.out.println(b1);
}

 TRUE
 FALSE
 Compilation error


Explanation:
b1 = false. So, !b1 = true. In Java ! is used as NOT operator.


9.How will you call a default method of an interface in a class?

  Using this keyword along with the interface
  Using name of the interface
 Using super keyword along with interface name
 default method can not be called in interface 


Explanation:
যখন একটি ক্লাস কোনো ইন্টারফেসের একটি ডিফল্ট মেথডকে ওভাররাইড করে, কিন্তু সেই ওভাররাইড করা মেথডের ভেতর থেকে ইন্টারফেসের মূল ডিফল্ট মেথডটিকে কল করতে চায়, 
তখন super কীওয়ার্ড ব্যবহার করা হয়। এর জন্য সিনট্যাক্সটি হলো:
InterfaceName.super.methodName();
সঠিক উত্তরটি হলো Using super keyword along with interface name।


10.What is the result of the following code?
public static void main(String[] args) {
do {
String s = ” “;
do {
s = “Hi”;
} while (s.equals(“Hi”));

} while (true);
}

 The will not compile
 Hi
 The code will compile but throws an exception at runtime
 The loop will continue forever



Explanation:
In the inner do statement, s = hi and test condition is also s = Hi. So loop will run forever.


11.What is the output of the following?
List continent = Arrays.asList(“Canada”, “USA”, “Mexico”);
for (int i = 0; i < continent.size(); i++) System.out.print(continent.get(i) + " ");

 2000 1 2
 Canada  
 Canada  USA  Mexico
 Compilation error


Explanation:
c


12.Given the application below and the choices available, which lines must all be removed to
allow the code to compile? (Choose three.)
1: package year;
2: public class Seasons {
3: public static void main(String[] time) {
4: final long winter = 10;
5: final byte season = 2;
6: int fall = 4;
7: final short summer = 3;
8: switch(season) {
9: case 1:
10: case winter: System.out.print(“winter”);
11: default:
12: case fall: System.out.print(“fall”);
13: case summer: System.out.print(“summer”);
14: default:
15: }
16: }
17: }

 Line 8
 Line 9
 Line 10
 Line 11
 Line 12
 Line 13


Explanation:
1.  Line 10 (`case winter:`): `winter` ভেরিয়েবলটি `long` টাইপের, যা `switch` স্টেটমেন্টের `byte` টাইপের `season` ভেরিয়েবলের সাথে সামঞ্জস্যপূর্ণ নয়। 
     `case` লেবেলে শুধুমাত্র কনস্ট্যান্ট এক্সপ্রেশন ব্যবহার করা যায় যা `switch` ভেরিয়েবলের টাইপের সাথে সামঞ্জস্যপূর্ণ।
2.  Line 11 (`default:`): একটি `switch` স্টেটমেন্টে শুধুমাত্র একটি `default` লেবেল থাকতে পারে। যেহেতু Line 14-তেও একটি `default` লেবেল আছে, তাই এটি একটি কম্পাইলেশন এরর তৈরি করে।
3.  Line 12 (`case fall:`): `case` লেবেলে ব্যবহৃত ভেরিয়েবলকে অবশ্যই একটি কম্পাইল-টাইম কনস্ট্যান্ট (`final`) হতে হবে। এখানে `fall` ভেরিয়েবলটি `final` নয়।


13.What is the output of the following?
List drinks = Arrays.asList(“can”, “cup”);
for (int container = drinks.size(); container > 0; container++) {
System.out.print(drinks.get(container-1) + “,”);
}

 can,cup,
 cup,can,
 The code does not compile.
 This is an infinite loop.
 The code compiles but throws an exception at runtime.


Explanation:


14.Which of the following has syntax error? (select two)
 String [] c;  c = {"I", "am", "the", "walrus"}; 
 int[] a = new int[50]; 
 double[] a = {0, 2, 4, 8, 10};  
 String[] c = {"I", "am", "the", "walrus"}; 
 String[] c = {1, 5, 2, 8, 0}; 



Explanation:
আপনি একইসাথে অ্যারে ডিক্লেয়ার এবং মান অ্যাসাইন করতে পারেন কার্লি ব্র্যাকেট {} ব্যবহার করে। কিন্তু, যদি আপনি শুধু ডিক্লেয়ার করেন এবং পরে মান অ্যাসাইন করতে চান, 
তাহলে আপনাকে অবশ্যই new কীওয়ার্ড ব্যবহার করতে হবে।

উদাহরণস্বরূপ:
একই লাইনে: int[] numbers = {1, 2, 3, 4, 5};
আলাদা লাইনে: int[] numbers; numbers = new int[]{1, 2, 3, 4, 5};
স্ট্রিং অ্যারের ক্ষেত্রে, প্রতিটি মান অবশ্যই কোটেশন চিহ্নের " " মধ্যে থাকতে হবে। যেমন, "1"।



15.What does the line 3 mean in the following code?
int[][] b;
b = new int[3][];
b[0] = new int[5];

 First row takes 5 as its element 
 First row takes 6 elements
 First row takes 4 elements
 First row takes 5 elements


Explanation:
`b[0] = new int[5];` লাইনটির মানে হলো প্রথম সারি 5টি উপাদান নেয়।
* `int[][] b;` লাইনটি একটি দ্বি-মাত্রিক অ্যারে ডিক্লেয়ার করে।
* `b = new int[3][];` লাইনটি ৩টি সারির জন্য মেমরি বরাদ্দ করে, কিন্তু প্রতিটি সারির দৈর্ঘ্য তখনো নির্দিষ্ট করা হয়নি।
* `b[0] = new int[5];` লাইনটি `b` অ্যারের প্রথম সারিটিকে (যার ইনডেক্স 0) একটি নতুন অ্যারে হিসেবে তৈরি করে, যা 5টি পূর্ণসংখ্যা (integer) ধারণ করতে পারে।
* সুতরাং, এই লাইনটি প্রথম সারির দৈর্ঘ্য 5 নির্ধারণ করে।
ans: 4


16.Which of the statements are true? 

 The javac command cannot compile directly into native machine code
 Java is not object oriented.
 The java command can execute .java file
 Compilers translate source code into object code


Explanation:
1,4


17.How many times does this code print true?
System.out.println(new StringBuilder(“zelda”)== new StringBuilder(“zelda”));
System.out.println(3 == 3);
System.out.println(“bart” == “bart”);
System.out.println(new int[0] == new int[0]);
System.out.println(LocalTime.now() == LocalTime.now());


 None
 One
 Two
 Three
 The code does not compile.


Explanation:
1.  `new StringBuilder("zelda") == new StringBuilder("zelda")`: `==` অপারেটর এখানে দুটি আলাদা অবজেক্টের মেমরি রেফারেন্স তুলনা করছে, যা ভিন্ন। তাই এটি `false` প্রিন্ট করবে।
2.  `3 == 3`: দুটি একই `int` প্রিমিটিভ মান তুলনা করা হচ্ছে। তাই এটি `true` প্রিন্ট করবে।
3.  `"bart" == "bart"`: জাভা স্ট্রিং পুলিং এর কারণে দুটি একই স্ট্রিং লিটারাল একই মেমরি রেফারেন্স নির্দেশ করে। তাই এটি `true` প্রিন্ট করবে।
4.  `new int[0] == new int[0]`: দুটি আলাদা অ্যারে অবজেক্টের মেমরি রেফারেন্স ভিন্ন। তাই এটি `false` প্রিন্ট করবে।
5.  `LocalTime.now() == LocalTime.now()`: `LocalTime.now()` প্রতিবার একটি নতুন অবজেক্ট তৈরি করে। তাই এদের রেফারেন্স ভিন্ন হবে এবং এটি `false` প্রিন্ট করবে।
দুই (Two) বার `true` প্রিন্ট হবে।


18.What is the interface of a Java class ? 

 private stuff + method bodies + comments inside methods.
 public instance variables + public method headers + JavaDoc comments
 private instance variables + method bodies + JavaDoc comments
 None of the above


Explanation:
কোনো জাভা ক্লাসের ইন্টারফেস বলতে বোঝানো হয় সেই ক্লাসের পাবলিক চুক্তিকে, যা অন্য ক্লাসগুলো সেই ক্লাসের সাথে যোগাযোগ বা মিথস্ক্রিয়া করার জন্য ব্যবহার করে। এই চুক্তির মধ্যে রয়েছে:
* পাবলিক ইনস্ট্যান্স ভেরিয়েবলস (Public instance variables): ক্লাসের যেকোনো ডেটা মেম্বার যা সরাসরি অ্যাক্সেস করা যায়।
* পাবলিক মেথড হেডার্স (Public method headers): মেথড সিগনেচার (নাম, রিটার্ন টাইপ এবং প্যারামিটার) যা নির্ধারণ করে কীভাবে ক্লাসের মেথডগুলোকে কল করতে হবে। 
                        মেথডের মূল বডি (implementation) ইন্টারফেসের অংশ নয়।
* জাভাডক কমেন্টস (JavaDoc comments): পাবলিক মেথড এবং ভেরিয়েবল ডকুমেন্ট করার জন্য এগুলো খুবই গুরুত্বপূর্ণ। 
                  এগুলো বর্ণনা করে যে ক্লাসের মেথড ও ভেরিয়েবলগুলোর উদ্দেশ্য কী এবং কীভাবে সেগুলো ব্যবহার করা উচিত।
                 জাভাডক কমেন্টসকে পাবলিক ইন্টারফেসের একটি অবিচ্ছেদ্য অংশ হিসেবে ধরা হয়।


19.Which of the following will generate random numbers between 0 to 100?

  (int) (Math.random() * 100); 
 (int) (Math.random() * 101); 
 (int) (Math.random() * 1 + 100); 
 (int) (Math.random() * 1 + 101); 


Explanation:

* `Math.random()` মেথডটি `0.0` (অন্তর্ভুক্ত) থেকে `1.0` (বহির্ভূত) এর মধ্যে একটি `double` টাইপের র্যান্ডম সংখ্যা তৈরি করে।
* `Math.random() * 101` এর মান `0.0` থেকে `100.999...` এর মধ্যে হবে।
* যখন এই মানটিকে `(int)` দ্বারা টাইপকাস্ট করা হয়, তখন দশমিকের পরের অংশ বাদ পড়ে যায়। ফলে, পূর্ণসংখ্যা হিসেবে `0` থেকে `100` পর্যন্ত যেকোনো মান পাওয়া সম্ভব।
* অন্যান্য বিকল্পগুলো ভুল কারণ:
    * `(int) (Math.random() * 100);` ব্যবহার করলে মান `0` থেকে `99` পর্যন্ত হবে, কারণ `Math.random() * 100` এর সর্বোচ্চ মান `99.999...` হবে।
    * বাকি অপশনগুলো ভুলভাবে সংখ্যা তৈরি করবে।
সঠিক উত্তরটি হলো `(int) (Math.random() * 101);`।


20.Which of the following code-blocks validates the user input between 10 and 100?
 int number = sc.nextInt(); do { number = sc.nextInt(); if (number < 10 || number > 100) { System.err.println("Invalid range."); } } while (number < 10 || number > 100);
 int number = sc.nextInt(); do { number = sc.nextInt(); System.err.println("Invalid range."); } while (number < 10 || number > 100);
 int number = sc.nextInt(); do { number = sc.nextInt(); if (number < 10 || number > 100) { System.err.println("Invalid range."); } } while (number < 10 && number > 100);
 None of the above


Explanation:
// একটি পূর্ণসংখ্যা (integer) ইনপুট নিন
int number = sc.nextInt();
do {
    // লুপের ভেতরে আবার একটি পূর্ণসংখ্যা ইনপুট নিন
    number = sc.nextInt();
    // যদি সংখ্যাটি 10-এর কম বা 100-এর বেশি হয়
    if (number < 10 || number > 100) {
        // তাহলে একটি ভুল বার্তা (error message) প্রিন্ট করুন
        System.err.println("Invalid range.");
    }
} while (number < 10 || number > 100); // যদি সংখ্যাটি 10-এর কম বা 100-এর বেশি হয়, তাহলে লুপটি চলতে থাকবে।


21.Which code will print “APPLE” from the given array?
String[] k = {“apple”, “kiwi”, “mango”}; 

 System.out.println(k[0].toUpper()); 
 System.out.println(k[1].toUpper()); 
 System.out.println(k[1].toUpperCase()); 
 System.out.println(k[0].toUpperCase()); 


Explanation:
last


22.Which of the following is primitive?
public static void main(String[] args){
int[] mango = new int[0];
Integer[] grape = new Integer[0]; }

 mango
 grape
 Both mango and grape
 Neither mango nor grape



Explanation:
int একটি প্রিমিটিভ টাইপ হলেও, সব অ্যারে হলো অবজেক্ট।
এর কারণ হলো:
* একটি অ্যারের `length` নামে একটি পাবলিক ইনস্ট্যান্স ভেরিয়েবল আছে।
* আপনি একটি অ্যারে ভেরিয়েবলকে `Object` টাইপের একটি ভেরিয়েবলের মধ্যে অ্যাসাইন করতে পারেন।
এই দুটি বৈশিষ্ট্যই প্রমাণ করে যে অ্যারে জাভাতে অবজেক্ট হিসেবে কাজ করে।


23.Given the following code, which option, if used to replace //INSERT CODE HERE, will correctly calculate the sum of all the even numbers in the array num and store it in the variable sum? 
int num[] = {80, 15, 2, 18, 17};
int sum = 0;
for (int number : num) {

//INSERT CODE HERE

sum += number;
}

 if (number % 2 == 0) break;
 if (number % 2 == 0) continue;
 if (number % 2 != 0) break;
 if (number % 2 != 0) continue;


Explanation:
if (number % 2 != 0) শর্তটি পরীক্ষা করে যে বর্তমান সংখ্যাটি বিজোড় (odd) কি না।
যদি সংখ্যাটি বিজোড় হয়, continue স্টেটমেন্টটি লুপের বর্তমান ইটারেশনটি (iteration) বাদ দিয়ে পরবর্তী সংখ্যায় চলে যাবে।
যদি সংখ্যাটি জোড় হয়, if শর্তটি মিথ্যা হবে এবং continue কার্যকর হবে না। ফলে, sum += number; লাইনটি চলবে এবং সংখ্যাটি sum-এর সাথে যোগ হবে।
এইভাবে, শুধুমাত্র জোড় সংখ্যাগুলোই sum-এর সাথে যোগ হবে।


24.Given the following code, which option, if used to replace //INSERT CODE HERE, will make the code print numbers that are completely  divisible  by  10? 
for (int c = 2; c <= 30; ++c) { 
    if (c % 5 != 0)
    //INSERT CODE HERE 
    if (c % 10 == 0) System.out.println( c );
}

 break;
 continue;
 exit;
 through;


Explanation:
কোডটি 2 থেকে 30 পর্যন্ত সংখ্যাগুলো পরীক্ষা করছে।
if (c % 5 != 0) শর্তটি পরীক্ষা করে যে সংখ্যাটি 5 দ্বারা বিভাজ্য কি না।
যদি সংখ্যাটি 5 দ্বারা বিভাজ্য না হয় (যেমন, 2, 3, 4, 6, 7, ...), তাহলে if শর্তটি সত্য হয় এবং continue; স্টেটমেন্টটি লুপের বর্তমান ইটারেশনটি (iteration) বাদ দিয়ে পরবর্তী সংখ্যায় চলে যায়। এর ফলে if (c % 10 == 0) লাইনটি কার্যকর হয় না।
যদি সংখ্যাটি 5 দ্বারা বিভাজ্য হয় (যেমন, 10, 15, 20, 25, 30), তাহলে if শর্তটি মিথ্যা হয়। continue; স্টেটমেন্টটি কার্যকর হয় না, এবং পরবর্তী লাইন if (c % 10 == 0) পরীক্ষা করা হয়। এই লাইনটি শুধুমাত্র সেই সংখ্যাগুলো প্রিন্ট করবে যা 10 দ্বারা বিভাজ্য।
এভাবে, শুধুমাত্র 10, 20 এবং 30 প্রিন্ট হবে।


25.Which of the following modifiers cannot be applied to the abstract class? 

 static
 protected
 final
 public

Explanation:
c

