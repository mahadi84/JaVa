 10 August 2025


ржкрж░рзАржХрзНрж╖рж╛ржпрж╝ ржПржЗ ржзрж░ржирзЗрж░ ржкрзНрж░рж╢рзНржиржЧрзБрж▓рзЛрж░ ржЙрждрзНрждрж░ ржжрзЗржУржпрж╝рж╛рж░ рж╕ржоржпрж╝ ржХрж┐ржЫрзБ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг ржмрж┐рж╖ржпрж╝ ржорж╛ржерж╛ржпрж╝ рж░рж╛ржЦрж╛ ржЬрж░рзБрж░рж┐:

1.  **ржХрзЛржбржЯрж┐ ржХржорзНржкрж╛ржЗрж▓ рж╣ржмрзЗ ржХрж┐ ржирж╛ рждрж╛ ржкрзНрж░ржержорзЗ ржжрзЗржЦрзБржи:** ржкрзНрж░рж╢рзНржиржЧрзБрж▓рзЛрж░ ржПржХржЯрж┐ ржмржбрж╝ ржЕржВрж╢ ржерж╛ржХрзЗ ржХржорзНржкрж╛ржЗрж▓рзЗрж╢ржи ржПрж░рж░ (compilation error) ржирж┐ржпрж╝рзЗред рждрж╛ржЗ, ржХрзЛржбржЯрж┐ рж▓рж╛ржЗржи ржмрж╛ржЗ рж▓рж╛ржЗржи ржкржбрж╝рзЗ ржЬрж╛ржнрж╛рж░ рж╕рж┐ржиржЯрзНржпрж╛ржХрзНрж╕ (syntax) ржмрж╛ ржирж┐ржпрж╝ржо ржЕржирзБржпрж╛ржпрж╝рзА ржХрзЛржирзЛ ржнрзБрж▓ ржЖржЫрзЗ ржХрж┐ ржирж╛ рждрж╛ ржкрзНрж░ржержорзЗ ржпрж╛ржЪрж╛ржЗ ржХрж░рзБржиред
    * `static`, `final`, `private` ржЗрждрзНржпрж╛ржжрж┐ ржоржбрж┐ржлрж╛ржпрж╝рж╛рж░ржЧрзБрж▓рзЛ ржХрзЛржерж╛ржпрж╝ ржПржмржВ ржХрзАржнрж╛ржмрзЗ ржмрзНржпржмрж╣рзГржд рж╣ржпрж╝рзЗржЫрзЗ рждрж╛ ржжрзЗржЦрзБржиред
    * ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ рж╕рзНржХрзЛржк (variable scope) ржПржмржВ ржЗржирж╣рзЗрж░рж┐ржЯрзНржпрж╛ржирзНрж╕рзЗрж░ ржирж┐ржпрж╝ржо (ржпрзЗржоржи: ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ ржЗржирж╣рзЗрж░рж┐ржЯ рж╣ржпрж╝ ржирж╛) ржнрж╛рж▓рзЛржнрж╛ржмрзЗ ржоржирзЗ рж░рж╛ржЦрзБржиред
    * ржЕржкрж╛рж░рзЗржЯрж░ржжрзЗрж░ ржЕржЧрзНрж░рж╛ржзрж┐ржХрж╛рж░ (precedence) ржПржмржВ ржЕрзНржпрж╛рж╕рзЛрж╕рж┐ржпрж╝рзЗржЯрж┐ржнрж┐ржЯрж┐ (associativity) рж╕ржорзНржкрж░рзНржХрзЗ рж╕рзНржкрж╖рзНржЯ ржзрж╛рж░ржгрж╛ рж░рж╛ржЦрзБржи (ржпрзЗржоржи: `30/2*5%4` ржПрж░ ржорждрзЛ рж╕ржорж╕рзНржпрж╛ рж╕ржорж╛ржзрж╛ржирзЗрж░ ржЬржирзНржп)ред
    * ржХрзЛржи ржЕржкрж╛рж░рзЗржЯрж░ ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ рждрж╛ ржмрзБржЭрзБржи (ржпрзЗржоржи: `==` рж░рзЗржлрж╛рж░рзЗржирзНрж╕ рждрзБрж▓ржирж╛ ржХрж░рзЗ, ржЖрж░ `equals()` ржХржирзНржЯрзЗржирзНржЯ рждрзБрж▓ржирж╛ ржХрж░рзЗ)ред

2.  **рж▓ржЬрж┐ржХ ржмрж╛ ржпрзБржХрзНрждрж┐ ржЕржирзБрж╕рж░ржг ржХрж░рзБржи:** ржпржжрж┐ ржХрзЛржбржЯрж┐ ржХржорзНржкрж╛ржЗрж▓ рж╣ржпрж╝, рждржмрзЗ рж▓рзБржк, ржХржирзНржбрж┐рж╢ржирж╛рж▓ рж╕рзНржЯрзЗржЯржорзЗржирзНржЯ (if-else), ржПржмржВ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ ржорж╛ржи ржХрзАржнрж╛ржмрзЗ ржкрж░рж┐ржмрж░рзНрждрж┐ржд рж╣ржЪрзНржЫрзЗ рждрж╛рж░ ржПржХржЯрж┐ ржорж╛ржирж╕рж┐ржХ ржмрж╛ ржХрж╛ржЧржЬрзЗ-ржХрж▓ржорзЗ ржЯрзНрж░рзЗрж╕рж┐ржВ (tracing) ржХрж░рзБржиред
    * рж▓рзБржкрзЗрж░ рж╢рж░рзНржд (`while`, `for`) ржХржЦржи рж╕рждрзНржп ржмрж╛ ржорж┐ржерзНржпрж╛ рж╣ржЪрзНржЫрзЗ рждрж╛ ржЦрзЗрзЯрж╛рж▓ ржХрж░рзБржиред
    * ржХрзЛржи ржорзЗржержб ржХржЦржи ржХрж▓ рж╣ржЪрзНржЫрзЗ ржПржмржВ ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░ржЧрзБрж▓рзЛ ржХрзАржнрж╛ржмрзЗ ржкрж╛рж╕ рж╣ржЪрзНржЫрзЗ рждрж╛ ржмрзБржЭрзБржиред
    * рж▓ржЬрж┐ржХрзНржпрж╛рж▓ ржЕржкрж╛рж░рзЗржЯрж░ (`&&`, `||`) ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ рждрж╛ ржЬрж╛ржирзБржиред `&&` рж╢рж░рзНржЯ-рж╕рж╛рж░рзНржХрж┐ржЯ (short-circuit) ржХрж░рзЗ, ржЖрж░ `||` ржУ ржПржХржЗ ржХрж╛ржЬ ржХрж░рзЗред

3.  **ржмрзНржпрждрж┐ржХрзНрж░ржо (Exceptions) рж╕ржорзНржкрж░рзНржХрзЗ рж╕ржЪрзЗрждржи ржерж╛ржХрзБржи:** ржХржЦржи ржПржХржЯрж┐ ржХрзЛржб рж░рж╛ржиржЯрж╛ржЗржо ржмрзНржпрждрж┐ржХрзНрж░ржо (runtime exception) рждрзИрж░рж┐ ржХрж░рждрзЗ ржкрж╛рж░рзЗ рждрж╛ ржнрж╛рж▓рзЛржнрж╛ржмрзЗ ржмрзБржЭрзБржиред
    * `ArrayIndexOutOfBoundsException`: ржЕрзНржпрж╛рж░рзЗрж░ рж╕рзАржорж╛рж░ ржмрж╛ржЗрж░рзЗ ржХрзЛржирзЛ ржЗржиржбрзЗржХрзНрж╕ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржХрж░рж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рж▓рзЗ ржПржЯрж┐ ржШржЯрзЗред
    * `NullPointerException`: ржХрзЛржирзЛ `null` ржЕржмржЬрзЗржХрзНржЯрзЗрж░ ржУржкрж░ ржорзЗржержб ржХрж▓ ржХрж░рж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рж▓рзЗ ржПржЯрж┐ ржШржЯрзЗред
    * ржЗржирж╣рзЗрж░рж┐ржЯрзНржпрж╛ржирзНрж╕рзЗрж░ ржХрзНрж╖рзЗрждрзНрж░рзЗ `catch` ржмрзНрж▓ржХрзЗрж░ ржХрзНрж░ржо (order) ржЦрзБржмржЗ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржгред рж╕рж╛ржмржХрзНрж▓рж╛рж╕рзЗрж░ ржмрзНржпрждрж┐ржХрзНрж░ржоржХрзЗ рж╕рзБржкрж╛рж░ржХрзНрж▓рж╛рж╕рзЗрж░ ржмрзНржпрждрж┐ржХрзНрж░ржорзЗрж░ `catch` ржмрзНрж▓ржХрзЗрж░ ржЖржЧрзЗ ржерж╛ржХрждрзЗ рж╣ржмрзЗред

---

### ржЙрждрзНрждрж░ ржжрзЗржУржпрж╝рж╛рж░ ржХрзМрж╢рж▓ (Answering Strategy) ЁЯОп

* **ржзрж╛ржк 1: ржХржорзНржкрж╛ржЗрж▓рзЗрж╢ржи ржПрж░рж░ ржЪрзЗржХ ржХрж░рзБржи:** ржкрзНрж░ржержорзЗ ржкрзНрж░рждрж┐ржЯрж┐ рж▓рж╛ржЗржи ржжрзЗржЦрзБржи ржПржмржВ ржЬрж╛ржнрж╛рж░ ржХржорзНржкрж╛ржЗрж▓рж╛рж░рзЗрж░ ржжрзГрж╖рзНржЯрж┐ржХрзЛржг ржерзЗржХрзЗ ржХрзЛржирзЛ ржнрзБрж▓ ржЖржЫрзЗ ржХрж┐ ржирж╛ рждрж╛ ржЪрж┐рж╣рзНржирж┐ржд ржХрж░рзБржиред ржпрзЗржоржи: `2:00` ржмрж╛ `OR` ржПрж░ ржмрзНржпржмрж╣рж╛рж░ред ржпржжрж┐ ржХржорзНржкрж╛ржЗрж▓рзЗрж╢ржи ржПрж░рж░ ржерж╛ржХрзЗ, рждржмрзЗ ржЕржирзНржп ржХрзЛржирзЛ ржЕржкрж╢ржи ржжрзЗржЦрж╛рж░ ржжрж░ржХрж╛рж░ ржирзЗржЗ, рж╕рзЗржЯрж┐ржЗ ржЙрждрзНрждрж░ред
* **ржзрж╛ржк 2: рж▓ржЬрж┐ржХрзНржпрж╛рж▓ ржлрзНрж▓рзЛ ржЯрзНрж░рзЗрж╕ ржХрж░рзБржи:** ржпржжрж┐ ржХрзЛржирзЛ ржХржорзНржкрж╛ржЗрж▓рзЗрж╢ржи ржПрж░рж░ ржирж╛ ржерж╛ржХрзЗ, рждржмрзЗ ржХрзЛржбржЯрж┐ ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ рждрж╛ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ ржЕржирзБрж╕рж░ржг ржХрж░рзБржиред ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ ржорж╛ржи ржкрж░рж┐ржмрж░рзНрждржи, рж▓рзБржкрзЗрж░ ржкрзБржирж░рж╛ржмрзГрждрзНрждрж┐, ржПржмржВ ржХрзЛржи ржХрзЛржб ржмрзНрж▓ржХ ржХрж╛рж░рзНржпржХрж░ рж╣ржЪрзНржЫрзЗ рждрж╛ ржоржирзЛржпрзЛржЧ ржжрж┐рзЯрзЗ ржжрзЗржЦрзБржиред
* **ржзрж╛ржк 3: ржЖржЙржЯржкрзБржЯ ржмрж╛ ржлрж▓рж╛ржлрж▓ ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рзБржи:** ржХрзЛржбрзЗрж░ ржПржХрзНрж╕рж┐ржХрж┐ржЙрж╢ржи рж╢рзЗрж╖ рж╣ржУрзЯрж╛рж░ ржкрж░ ржХрзА ржкрзНрж░рж┐ржирзНржЯ рж╣ржмрзЗ ржмрж╛ ржХрзА ржлрж▓рж╛ржлрж▓ ржЖрж╕ржмрзЗ рждрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзБржиред `System.out.println` ржмрж╛ `System.out.print` рж╕рзНржЯрзЗржЯржорзЗржирзНржЯржЧрзБрж▓рзЛ ржХрзА ржлрж▓рж╛ржлрж▓ ржжрзЗржмрзЗ рждрж╛ ржмрзБржЭрзБржиред
* **ржзрж╛ржк 4: ржмрж┐ржХрж▓рзНржкржЧрзБрж▓рзЛ ржпрж╛ржЪрж╛ржЗ ржХрж░рзБржи:** ржЖржкржирж╛рж░ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрж░рж╛ ржлрж▓рж╛ржлрж▓рзЗрж░ рж╕рж╛ржерзЗ ржжрзЗржУржпрж╝рж╛ ржмрж┐ржХрж▓рзНржкржЧрзБрж▓рзЛ ржорж┐рж▓рж┐рзЯрзЗ ржжрзЗржЦрзБржиред ржкрзНрж░рж╛ржпрж╝рж╢ржЗ, ржПржХржЯрж┐ ржмрж┐ржХрж▓рзНржк ржЖржкржирж╛рж░ рж╕ржарж┐ржХ ржлрж▓рж╛ржлрж▓рзЗрж░ рж╕рж╛ржерзЗ ржорж┐рж▓рзЗ ржпрж╛ржмрзЗред рждржмрзЗ, ржпржжрж┐ ржЖржкржирж╛рж░ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрзЛржирзЛ ржмрж┐ржХрж▓рзНржкрзЗрж░ рж╕рж╛ржерзЗ ржирж╛ ржорзЗрж▓рзЗ, рждржмрзЗ ржкрзНрж░рж╢рзНржиржЯрж┐ ржПржмржВ ржЖржкржирж╛рж░ ржмрж┐рж╢рзНрж▓рзЗрж╖ржгржЯрж┐ ржЖржмрж╛рж░ ржкрж░рзАржХрзНрж╖рж╛ ржХрж░рзБржиред

ржПржЗ ржХрзМрж╢рж▓ржЧрзБрж▓рзЛ ржЕржирзБрж╕рж░ржг ржХрж░рж▓рзЗ ржЖржкржирж┐ ржЬрж╛ржнрж╛ ржкрж░рзАржХрзНрж╖рж╛рж░ ржкрзНрж░рж╢рзНржиржЧрзБрж▓рзЛрж░ ржЙрждрзНрждрж░ рж╕ржарж┐ржХржнрж╛ржмрзЗ ржПржмржВ ржжрзНрж░рзБржд ржжрж┐рждрзЗ ржкрж╛рж░ржмрзЗржиред



1.class OpenDoorException extends Exception {}
class CableSnapException extends OpenDoorException {}

public class Palace {
public void openDrawbridge() throws Exception {
try {
throw new Exception(тАЬProblemтАЭ);
} catch (OpenDoorException e) {
throw new OpenDoorException();
} catch (CableSnapException ex) {
        try {
        throw new OpenDoorException();
        } catch (Exception ex) {
        } finally {
        System.out.println(тАЬAlmost doneтАЭ);
        }
} finally {
throw new RuntimeException(тАЬUnending problemтАЭ);
}
}

public static void main(String[] moat) throws IllegalArgumentException {
new Palace().openDrawbridge();
}
}


a.None. The code compiles and produces a stack trace at runtime.
b. One
c. Two
d. Three
e. Four
f. Five






Explanation:
ржПржЦрж╛ржирзЗ ржкрж╛ржБржЪржЯрж┐ ржХржорзНржкрж╛ржЗрж▓рзЗрж╢ржи ржПрж░рж░ (Compilation Error) ржЖржЫрзЗред

### ржПрж░рж░ржЧрзБрж▓рзЛ рж╣рж▓рзЛ:
1.  Duplicate catch block: `catch (OpenDoorException e)` ржмрзНрж▓ржХржЯрж┐ `catch (CableSnapException ex)` ржмрзНрж▓ржХрзЗрж░ ржЖржЧрзЗ рж▓рзЗржЦрж╛ рж╣ржпрж╝рзЗржЫрзЗред 
    ржпрзЗрж╣рзЗрждрзБ `CableSnapException` рж╣рж▓рзЛ `OpenDoorException`-ржПрж░ рж╕рж╛ржмржХрзНрж▓рж╛рж╕, рждрж╛ржЗ рж╕рж╛ржмржХрзНрж▓рж╛рж╕рзЗрж░ `catch` ржмрзНрж▓ржХржЯрж┐ рж╕рзБржкрж╛рж░ржХрзНрж▓рж╛рж╕рзЗрж░ `catch` ржмрзНрж▓ржХрзЗрж░ ржЖржЧрзЗ ржерж╛ржХрждрзЗ рж╣ржмрзЗред 
    ржХржорзНржкрж╛ржЗрж▓рж╛рж░ ржПржЯрж┐ ржПржХржЯрж┐ ржЕржкрзНрж░рж╛ржкрзНржп (unreachable) ржХрзЛржб рж╣рж┐рж╕рзЗржмрзЗ ржжрзЗржЦржмрзЗ ржПржмржВ ржПрж░рж░ ржжрзЗржмрзЗред
2.  Duplicate local variable: `catch (CableSnapException ex)` ржмрзНрж▓ржХрзЗрж░ ржнрзЗрждрж░рзЗ ржПржХржЯрж┐ ржирзЗрж╕рзНржЯрзЗржб `catch` ржмрзНрж▓ржХ ржЖржЫрзЗ, ржпрж╛рж░ ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░ рж╣рж┐рж╕рзЗржмрзЗ `Exception ex` рж▓рзЗржЦрж╛ рж╣ржпрж╝рзЗржЫрзЗред 
    ржПржЦрж╛ржирзЗ `ex` ржирж╛ржорзЗрж░ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ржЯрж┐ ржмрж╛ржЗрж░рзЗрж░ `catch` ржмрзНрж▓ржХрзЗрж░ `ex` ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ рж╕рж╛ржерзЗ рж╕ржВржШрж░рзНрж╖ (clash) ржХрж░ржЫрзЗред
3.  Duplicate local variable: ржПржХржЗ ржХрж╛рж░ржгрзЗ, `try...catch...finally` ржмрзНрж▓ржХрзЗрж░ ржнрзЗрждрж░рзЗржУ `Exception ex` ржПрж░ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ ржирзЗржоржЯрж┐ ржкрзБржирж░рж╛ржпрж╝ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ, ржпрж╛ ржЕржирзБржорзЛржжрж┐ржд ржирзЯред
4.  `main` method declaration: `main` ржорзЗржержбржЯрж┐ `IllegalArgumentException` ржерзНрж░рзЛ ржХрж░ржЫрзЗ, ржХрж┐ржирзНрждрзБ `new Palace().openDrawbridge()` ржПрж░рж░ржЯрж┐ `RuntimeException` ржерзНрж░рзЛ ржХрж░рзЗ, 
    ржпрж╛ `IllegalArgumentException` ржПрж░ рж╕рзБржкрж╛рж░ржХрзНрж▓рж╛рж╕ред ржХржорзНржкрж╛ржЗрж▓рж╛рж░ ржПржЯрж┐ ржзрж░рждрзЗ ржкрж╛рж░ржмрзЗ ржирж╛ред
5.  Unreachable statement: `catch (OpenDoorException e)` ржмрзНрж▓ржХрзЗрж░ ржнрзЗрждрж░рзЗ `throw new OpenDoorException();` 
   ржПрж░ ржкрж░рзЗ ржХрзЛржирзЛ ржХрзЛржб рж▓рж┐ржЦрж▓рзЗ рждрж╛ ржЕржкрзНрж░рж╛ржкрзНржп рж╣ржмрзЗ, ржХрж╛рж░ржг `throw` рж╕рзНржЯрзЗржЯржорзЗржирзНржЯржЯрж┐ ржорзЗржержбрзЗрж░ рж╕рзНржмрж╛ржнрж╛ржмрж┐ржХ ржкрзНрж░ржмрж╛рж╣ ржмржирзНржз ржХрж░рзЗ ржжрзЗрзЯред 
   ржПржЗ рж▓рж╛ржЗржирзЗрж░ ржкрж░ `catch (CableSnapException ex)` ржмрзНрж▓ржХржЯрж┐ ржЕржкрзНрж░рж╛ржкрзНржп рж╣ржпрж╝рзЗ ржпрж╛рзЯ, ржХрж╛рж░ржг ржПржЯрж┐ ржПржХржЯрж┐ рж╕рж╛ржмржХрзНрж▓рж╛рж╕рзЗрж░ ржПржХрзНрж╕рж╕рзЗржкрж╢ржиржХрзЗ рж╣рзНржпрж╛ржирзНржбрзЗрж▓ ржХрж░рж╛рж░ ржХржерж╛, ржпрж╛ ржПрж░ рж╕рзБржкрж╛рж░ржХрзНрж▓рж╛рж╕ ржжрзНржмрж╛рж░рж╛ ржЗрждрж┐ржоржзрзНржпрзЗржЗ рж╣рзНржпрж╛ржирзНржбрзЗрж▓ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред
   ржПржЗ ржкрж╛ржБржЪржЯрж┐ ржХрж╛рж░ржгрзЗ ржХрзЛржбржЯрж┐ ржХржорзНржкрж╛ржЗрж▓ рж╣ржмрзЗ ржирж╛ред




2.What is the output of the following?
12: int result = 8;
13: loop: while (result > 7) {
14: result++;
15: do {
16: resultтАУ;
17: } while (result > 5);
18: break loop;
19: }
20: System.out.println(result);

 5
 7
 8
 The code does not compile.
 The code compiles but throws an exception at runtime.






Explanation:
loop ржПржХржЯрж┐ ржЬрж╛ржнрж╛ ржХрзАржУржпрж╝рж╛рж░рзНржб (keyword) ржиржпрж╝ред рждржмрзЗ, ржПржЯрж┐ ржПржХржЯрж┐ рж▓рзЗржмрзЗрж▓ (label) рж╣рж┐рж╕рзЗржмрзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ ржпрж╛рзЯ, ржпрж╛ ржЬрж╛ржнрж╛рждрзЗ ржПржХржЯрж┐ рж▓рзБржкржХрзЗ ржЪрж┐рж╣рзНржирж┐ржд ржХрж░рж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рж╣ржпрж╝ред


1.  рж▓рж╛ржЗржи 12: ржкрзНрж░ржержорзЗ `result` ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ржЯрж┐рж░ ржорж╛ржи `8` ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рж╛ рж╣ржпрж╝ред
2.  рж▓рж╛ржЗржи 13: `while` рж▓рзБржк рж╢рзБрж░рзБ рж╣ржпрж╝ред рж╢рж░рзНрждржЯрж┐ рж╣рж▓рзЛ `result > 7`, ржпрж╛ рж╕рждрзНржп (ржХрж╛рж░ржг `8` `7` ржПрж░ ржерзЗржХрзЗ ржмржбрж╝)ред ржкрзНрж░рзЛржЧрзНрж░рж╛ржо рж▓рзБржкрзЗрж░ ржнрзЗрждрж░рзЗ ржкрзНрж░ржмрзЗрж╢ ржХрж░рзЗред
3.  рж▓рж╛ржЗржи 14: `result` ржПрж░ ржорж╛ржи ржПржХ ржмрж╛ржбрж╝рж╛ржирзЛ рж╣ржпрж╝, ржлрж▓рзЗ ржирждрзБржи ржорж╛ржи рж╣ржпрж╝ `9`ред
4.  рж▓рж╛ржЗржи 15: ржПржХржЯрж┐ `do-while` рж▓рзБржк рж╢рзБрж░рзБ рж╣ржпрж╝ред ржПржЗ рж▓рзБржкрзЗрж░ ржмрзИрж╢рж┐рж╖рзНржЯрзНржп рж╣рж▓рзЛ, рж╢рж░рзНржд ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛рж░ ржЖржЧрзЗржЗ ржПрж░ ржнрзЗрждрж░рзЗрж░ ржХрзЛржб ржЕржирзНрждржд ржПржХржмрж╛рж░ ржПржХрзНрж╕рж┐ржХрж┐ржЙржЯ рж╣ржпрж╝ред
5.  рж▓рж╛ржЗржи 16: `do-while` рж▓рзБржкрзЗрж░ ржнрзЗрждрж░рзЗ `result` ржПрж░ ржорж╛ржи ржПржХ ржХржорж╛ржирзЛ рж╣ржпрж╝, ржлрж▓рзЗ ржорж╛ржи рж╣ржпрж╝ `8`ред
6.  рж▓рж╛ржЗржи 17: `do-while` рж▓рзБржкрзЗрж░ рж╢рж░рзНржд (`result > 5`) ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛ рж╣ржпрж╝ред рж╢рж░рзНрждржЯрж┐ рж╕рждрзНржп (`8 > 5`), рждрж╛ржЗ рж▓рзБржкржЯрж┐ ржЖржмрж╛рж░ ржЪрж▓рзЗред as ; (comma) end of while (result > 5);
7.  рж▓рж╛ржЗржи 16: `result` ржПрж░ ржорж╛ржи ржЖржмрж╛рж░ ржПржХ ржХржорж╛ржирзЛ рж╣ржпрж╝, ржлрж▓рзЗ ржорж╛ржи рж╣ржпрж╝ `7`ред
8.  рж▓рж╛ржЗржи 17: рж╢рж░рзНрждржЯрж┐ ржЖржмрж╛рж░ ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛ рж╣ржпрж╝, ржпрж╛ ржПржЦржирзЛ рж╕рждрзНржп (`7 > 5`), рждрж╛ржЗ рж▓рзБржкржЯрж┐ рждрзГрждрзАржпрж╝ржмрж╛рж░рзЗрж░ ржорждрзЛ ржЪрж▓рзЗред
9.  рж▓рж╛ржЗржи 16: `result` ржПрж░ ржорж╛ржи ржЖржмрж╛рж░ ржПржХ ржХржорж╛ржирзЛ рж╣ржпрж╝, ржлрж▓рзЗ ржорж╛ржи рж╣ржпрж╝ `6`ред
10. рж▓рж╛ржЗржи 17: рж╢рж░рзНрждржЯрж┐ ржЖржмрж╛рж░ ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛ рж╣ржпрж╝, ржпрж╛ ржПржЦржирзЛ рж╕рждрзНржп (`6 > 5`), рждрж╛ржЗ рж▓рзБржкржЯрж┐ ржЪрждрзБрж░рзНржержмрж╛рж░рзЗрж░ ржорждрзЛ ржЪрж▓рзЗред
11. рж▓рж╛ржЗржи 16: `result` ржПрж░ ржорж╛ржи рж╢рзЗрж╖ржмрж╛рж░рзЗрж░ ржорждрзЛ ржПржХ ржХржорж╛ржирзЛ рж╣ржпрж╝, ржлрж▓рзЗ ржорж╛ржи рж╣ржпрж╝ `5`ред
12. рж▓рж╛ржЗржи 17: рж╢рж░рзНрждржЯрж┐ ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛ рж╣ржпрж╝ред ржПржмрж╛рж░ ржПржЯрж┐ ржорж┐ржерзНржпрж╛ (ржХрж╛рж░ржг `5` `5` ржПрж░ ржерзЗржХрзЗ ржмржбрж╝ ржиржпрж╝)ред `do-while` рж▓рзБржк рж╢рзЗрж╖ рж╣ржпрж╝ред
13. рж▓рж╛ржЗржи 18: `break loop;` рж╕рзНржЯрзЗржЯржорзЗржирзНржЯржЯрж┐ ржПржХрзНрж╕рж┐ржХрж┐ржЙржЯ рж╣ржпрж╝ред ржПржЯрж┐ рж▓рзЗржмрзЗрж▓ржпрзБржХрзНржд (`loop`) ржмрж╛ржЗрж░рзЗрж░ `while` рж▓рзБржк ржерзЗржХрзЗ ржкрзНрж░рзЛржЧрзНрж░рж╛ржоржХрзЗ рж╕рж░рж╛рж╕рж░рж┐ ржмрзЗрж░ ржХрж░рзЗ ржирж┐ржпрж╝рзЗ ржЖрж╕рзЗред
14. рж▓рж╛ржЗржи 20: рж╕ржмрж╢рзЗрж╖рзЗ, `result` ржПрж░ ржЪрзВржбрж╝рж╛ржирзНржд ржорж╛ржи, ржпрж╛ `5`, рждрж╛ ржХржирж╕рзЛрж▓рзЗ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рж╛ рж╣ржпрж╝ред



3.What statements are true about compiling a Java class file? (Choose two.)

 If the file does not contain a package statement, then the compiler considers the class part of the java.lang package.
 The compiler assumes every class implicitly imports the java.lang.* package.
 The compiler assumes every class implicitly imports the java.util.* package.
 Java requires every file to declare a package statement.
 Java requires every file to declare at least one import statement.
 If the class declaration does not extend another class, then it implicitly extends the java.lang.Object class.










Explanation:
2. рж╕ржВржХрж▓ржХ (compiler) ржзрж░рзЗ ржирзЗржпрж╝ ржпрзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржХрзНрж▓рж╛рж╕ рж╕рзНржмржпрж╝ржВржХрзНрж░рж┐ржпрж╝ржнрж╛ржмрзЗ java.lang.* ржкрзНржпрж╛ржХрзЗржЬржЯрж┐ ржЖржоржжрж╛ржирж┐ (import) ржХрж░рзЗред
ржПрж░ ржЕрж░рзНрже рж╣рж▓рзЛ, ржЖржкржирж┐ java.lang ржкрзНржпрж╛ржХрзЗржЬрзЗрж░ ржХрзНрж▓рж╛рж╕ржЧрзБрж▓рзЛ, ржпрзЗржоржи String, System, ржмрж╛ Math, ржХрзЛржирзЛ import рж╕рзНржЯрзЗржЯржорзЗржирзНржЯ ржЫрж╛ржбрж╝рж╛ржЗ рж╕рж░рж╛рж╕рж░рж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░рзЗржиред
6.ржпржжрж┐ ржХрзНрж▓рж╛рж╕ ржбрж┐ржХрзНрж▓рзЗржпрж╝рж╛рж░рзЗрж╢ржирзЗ ржЕржирзНржп ржХрзЛржирзЛ ржХрзНрж▓рж╛рж╕ржХрзЗ ржПржХрзНрж╕ржЯрзЗржирзНржб (extend) ржирж╛ ржХрж░рж╛ рж╣ржпрж╝, рждржмрзЗ ржПржЯрж┐ рж╕рзНржмржпрж╝ржВржХрзНрж░рж┐ржпрж╝ржнрж╛ржмрзЗ java.lang.Object ржХрзНрж▓рж╛рж╕ржХрзЗ ржПржХрзНрж╕ржЯрзЗржирзНржб ржХрж░рзЗред
ржЬрж╛ржнрж╛рждрзЗ, ржкрзНрж░рждрж┐ржЯрж┐ ржХрзНрж▓рж╛рж╕ Object ржХрзНрж▓рж╛рж╕рзЗрж░ ржПржХржЯрж┐ ржЙржкрж╢рзНрж░рзЗржгрзА (subclass)ред ржПржЯрж┐ рж╕ржорж╕рзНржд ржХрзНрж▓рж╛рж╕рзЗрж░ ржЬржирзНржп ржорзМрж▓рж┐ржХ ржХрж╛рж░рзНржпржХрж╛рж░рж┐рждрж╛ ржкрзНрж░ржжрж╛ржи ржХрж░рзЗ, ржпрзЗржоржи equals() ржПржмржВ toString() ржорзЗржержбред




4. What is the output of the following application?
package woods;
interface Plant {
default String grow() { return тАЬGrow!тАЭ; }
}
interface Living {
public default String grow() { return тАЬGrowing!тАЭ; }
}
public class Tree implements Plant, Living { // m1
public String grow(int height) { return тАЬSuper Growing!тАЭ; }
public static void main(String[] leaves) {
Plant p = new Tree(); // m2
System.out.print(((Living)p).grow()); // m3
}
}

 Grow!
 Growing!
 Super Growing!
 It does not compile because of line m1.
 It does not compile because of line m2.
 It does not compile because of line m3.






Explanation:
ржХрзЛржбржЯрж┐ ржХржорзНржкрж╛ржЗрж▓ рж╣ржмрзЗ ржирж╛ ржПржмржВ ржПрж░ ржкрзНрж░ржзрж╛ржи ржХрж╛рж░ржг рж╣рж▓рзЛ рж▓рж╛ржЗржи m1-ржПрж░ Tree ржХрзНрж▓рж╛рж╕ ржбрж┐ржХрзНрж▓рзЗрзЯрж╛рж░рзЗрж╢ржиред
ржпржЦржи ржПржХржЯрж┐ ржХрзНрж▓рж╛рж╕ ржжрзБржЯрж┐ ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ (Plant ржПржмржВ Living) ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯ ржХрж░рзЗ, ржПржмржВ ржЙржнржпрж╝ ржЗржирзНржЯрж╛рж░ржлрзЗрж╕рзЗ ржПржХржЗ рж╕рж┐ржЧржирзЗржЪрж╛рж░ (signature) рж╕рж╣ ржПржХржЯрж┐ ржбрж┐ржлрж▓рзНржЯ ржорзЗржержб ржерж╛ржХрзЗ, 
рждржЦржи рж╕рзЗржЗ ржХрзНрж▓рж╛рж╕ржХрзЗ ржЕржмрж╢рзНржпржЗ рж╕рзЗржЗ ржорзЗржержбржЯрж┐ржХрзЗ ржУржнрж╛рж░рж░рж╛ржЗржб (override) ржХрж░рждрзЗ рж╣ржмрзЗ ржпрж╛рждрзЗ ржжрзНржмржирзНржжрзНржм (conflict) ржПржбрж╝рж╛ржирзЛ ржпрж╛ржпрж╝ред

Tree ржХрзНрж▓рж╛рж╕ржЯрж┐ 
-ржЙржнржпрж╝ ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯ ржХрж░рж▓рзЗржУ, ржПржЯрж┐ grow() ржорзЗржержбрзЗрж░ ржЬржирзНржп ржирж┐ржЬрж╕рзНржм ржХрзЛржирзЛ ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯрзЗрж╢ржи ржжрзЗржпрж╝ржирж┐ред
-public String grow(int height) ржорзЗржержбржЯрж┐ ржПржХржЯрж┐ ржУржнрж╛рж░рж▓рзЛржб (overload), ржУржнрж╛рж░рж░рж╛ржЗржб (override) ржиржпрж╝, ржХрж╛рж░ржг ржПрж░ рж╕рж┐ржЧржирзЗржЪрж╛рж░ ржнрж┐ржирзНржи (ржПржЯрж┐ ржПржХржЯрж┐ int ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░ ржЧрзНрж░рж╣ржг ржХрж░рзЗ)ред


5.Which statements best describe the result of this code? (Choose two.)
package nyc;
public class TouristBus {
public static void main(StringтАж args) {
String[] nycTourLoops = new String[] { тАЬDowntownтАЭ, тАЬUptownтАЭ, тАЬBrooklynтАЭ };
String[] times = new String[] { тАЬDayтАЭ, тАЬNightтАЭ };
for (int i = 0, j = 0; i < nycTourLoops.length; i++, j++) 
System.out.println(nycTourLoops[i] + " " + times[j]); } }

 The println causes one line of output.
 The println causes two lines of output.
 The println causes three lines of output.
 The code terminates successfully.
 The code throws an exception at runtime.






Explanation:
 ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг: рж▓рзБржкрзЗрж░ рж╢рж░рзНрждржЯрж┐ nycTourLoops ржЕрзНржпрж╛рж░рзЗрж░ ржжрзИрж░рзНржШрзНржпрзЗрж░ ржЙржкрж░ ржирж┐рж░рзНржнрж░ ржХрж░рзЗ, ржХрж┐ржирзНрждрзБ ржнрж┐рждрж░рзЗ times ржЕрзНржпрж╛рж░рзЗржЯрж┐ j index ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗред ржпрзЗрж╣рзЗрждрзБ times ржЕрзНржпрж╛рж░рзЗрж░ ржжрзИрж░рзНржШрзНржп nycTourLoops ржЕрзНржпрж╛рж░рзЗрж░ ржЪрзЗржпрж╝рзЗ ржХржо, 
 рждрж╛ржЗ рж▓рзБржкрзЗрж░ рждрзГрждрзАржпрж╝ ржкрзБржирж░рж╛ржмрзГрждрзНрждрж┐рждрзЗ j ржПрж░ ржорж╛ржи 2 рж╣рж▓рзЗ times[j] ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржХрж░рж╛рж░ рж╕ржоржпрж╝ ржПржХржЯрж┐ ArrayIndexOutOfBoundsException рж╣ржпрж╝ред рждрж╛ржЗ, ржХрзЛржбржЯрж┐ рж╕ржлрж▓ржнрж╛ржмрзЗ рж╢рзЗрж╖ рж╣ржпрж╝ ржирж╛, ржмрж░ржВ ржПржХржЯрж┐ ржмрзНржпрждрж┐ржХрзНрж░ржо (exception) рждрзИрж░рж┐ ржХрж░рзЗред

ржЕрждржПржм, рж╕ржарж┐ржХ ржмрж┐ржмрзГрждрж┐ ржжрзБржЯрж┐ рж╣рж▓рзЛ:
The println causes two lines of output. (println ржжрзБржЯрж┐ рж▓рж╛ржЗржирзЗ ржЖржЙржЯржкрзБржЯ рждрзИрж░рж┐ ржХрж░рзЗред)
The code throws an exception at runtime. (ржХрзЛржбржЯрж┐ рж░рж╛ржиржЯрж╛ржЗржорзЗ ржПржХржЯрж┐ ржмрзНржпрждрж┐ржХрзНрж░ржо рждрзИрж░рж┐ ржХрж░рзЗред)


6.What is the result of the following?
package calendar;
public class Seasons {
public static void seasons(StringтАж names) {
int l = names[1].length(); // s1
System.out.println(names[l]); // s2
}
public static void main(String[] args) {
seasons(тАЬSummerтАЭ, тАЬFallтАЭ, тАЬWinterтАЭ, тАЬSpringтАЭ);
}
}






Explanation:
ржХрзЛржбржЯрж┐ ржХржорзНржкрж╛ржЗрж▓ рж╣рзЯред рж▓рж╛ржЗржи s1 ржХрж┐ржЫрзБржЯрж╛ ржЯрзНрж░рж┐ржХрж┐ ржХрж╛рж░ржг ржЕрзНржпрж╛рж░рзЗрж░ ржЬржирзНржп length ржмрзНржпржмрж╣рзГржд рж╣рзЯ ржПржмржВ рж╕рзНржЯрзНрж░рж┐ржВрзЯрзЗрж░ ржЬржирзНржп length() ржмрзНржпржмрж╣рзГржд рж╣рзЯред рж▓рж╛ржЗржи s1-ржП Fall-ржПрж░ ржжрзИрж░рзНржШрзНржп ржПржХржЯрж┐ ржнрзЗрж░рж┐рзЯрзЗржмрж▓рзЗ рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рж╛ рж╣рзЯ, ржпрж╛ 4ред
 рж▓рж╛ржЗржи s2-ржП ArrayIndexOutOfBoundsException ржерзНрж░рзЛ ржХрж░рж╛ рж╣рзЯ ржХрж╛рж░ржг 4 рж╣рж▓ ржПржХржЯрж┐ ржЪрж╛рж░ржЯрж┐ ржПрж▓рж┐ржорзЗржирзНржЯ ржмрж┐рж╢рж┐рж╖рзНржЯ ржЕрзНржпрж╛рж░рзЗрж░ ржЬржирзНржп ржЕржмрзИржз ржЗржиржбрзЗржХрзНрж╕ред 
 ржоржирзЗ рж░рж╛ржЦржмрзЗржи, ржЗржиржбрзЗржХрзНрж╕ ржЧржгржирж╛ рж╢рзВржирзНржп ржерзЗржХрзЗ рж╢рзБрж░рзБ рж╣рзЯред рждрж╛ржЗ, ржлрж▓рж╛ржлрж▓: рж░рж╛ржиржЯрж╛ржЗржорзЗ ArrayIndexOutOfBoundsExceptionред



7.How many lines of the following application contain compilation errors?
1: package percussion;
2:
3: interface MakesNoise {}

4: abstract class Instrument implements MakesNoise {
5: public Instrument(int beats) {}
6: public void play() {}
7: }

8: public class Drum extends Instrument {
9: public void play(int count) {}
10: public void concert() {
11: super.play(5);
12: }
13: public static void main(String[] beats) {
14: MakesNoise mn = new Drum();
15: mn.concert();
16: }
17: }

 None. The code compiles and runs without issue.
 One
 Two
 Three
 Four






Explanation:
* рж▓рж╛ржЗржи рзл: `Instrument` ржХрзНрж▓рж╛рж╕рзЗрж░ ржХрзЛржирзЛ ржбрж┐ржлрж▓рзНржЯ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ ржирзЗржЗред рждрж╛ржЗ, `Drum` ржХрзНрж▓рж╛рж╕ржХрзЗ рждрж╛рж░ ржирж┐ржЬрзЗрж░ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ ржерзЗржХрзЗ `super(int)` ржХрж▓ ржХрж░рждрзЗ рж╣ржмрзЗ, ржпрж╛ ржПржЦрж╛ржирзЗ ржЕржирзБржкрж╕рзНржерж┐рждред
* рж▓рж╛ржЗржи рззрзз: `Instrument` ржХрзНрж▓рж╛рж╕рзЗрж░ `play()` ржорзЗржержбржЯрж┐ ржХрзЛржирзЛ ржЖрж░рзНржЧрзБржорзЗржирзНржЯ ржЧрзНрж░рж╣ржг ржХрж░рзЗ ржирж╛, ржХрж┐ржирзНрждрзБ ржПржЦрж╛ржирзЗ `super.play(5)` ржХрж▓ ржХрж░рзЗ ржПржХржЯрж┐ ржЗржирзНржЯрж┐ржЬрж╛рж░ ржЖрж░рзНржЧрзБржорзЗржирзНржЯ ржкрж╛ржарж╛ржирзЛ рж╣ржЪрзНржЫрзЗред
* рж▓рж╛ржЗржи рззрзл: `mn` ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ржЯрж┐ `MakesNoise` ржЯрж╛ржЗржкрзЗрж░, ржпрзЗржЯрж┐рждрзЗ `concert()` ржирж╛ржорзЗ ржХрзЛржирзЛ ржорзЗржержб ржирзЗржЗред рждрж╛ржЗ, ржХржорзНржкрж╛ржЗрж▓рж╛рж░ ржПржЗ ржХрж▓ржЯрж┐ ржЦрзБржБржЬрзЗ ржкрж╛ржмрзЗ ржирж╛ред


8.What is the output of the following when run as java EchoFirst seed flower plant?
package unix;
import java.util.*;
public class EchoFirst {
public static void main(String[] args) {
Arrays.sort(args);
int result = Arrays.binarySearch(args, args[0]);
System.out.println(result);
}
}

 0
 1
 2
 The code does not compile.
 The code compiles but throws an exception at runtime.
 The output is not guaranteed.






Explanation:
1.  ржкрзНрж░ржержорзЗ, `Arrays.sort(args)` ржХржорж╛ржирзНржбрзЗрж░ ржХрж╛рж░ржгрзЗ `args` ржЕрзНржпрж╛рж░рзЗржЯрж┐ ржЕрзНржпрж╛рж▓ржлрж╛ржмрзЗржЯрж┐ржХрзНржпрж╛рж▓рж┐ рж╕рж╛ржЬрж╛ржирзЛ рж╣ржпрж╝, ржпрж╛ ржжрж╛ржБрзЬрж╛рзЯ `["flower", "plant", "seed"]`ред
2.  ржПрж░ржкрж░, `args[0]` ржПрж░ ржорж╛ржи рж╣ржпрж╝ `"flower"`ред
3.  `Arrays.binarySearch(args, args[0])` ржХржорж╛ржирзНржбржЯрж┐ рж╕рж╛ржЬрж╛ржирзЛ ржЕрзНржпрж╛рж░рзЗрждрзЗ `"flower"` ржПрж░ ржЕржмрж╕рзНржерж╛ржи ржЦрзЛржБржЬрзЗред
4.  ржпрзЗрж╣рзЗрждрзБ `"flower"` ржЕрзНржпрж╛рж░рзЗрж░ ржкрзНрж░ржержо ржЙржкрж╛ржжрж╛ржи, рждрж╛ржЗ ржПрж░ ржЗржиржбрзЗржХрзНрж╕ `0` рж╣ржпрж╝ред

ржПржЬржирзНржп, ржЖржЙржЯржкрзБржЯ `0` ржкрзНрж░рж┐ржирзНржЯ ржХрж░рж╛ рж╣рзЯред


9. What is the output of the following?
14: int count = 0;
15: LocalDate date = LocalDate.of(2017, Month.JANUARY, 1);
16: while (date.getMonth() != Month.APRIL)
17: date = date.minusMonths(1);
18: count++;
19: System.out.println(count);

 0
 1
 3
 9
 This is an infinite loop.
 The code does not compile.






Explanation:
 while (date.getMonth() != Month.APRIL) { // ржПржХржЯрж┐ рж▓рзБржк ржпрж╛ рждрж╛рж░рж┐ржЦрзЗрж░ ржорж╛рж╕ ржПржкрзНрж░рж┐рж▓ ржирж╛ рж╣ржУржпрж╝рж╛ ржкрж░рзНржпржирзНржд ржЪрж▓ржмрзЗ             
        date = date.minusMonths(1);// рждрж╛рж░рж┐ржЦ ржерзЗржХрзЗ ржПржХ ржорж╛рж╕ ржХржорж┐ржпрж╝рзЗ ржЖржкржбрзЗржЯ ржХрж░рж╛ рж╣ржпрж╝
date ржкрзНрж░рждрж┐ржмрж╛рж░ ржПржХ ржорж╛рж╕ ржХрж░рзЗ ржкрзЗржЫржирзЗрж░ ржжрж┐ржХрзЗ ржпрзЗрждрзЗ ржерж╛ржХржмрзЗ, рж▓рзБржкрзЗрж░ рж╢рж░рзНрждржЯрж┐ржУ date ржПржЦржи ржЬрж╛ржирзБржпрж╝рж╛рж░рж┐,ржбрж┐рж╕рзЗржорзНржмрж░ ....ржорзЛржЯ рзп ржмрж╛рж░ рж▓рзБржк ржЪрж▓рж╛рж░ ржкрж░, date ржПрж░ ржорж╛рж╕ ржПржкрзНрж░рж┐рж▓ рж╣рзЯред рждржЦржи рж▓рзБржкрзЗрж░ рж╢рж░рзНрждржЯрж┐ ржорж┐ржерзНржпрж╛ рж╣рзЯрзЗ ржпрж╛рзЯ ржПржмржВ рж▓рзБржкржЯрж┐ ржмржирзНржз рж╣ржпрж╝рзЗ ржпрж╛ржпрж╝ред

рж▓рзБржк рж╢рзЗрж╖ рж╣ржУрзЯрж╛рж░ ржкрж░ ржкрзНрж░рзЛржЧрзНрж░рж╛ржоржЯрж┐ рждрж╛рж░ ржкрж░рзЗрж░ рж▓рж╛ржЗржирзЗ ржЪрж▓рзЗ ржЖрж╕рзЗ, ржпрж╛ рж╣рж▓рзЛ count++;(count ржПрж░ ржорж╛ржи рзж ржерзЗржХрзЗ ржмрж╛ржбрж╝рж┐ржпрж╝рзЗ рзз ржХрж░рзЗ)ред
рж╕ржмрж╢рзЗрж╖рзЗ, System.out.println(count) рж▓рж╛ржЗржиржЯрж┐ count ржПрж░ ржЪрзВржбрж╝рж╛ржирзНржд ржорж╛ржи, ржЕрж░рзНржерж╛рзО 1 ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзЗред
рж╕рзБрждрж░рж╛ржВ, рж▓рзБржкржЯрж┐ рж╢рзЗрж╖ рж╣рзЯ ржарж┐ржХржЗ, ржХрж┐ржирзНрждрзБ count ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ржЯрж┐ рж▓рзБржкрзЗрж░ ржмрж╛ржЗрж░рзЗ ржерж╛ржХрж╛рж░ ржХрж╛рж░ржгрзЗ рж╢рзБржзрзБржорж╛рждрзНрж░ ржПржХржмрж╛рж░ржЗ ржмрж╛рзЬрзЗред







10.Which code will print the numbers up to 1000 (included) starting from user input, assume that user input is less than 1000? 

 int x = sc.nextInt(); do { System.out.println(x); x--; } while (x < 1000); System.out.println(x);
 int x = sc.nextInt(); do { System.out.println(x); x++; } while (x < 1000); System.out.println(x);
 int x = sc.nextInt(); do { System.out.println(x); x+=1; } while (x <= 1000); System.out.println(x);
 None of the above






Explanation:




11.There is an error in the following code. How to fix that error?
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int num = sc.nextInt();

if (num == 7) {
boolean seven = true;
} else {
boolean seven = false;
}
System.out.println(seven);
}

 "else" statement needs a boolean condition
 boolean variable "seven" has to be changed with another name
 boolean variable "seven" is a local variable. It needs to declared outside of if statement
 if statement conditions has to be like num.equals(7)






Explanation:
ржПржЦрж╛ржирзЗ ржкрзНрж░ржзрж╛ржи рждрзНрж░рзБржЯрж┐ржЯрж┐ рж╣рж▓рзЛ boolean variable "seven" is a local variable. It needs to declared outside of if statementред




12.For the given Circle class, which of the following method defines area of the circle? 
public class Circle{
double radius = 10.0;
double x = 100.0;
double y = 100.0;

// area method goes here
}

 double getArea(int radius) {         return Math.PI * radius * radius;     }
 double getArea() { return PI * radius * radius; }
 double getArea() { return Math.PI * radius * radius; }
 None of the above






Explanation:
рж╕ржарж┐ржХ ржЙрждрзНрждрж░ рж╣рж▓рзЛ: 
double getArea() { return Math.PI * radius * radius; }


13.How many lines contain a compile error?
1: import java.time.*;
2: import java.time.format.*;
3:
4: public class HowLong {
5: public void main(String h) {
6: LocalDate newYears = new LocalDate(2017, 1, 1);
7: Period period = Period.ofYears(1).ofDays(1);
8: DateTimeFormat format = DateTimeFormat.ofPattern(тАЬMM-dd-yyyyтАЭ);
9: System.out.print(format.format(newYears.minus(period)));
10: }
11: }

 None
 One
 Two
 Three
 Four
 Five








Explanation:
1.  рж▓рж╛ржЗржи рзл: `main` ржорзЗржержбрзЗрж░ рж╕ржарж┐ржХ рж╕рж┐ржЧржирзЗржЪрж╛рж░ `public static void main(String[] args)` ржирзЯред
2.  рж▓рж╛ржЗржи рзм: `LocalDate` ржХрзНрж▓рж╛рж╕рзЗрж░ ржХрзЛржирзЛ ржкрж╛ржмрж▓рж┐ржХ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ ржирзЗржЗ, ржПрж░ ржмржжрж▓рзЗ `LocalDate.of()` ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ рж╣рзЯред
3.  рж▓рж╛ржЗржи рзн: `Period` ржПрж░ ржорзЗржержбржЧрзБрж▓рзЛ `ofYears().ofDays()` ржПржнрж╛ржмрзЗ ржЪрзЗржЗржи ржХрж░рж╛ ржпрж╛рзЯ ржирж╛ред
4.  рж▓рж╛ржЗржи рзо: рж╕ржарж┐ржХ ржХрзНрж▓рж╛рж╕ржЯрж┐рж░ ржирж╛ржо `DateTimeFormat` ржирзЯ, ржПржЯрж┐ рж╣ржмрзЗ `DateTimeFormatter`ред
ржкрзНрж░ржжрждрзНржд ржХрзЛржбрзЗ ржорзЛржЯ 4 рж▓рж╛ржЗржирзЗ ржХржорзНржкрж╛ржЗрж▓ ржПрж░рж░ (compile error) ржЖржЫрзЗред


14.Which is the correct statement about static variable? 
 -There may be any number of copies of static variable that can be shared among all the instances of the class
 -There is always exactly one copy of a static variable is created and shared among all the instances of the class
 -Static variables are primitive type 
 -None of the above






Explanation:
ржПржХржЯрж┐ рж╕рзНржЯрзНржпрж╛ржЯрж┐ржХ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ ржХрзНрж▓рж╛рж╕рзЗрж░ рж╕рж╛ржерзЗ рж╕ржорзНржкрж░рзНржХрж┐ржд, ржХрзЛржирзЛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржЕржмржЬрзЗржХрзНржЯрзЗрж░ (instance) рж╕рж╛ржерзЗ ржиржпрж╝ред
ржЖржкржирж┐ ржпрждржЧрзБрж▓рзЛржЗ ржЕржмржЬрзЗржХрзНржЯ рждрзИрж░рж┐ ржХрж░рзБржи ржирж╛ ржХрзЗржи, рж╕рзНржЯрзНржпрж╛ржЯрж┐ржХ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ рж╢рзБржзрзБржорж╛рждрзНрж░ ржПржХржЯрж┐ржЗ ржХржкрж┐ ржорзЗржорж░рж┐рждрзЗ рждрзИрж░рж┐ рж╣ржпрж╝ред
ржПржЗ ржПржХржЯрж┐ ржХржкрж┐ржЗ ржХрзНрж▓рж╛рж╕рзЗрж░ рж╕ржорж╕рзНржд ржЕржмржЬрзЗржХрзНржЯрзЗрж░ ржоржзрзНржпрзЗ рж╢рзЗржпрж╝рж╛рж░ ржХрж░рж╛ рж╣ржпрж╝ред ржпржЦржи ржПржХржЯрж┐ ржЕржмржЬрзЗржХрзНржЯ ржПржЗ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ ржорж╛ржи ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рзЗ, рждржЦржи рж╕рзЗржЗ ржкрж░рж┐ржмрж░рзНрждржиржЯрж┐ ржЕржирзНржп рж╕ржм ржЕржмржЬрзЗржХрзНржЯрзЗрж░ ржЬржирзНржпржУ ржжрзГрж╢рзНржпржорж╛ржи рж╣ржпрж╝ред
рж╕ржарж┐ржХ ржЙрждрзНрждрж░ рж╣рж▓рзЛ: "There is always exactly one copy of a static variable is created and shared among all the instances of the class" (ржПржХржЯрж┐ рж╕рзНржЯрзНржпрж╛ржЯрж┐ржХ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ рж╕ржмрж╕ржоржпрж╝ ржарж┐ржХ ржПржХржЯрж┐ ржХржкрж┐ рждрзИрж░рж┐ рж╣ржпрж╝ ржпрж╛ ржХрзНрж▓рж╛рж╕рзЗрж░ рж╕ржорж╕рзНржд ржЗржирж╕рзНржЯрзНржпрж╛ржирзНрж╕рзЗрж░ ржоржзрзНржпрзЗ рж╢рзЗржпрж╝рж╛рж░ ржХрж░рж╛ рж╣ржпрж╝)ред


15.What is printed by the following code snippet?
int fish = 1 + 2 * 5>=2 ? 4 : 2;
int mammals = 3 < 3 ? 1 : 5>=5 ? 9 : 7;
System.out.print(fish+mammals+тАЭтАЭ);

 49
 13
 18
 99
 It does not compile.






Explanation:
B.13


16.What is the output for this code line? 
System.out.println(30/2*5%4);  

 1
 15
 0
 3







Explanation:
ржЬрж╛ржнрж╛рждрзЗ, `*`, `/`, ржПржмржВ `%` ржЕржкрж╛рж░рзЗржЯрж░ржЧрзБрж▓рзЛрж░ ржЕржЧрзНрж░рж╛ржзрж┐ржХрж╛рж░ ржПржХржЗ, рждрж╛ржЗ ржмрж╛ржо ржжрж┐ржХ ржерзЗржХрзЗ ржбрж╛ржи ржжрж┐ржХрзЗ ржЧржгржирж╛ ржХрж░рж╛ рж╣рзЯред
1.  ржкрзНрж░ржержорзЗ, `30/2` ржЧржгржирж╛ ржХрж░рж╛ рж╣ржпрж╝, ржпрж╛рж░ ржлрж▓рж╛ржлрж▓ `15`ред
2.  ржПрж░ржкрж░, `15*5` ржЧржгржирж╛ ржХрж░рж╛ рж╣ржпрж╝, ржпрж╛рж░ ржлрж▓рж╛ржлрж▓ `75`ред
3.  рж╕ржмрж╢рзЗрж╖рзЗ, `75%4` ржЧржгржирж╛ ржХрж░рж╛ рж╣ржпрж╝, ржпрж╛рж░ ржлрж▓рж╛ржлрж▓ `3` (ржХрж╛рж░ржг 75 ржХрзЗ 4 ржжрж┐ржпрж╝рзЗ ржнрж╛ржЧ ржХрж░рж▓рзЗ ржнрж╛ржЧрж╢рзЗрж╖ 3 ржерж╛ржХрзЗ)ред




17.What is the output of the following code?
public static void main(String[] args) {
final String cell = тАЬaтАЭ;
String foo = new String(тАЬaтАЭ);
final String bell = new String(foo);
System.out.print((cell==bell)+тАЭ тАЬ+cell.equals(bell));
}

 false true
 false false
 true true
 Code will not compile due to error








Explanation:
check carefully: false true


18.Given that SC is an scanner object. Which of the following code stores users value into an array? 

 int[] d = new int[10]; for (int i = 0; i < d.length; i++) { d[i].nextInt(); }
 int[] d = new Int[10]; for (int i = 0; i < d.length; i++) { d[i] = SC.nextInt(); }
 int[] d = new int[10]; d[i] = SC.nextInt();
 int[] d = new int[10]; for (int i = 0; i < d.length; i++) { d[i] = SC.nextInt(); }






Explanation:
* ржПржЗ ржХрзЛржбржЯрж┐ ржПржХржЯрж┐ `for` рж▓рзБржк ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗред
* рж▓рзБржкржЯрж┐ ржЕрзНржпрж╛рж░рзЗрж░ ржкрзНрж░рждрж┐ржЯрж┐ ржЗржиржбрзЗржХрзНрж╕ (`i=0` ржерзЗржХрзЗ `9` ржкрж░рзНржпржирзНржд) ржжрж┐рзЯрзЗ ржЪрж▓рзЗред
* `SC.nextInt()` ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржХрж╛ржЫ ржерзЗржХрзЗ ржПржХржЯрж┐ ржкрзВрж░рзНржгрж╕ржВржЦрзНржпрж╛ ржЗржиржкрзБржЯ ржирзЗрзЯред
* ржкрзНрж░рждрж┐ржЯрж┐ ржЗржиржкрзБржЯржХрзЗ `d[i]` ржПрж░ ржорж╛ржзрзНржпржорзЗ ржЕрзНржпрж╛рж░рзЗрж░ рж╕ржарж┐ржХ рж╕рзНржерж╛ржирзЗ рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рзЗред
-last one





19.Suppose you have a variable named passengers which stores an array of objects of type Passenger.
 What is a single line of code that will print the output of the getName() method for the first Passenger object in the passengers array?

 System.out.println(passengers.getName()); 
 System.out.println(passengers[0].getName()); 
 System.out.println(passengers.getName([0])); 
 System.out.println(getName(0));







Explanation:
 System.out.println(passengers[0].getName()); gives the first element of the given array.











20.What does this code output? 
public void foo(int[] x) {
x[0] = x[0] + 1;
}
int[] a = new int[10];
int[] b = a;
foo(a);
System.out.println(a[0]+тАЭ тАЬ+b[0]);

 0 0
 1 1
 1 0
 null null






Explanation:
2



21.Given the application below, which lines do not compile? (Choose three.)
package furryfriends;
interface Friend {
protected String getName(); // h1
}
class Cat implements Friend {
String getName() { // h2
return тАЬKittyтАЭ;
}
}
public class Dog implements Friend {
String getName() throws RuntimeException { // h3
return тАЬDoggyтАЭ;
}
public static void main(String[] adoption) {
Friend friend = new Dog(); // h4
System.out.print(((Cat)friend).getName()); // h5
System.out.print(((Dog)null).getName()); // h6
}
}

 Line h1
 Line h2
 Line h3
 Line h4
 Line h5
 Line h6






Explanation:
interface abstract method Can not be protected
so output: 1,2,3




22.What is the result of compiling and executing the following application?

public class Cowboy {
private int space = 5;
private double ship = space < 2 ? 1 : 10; // g1 

public void printMessage() { 
    if(ship>1) {
        System.out.println(тАЬGoodbyeтАЭ);
   } 

if(ship<10 && space>=2) System.out.println(тАЬHelloтАЭ); // g2
else System.out.println(тАЬSee you againтАЭ);
}

public static final void main(StringтАж stars) {
new Cowboy().printMessage();
}
}

 It only prints Hello.
 It only prints Goodbye.
 It only prints See you again.
 It does not compile because of line g1.
 It does not compile because of line g2.
 None of the above






Explanation:
ржнрж╛рж▓рзЛ ржХрж░рзЗ ржЦрзЗржпрж╝рж╛рж▓ ржХрж░рзБржи: Varible: ship, space
Goodbye
See you again
Ans is :None of the above



23.Why do we use the super keyword in the case of inheritance?
 To force a call to a method from a subclass
 To force a call to a method from a superclass
 To force a call to a local variable outside of the method
 None of the above






Explanation:
B



24.What is true about constructor inheritance? (Select two)

 Constructors are not inherited
 Constructors are inherited
 Java calls the constructor you asked for, and then the no-argument constructor for every superclass
 You may call constructor again and again






Explanation:
a.ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ржЧрзБрж▓рзЛ ржЗржирж╣рзЗрж░рж┐ржЯ рж╣рзЯ ржирж╛ |
c.ржЬрж╛ржнрж╛ ржЖржкржирж┐ ржпрзЗ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░рзЗрж░ ржЬржирзНржп ржЕржирзБрж░рзЛржз ржХрж░рзЗржЫрзЗржи, ржПржмржВ рждрж╛рж░ржкрж░рзЗ ржкрзНрж░рждрж┐ржЯрж┐ рж╕рзБржкрж╛рж░ржХрзНрж▓рж╛рж╕рзЗрж░ ржЬржирзНржп ржирзЛ-ржЖрж░рзНржЧрзБржорзЗржирзНржЯ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ржХрзЗ ржХрж▓ ржХрж░рзЗред
ржЙржжрж╛рж╣рж░ржгрж╕рзНржмрж░рзВржк, 
ржпржжрж┐ `Child` ржХрзНрж▓рж╛рж╕ржЯрж┐ `Parent` ржХрзНрж▓рж╛рж╕ржХрзЗ ржПржХрзНрж╕ржЯрзЗржирзНржб ржХрж░рзЗ, ржПржмржВ `Parent` ржХрзНрж▓рж╛рж╕ржЯрж┐ `Grandparent` ржХрзНрж▓рж╛рж╕ржХрзЗ ржПржХрзНрж╕ржЯрзЗржирзНржб ржХрж░рзЗ, рждрж╛рж╣рж▓рзЗ `new Child()` ржХрж▓ ржХрж░рж▓рзЗ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ржЧрзБрж▓рзЛ ржПржЗ ржХрзНрж░ржорзЗ ржПржХрзНрж╕рж┐ржХрж┐ржЙржЯ рж╣ржмрзЗ:
1.  `Grandparent()` ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░
2.  `Parent()` ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░
3.  `Child()` ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░
ржПржХржЯрж┐ ржЕржмржЬрзЗржХрзНржЯ рждрзИрж░рж┐рж░ рж╕ржоржпрж╝ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ржЧрзБрж▓рзЛ ржУржкрж░ ржерзЗржХрзЗ ржирж┐ржЪрзЗ (ржЕрж░рзНржерж╛рзО рж╕рзБржкрж╛рж░ржХрзНрж▓рж╛рж╕ ржерзЗржХрзЗ рж╕рж╛ржмржХрзНрж▓рж╛рж╕) ржкрж░рзНржпржирзНржд ржПржХрзНрж╕рж┐ржХрж┐ржЙржЯ рж╣ржпрж╝ред
ржПржЗ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ржЯрж┐ ржЪрж▓рждрзЗ ржерж╛ржХрзЗ ржпрждржХрзНрж╖ржг ржирж╛ ржПржЯрж┐ рж╕ржм ржХрзНрж▓рж╛рж╕рзЗрж░ ржорзВрж▓ ржХрзНрж▓рж╛рж╕ `java.lang.Object` ржкрж░рзНржпржирзНржд ржкрзМржБржЫрж╛рзЯред



25.Which code validate the user input between 1 and 10?
 int number = sc.nextInt(); while (number < 1 OR number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }
 int number = sc.nextInt(); while (number > 1 || number < 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }
 int number = sc.nextInt(); while (number < 1 && number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }
 int number = sc.nextInt(); while (number < 1 || number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }






Explanation:

a. `int number = sc.nextInt(); while (number < 1 || number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }`
*рж▓рзБржкрзЗрж░ ржХрж╛рж░рзНржпржХрж╛рж░рж┐рждрж╛: ржпрждржХрзНрж╖ржг ржкрж░рзНржпржирзНржд ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА 1 ржерзЗржХрзЗ 10 ржПрж░ ржмрж╛ржЗрж░рзЗрж░ ржХрзЛржирзЛ рж╕ржВржЦрзНржпрж╛ ржЗржиржкрзБржЯ ржжрзЗржмрзЗ, рж▓рзБржкржЯрж┐ рждрждржХрзНрж╖ржг ржЪрж▓рждрзЗ ржерж╛ржХржмрзЗ ржПржмржВ ржмрж╛рж░ржмрж╛рж░ ржЗржиржкрзБржЯ ржЪрж╛ржЗржмрзЗред ржпржЦржи ржПржХржЯрж┐ ржмрзИржз рж╕ржВржЦрзНржпрж╛ ржЗржиржкрзБржЯ ржжрзЗржУрзЯрж╛ рж╣ржмрзЗ, рждржЦржи рж▓рзБржкрзЗрж░ рж╢рж░рзНрждржЯрж┐ ржорж┐ржерзНржпрж╛ рж╣ржмрзЗ ржПржмржВ рж▓рзБржкржЯрж┐ ржмржирзНржз рж╣рзЯрзЗ ржпрж╛ржмрзЗред

ржЕржирзНржпрж╛ржирзНржп ржЕржкрж╢ржиржЧрзБрж▓рзЛ ржнрзБрж▓ ржХрж╛рж░ржг:
* `number < 1 OR number > 10`**: ржПржЯрж┐ рж╕ржарж┐ржХ рж▓ржЬрж┐ржХ рж╣рж▓рзЗржУ, ржЬрж╛ржнрж╛рждрзЗ `OR` ржПрж░ ржмржжрж▓рзЗ `||` ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ рж╣рзЯред
* `number > 1 || number < 10`**: ржПржЗ рж▓ржЬрж┐ржХржЯрж┐ ржнрзБрж▓ред ржкрзНрж░рж╛рзЯ ржпрзЗржХрзЛржирзЛ рж╕ржВржЦрзНржпрж╛ржЗ рж╣рзЯ 1-ржПрж░ ржЪрзЗрзЯрзЗ ржмрзЬ ржЕржержмрж╛ 10-ржПрж░ ржЪрзЗрзЯрзЗ ржЫрзЛржЯ рж╣ржмрзЗред рждрж╛ржЗ рж▓рзБржкржЯрж┐ ржПржХржЯрж┐ ржЕржмрж┐рж░рж╛ржо рж▓рзБржк (infinite loop) рждрзИрж░рж┐ ржХрж░ржмрзЗред
* `number < 1 && number > 10`**: ржПржЗ рж▓ржЬрж┐ржХржЯрж┐ ржнрзБрж▓ред ржПржХржЯрж┐ рж╕ржВржЦрзНржпрж╛ ржПржХржЗ рж╕рж╛ржерзЗ 1-ржПрж░ ржЪрзЗрзЯрзЗ ржЫрзЛржЯ ржПржмржВ 10-ржПрж░ ржЪрзЗрзЯрзЗ ржмрзЬ рж╣рждрзЗ ржкрж╛рж░рзЗ ржирж╛ред рждрж╛ржЗ рж▓рзБржкржЯрж┐ ржПржХржмрж╛рж░ржУ ржЪрж▓ржмрзЗ ржирж╛ред


26.The following method compiles and executes but does not work as you might hope. What is wrong with it?
public static int[] copyArray(int[] anArray){
int[] temp = new int[anArray.length];
temp = anArray;
return temp;
}

 The method does not return an array distinct from the given argument array. 
 The temp array declaration is not valid
 The method cannot have a return type
 Nothing is wrong with the code






Explanation:
a



27.What is a line of Java code to sort only the portion of the array named anArray beginning with the index 5 and ending with the index 10?

 Arrays.sort(anArray[5:10]); 
 Arrays.sort(anArray[5], anArray[10]); 
 Arrays.sort(anArray, 5, 10); 
 Arrays.sort(anArray([5] : [10])); 






Explanation:
c



