 10 August 2025


public void openDrawbridge() throws Exception {
try {throw new Exception(“Problem”);} 
if no "catch(Excepton e)" but finally exists for Checked Exception is OK to Compile.
}

public static void main(String[] moat) throws IllegalArgumentException { //to compile, use Exception instead of IllegalArgumentException. or use try-catch(Excepton args) below
new Palace().openDrawbridge();
}
**always check -Duplicate local variable -Unreachable statement -Re throw Exception -exit()

-loop একটি জাভা কীওয়ার্ড (keyword) নয়।  এটি একটি লেবেল (label) হিসেবে ব্যবহার করা যায়, যা জাভাতে একটি লুপকে চিহ্নিত করার জন্য ব্যবহৃত হয়।

-যখন একটি ক্লাস দুটি ইন্টারফেস Implemet করে, এবং উভয় ইন্টারফেসে একই সিগনেচার (signature) সহ একটি ডিফল্ট মেথড থাকে, 
তখন সেই ক্লাসকে অবশ্যই সেই মেথডটিকে ওভাররাইড (override) করতে হবে যাতে দ্বন্দ্ব (conflict) এড়ানো যায়।  ওভারলোড (overload) নয়|

int l = names[1].length();  //ok


abstract class Instrument {public Instrument(int beats) {}} //constructor in abstract class
public class Drum extends Instrument { ** } //**must have a constructor call with super(dt v).

 console: java EchoFirst seed flower plant?
 int result = Arrays.binarySearch(args, args[0]); //output: যেহেতু `"flower"` অ্যারের প্রথম উপাদান, তাই এর ইনডেক্স `0` হয়। if not found (-index)+(-1)

LocalDate date = LocalDate.of(2017, Month.JANUARY, 1);
while (date.getMonth() != Month.APRIL)
date = date.minusMonths(1); date প্রতিবার এক মাস করে পেছনের দিকে যেতে থাকবে|

ব্যবহারকারীর ইনপুট থেকে ১০০০ পর্যন্ত সংখ্যাগুলো প্রিন্ট করার একটি উদাহরণ?
int x = sc.nextInt(); 
do { System.out.println(x); x+=1; } 
while (x <= 1000);
System.out.println(x);

`Period` এর মেথডগুলো `ofYears().ofDays()` এভাবে চেইন করা যায় না।

আপনি যতগুলোই অবজেক্ট তৈরি করুন না কেন- 
স্ট্যাটিক ভেরিয়েবলের শুধুমাত্র একটিই কপি মেমরিতে তৈরি হয়। এই একটি কপিই ক্লাসের সমস্ত অবজেক্টের মধ্যে শেয়ার করা হয়। 
যখন একটি অবজেক্ট এই ভেরিয়েবলের মান পরিবর্তন করে, তখন সেই পরিবর্তনটি অন্য সব অবজেক্টের জন্যও দৃশ্যমান হয়।
উদাহরণস্বরূপ, একটি Student ক্লাসের কথা ভাবুন:
ইনস্ট্যান্স ভেরিয়েবল (Instance Variable): একজন শিক্ষার্থীর নাম, রোল নম্বর বা ঠিকানা। এই তথ্যগুলো প্রত্যেক শিক্ষার্থীর জন্য আলাদা এবং প্রতিটি Student অবজেক্টের নিজস্ব মান থাকে।
স্ট্যাটিক ভেরিয়েবল (Static Variable): একটি স্কুলের মোট শিক্ষার্থীর সংখ্যা। এই সংখ্যাটি কোনো একজন শিক্ষার্থীর জন্য নির্দিষ্ট নয়, বরং এটি সমস্ত শিক্ষার্থীর জন্য একই। যখন একজন নতুন শিক্ষার্থী ভর্তি হয়, তখন এই সংখ্যাটি বাড়ে, এবং এই পরিবর্তনটি সবার জন্য প্রযোজ্য।

`*`, `/`, এবং `%` অপারেটরগুলোর অগ্রাধিকার একই, তাই বাম দিক থেকে ডান দিকে গণনা করা হয়।


যদি Passenger অবজেক্টের একটি অ্যারে passengers থাকে, তাহলে প্রথম অবজেক্টের getName() মেথডের আউটপুট প্রিন্ট করার জন্য একটিমাত্র লাইনের কোড হলো:
passengers[0].getName() 


protected can not be abstract method in Interface


ভালো করে খেয়াল করুন: 
-ship, space are not same
-Phone phone, Phone smartphone are same reference variable

জাভা আপনি যে কনস্ট্রাক্টরের জন্য অনুরোধ করেছেন, এবং তারপরে প্রতিটি সুপারক্লাসের জন্য নো-আর্গুমেন্ট কনস্ট্রাক্টরকে কল করে।
উদাহরণস্বরূপ, 
যদি `Child` ক্লাসটি `Parent` ক্লাসকে এক্সটেন্ড করে, এবং `Parent` ক্লাসটি `Grandparent` ক্লাসকে এক্সটেন্ড করে, তাহলে `new Child()` কল করলে কনস্ট্রাক্টরগুলো এই ক্রমে এক্সিকিউট হবে:
1.  `Grandparent()` কনস্ট্রাক্টর
2.  `Parent()` কনস্ট্রাক্টর
3.  `Child()` কনস্ট্রাক্টর
একটি অবজেক্ট তৈরির সময় কনস্ট্রাক্টরগুলো ওপর থেকে নিচে (অর্থাৎ সুপারক্লাস থেকে সাবক্লাস) পর্যন্ত এক্সিকিউট হয়।
এই প্রক্রিয়াটি চলতে থাকে যতক্ষণ না এটি সব ক্লাসের মূল ক্লাস `java.lang.Object` পর্যন্ত পৌঁছায়।



 `number < 1 OR number > 10` : এটি সঠিক লজিক হলেও, জাভাতে `OR` এর বদলে `||` ব্যবহার করতে হয়।
 `number < 1 AND number > 10`: এটি সঠিক লজিক হলেও, জাভাতে `AND` এর বদলে `&&` ব্যবহার করতে হয়।

শর্তটি ইনপুট যাচাই করার জন্য:
if(ship<10 && space>=2) /ok

while (number < 1 || number > 10); :এটি ব্যবহারকারীর কাছ থেকে 1 থেকে 10 এর মধ্যে একটি বৈধ সংখ্যা না পাওয়া পর্যন্ত বারবার ইনপুট চাওয়ার জন্য সঠিক লজিক। 
while(number < 1 && number > 10); এমন কোনো সংখ্যা নেই যা একই সাথে 1 এর চেয়ে ছোট এবং 10 এর চেয়ে বড় হতে পারে। সুতরাং, এই শর্তটি সব সময়ই মিথ্যা (false) হবে।


Jagged Array বা অসম অ্যারে::প্রতিটি শহরে বিভিন্ন সংখ্যক শাখা অফিস আছে। এই ডেটা সংরক্ষণের জন্য একটি অসম অ্যারে ব্যবহার করা যেতে পারে।
বাস্তব উদাহরণ:
int[][] branchCounts = new int[3][]; //  তিনটি শহরের শাখা অফিসের সংখ্যা ভিন্ন
branchCounts[0] = new int[2];// প্রথম শহরে দুটি শাখা অফিস
// শাখা অফিসের সংখ্যাগুলো নির্ধারণ করা হচ্ছে
branchCounts[0][0] = 50;  // শহরের প্রথম শাখার কর্মী সংখ্যা
branchCounts[0][1] = 75;  // শহরের দ্বিতীয় শাখার কর্মী সংখ্যা


Arrays.sort(anArray, 5, 10);` এর অর্থ হলো:
একটি বিল্ট-ইন মেথড `Arrays.sort()` ব্যবহার করে `anArray` নামের অ্যারেটির নির্দিষ্ট অংশকে সাজানো হচ্ছে। 
এখানে, অ্যারেটির **ইনডেক্স 5 থেকে ইনডেক্স 9 পর্যন্ত** উপাদানগুলো ছোট থেকে বড় ক্রমে সাজানো হবে।
* 5: এটি শুরুর ইনডেক্স (inclusive), অর্থাৎ ইনডেক্স 5 থেকে গণনা শুরু হবে।
* 10: এটি শেষের ইনডেক্স (exclusive), অর্থাৎ ইনডেক্স 9 পর্যন্তই সাজানো হবে, ইনডেক্স 10 বাদ দেওয়া হবে।



-----------



1.class OpenDoorException extends Exception {}
class CableSnapException extends OpenDoorException {}

public class Palace {
public void openDrawbridge() throws Exception {
try {
throw new Exception(“Problem”);
} catch (OpenDoorException e) {
throw new OpenDoorException();
} catch (CableSnapException ex) {
        try {
        throw new OpenDoorException();
        } catch (Exception ex) {
        } finally {
        System.out.println(“Almost done”);
        }
} finally {
throw new RuntimeException(“Unending problem”);
}
}

public static void main(String[] moat) throws IllegalArgumentException {
new Palace().openDrawbridge();
}
}


a.None. The code compiles and produces a stack trace at runtime.
b. One
c. Two
d. Three
e. Four
f. Five






Explanation:
এখানে পাঁচটি কম্পাইলেশন এরর (Compilation Error) আছে।

### এররগুলো হলো:
1.  Duplicate catch block: `catch (OpenDoorException e)` ব্লকটি `catch (CableSnapException ex)` ব্লকের আগে লেখা হয়েছে। 
    যেহেতু `CableSnapException` হলো `OpenDoorException`-এর সাবক্লাস, তাই সাবক্লাসের `catch` ব্লকটি সুপারক্লাসের `catch` ব্লকের আগে থাকতে হবে। 
    কম্পাইলার এটি একটি অপ্রাপ্য (unreachable) কোড হিসেবে দেখবে এবং এরর দেবে।
2.  Duplicate local variable: `catch (CableSnapException ex)` ব্লকের ভেতরে একটি নেস্টেড `catch` ব্লক আছে, যার প্যারামিটার হিসেবে `Exception ex` লেখা হয়েছে। 
    এখানে `ex` নামের ভেরিয়েবলটি বাইরের `catch` ব্লকের `ex` ভেরিয়েবলের সাথে সংঘর্ষ (clash) করছে।
3.  Duplicate local variable: একই কারণে, `try...catch...finally` ব্লকের ভেতরেও `Exception ex` এর ভেরিয়েবল নেমটি পুনরায় ব্যবহার করা হয়েছে, যা অনুমোদিত নয়।
4.  `main` method declaration: `main` মেথডটি `IllegalArgumentException` থ্রো করছে, কিন্তু `new Palace().openDrawbridge()` এররটি `RuntimeException` থ্রো করে, 
    যা `IllegalArgumentException` এর সুপারক্লাস। কম্পাইলার এটি ধরতে পারবে না।
5.  Unreachable statement: `catch (OpenDoorException e)` ব্লকের ভেতরে `throw new OpenDoorException();` 
   এর পরে কোনো কোড লিখলে তা অপ্রাপ্য হবে, কারণ `throw` স্টেটমেন্টটি মেথডের স্বাভাবিক প্রবাহ বন্ধ করে দেয়। 
   এই লাইনের পর `catch (CableSnapException ex)` ব্লকটি অপ্রাপ্য হয়ে যায়, কারণ এটি একটি সাবক্লাসের এক্সসেপশনকে হ্যান্ডেল করার কথা, যা এর সুপারক্লাস দ্বারা ইতিমধ্যেই হ্যান্ডেল করা হয়েছে।
   এই পাঁচটি কারণে কোডটি কম্পাইল হবে না।




2.What is the output of the following?
12: int result = 8;
13: loop: while (result > 7) {
14: result++;
15: do {
16: result–;
17: } while (result > 5);
18: break loop;
19: }
20: System.out.println(result);

 5
 7
 8
 The code does not compile.
 The code compiles but throws an exception at runtime.






Explanation:
loop একটি জাভা কীওয়ার্ড (keyword) নয়। তবে, এটি একটি লেবেল (label) হিসেবে ব্যবহার করা যায়, যা জাভাতে একটি লুপকে চিহ্নিত করার জন্য ব্যবহৃত হয়।


1.  লাইন 12: প্রথমে `result` ভেরিয়েবলটির মান `8` নির্ধারণ করা হয়।
2.  লাইন 13: `while` লুপ শুরু হয়। শর্তটি হলো `result > 7`, যা সত্য (কারণ `8` `7` এর থেকে বড়)। প্রোগ্রাম লুপের ভেতরে প্রবেশ করে।
3.  লাইন 14: `result` এর মান এক বাড়ানো হয়, ফলে নতুন মান হয় `9`।
4.  লাইন 15: একটি `do-while` লুপ শুরু হয়। এই লুপের বৈশিষ্ট্য হলো, শর্ত যাচাই করার আগেই এর ভেতরের কোড অন্তত একবার এক্সিকিউট হয়।
5.  লাইন 16: `do-while` লুপের ভেতরে `result` এর মান এক কমানো হয়, ফলে মান হয় `8`।
6.  লাইন 17: `do-while` লুপের শর্ত (`result > 5`) যাচাই করা হয়। শর্তটি সত্য (`8 > 5`), তাই লুপটি আবার চলে। as ; (comma) end of while (result > 5);
7.  লাইন 16: `result` এর মান আবার এক কমানো হয়, ফলে মান হয় `7`।
8.  লাইন 17: শর্তটি আবার যাচাই করা হয়, যা এখনো সত্য (`7 > 5`), তাই লুপটি তৃতীয়বারের মতো চলে।
9.  লাইন 16: `result` এর মান আবার এক কমানো হয়, ফলে মান হয় `6`।
10. লাইন 17: শর্তটি আবার যাচাই করা হয়, যা এখনো সত্য (`6 > 5`), তাই লুপটি চতুর্থবারের মতো চলে।
11. লাইন 16: `result` এর মান শেষবারের মতো এক কমানো হয়, ফলে মান হয় `5`।
12. লাইন 17: শর্তটি যাচাই করা হয়। এবার এটি মিথ্যা (কারণ `5` `5` এর থেকে বড় নয়)। `do-while` লুপ শেষ হয়।
13. লাইন 18: `break loop;` স্টেটমেন্টটি এক্সিকিউট হয়। এটি লেবেলযুক্ত (`loop`) বাইরের `while` লুপ থেকে প্রোগ্রামকে সরাসরি বের করে নিয়ে আসে।
14. লাইন 20: সবশেষে, `result` এর চূড়ান্ত মান, যা `5`, তা কনসোলে প্রিন্ট করা হয়।



3.What statements are true about compiling a Java class file? (Choose two.)

 If the file does not contain a package statement, then the compiler considers the class part of the java.lang package.
 The compiler assumes every class implicitly imports the java.lang.* package.
 The compiler assumes every class implicitly imports the java.util.* package.
 Java requires every file to declare a package statement.
 Java requires every file to declare at least one import statement.
 If the class declaration does not extend another class, then it implicitly extends the java.lang.Object class.










Explanation:
2. সংকলক (compiler) ধরে নেয় যে প্রতিটি ক্লাস স্বয়ংক্রিয়ভাবে java.lang.* প্যাকেজটি আমদানি (import) করে।
এর অর্থ হলো, আপনি java.lang প্যাকেজের ক্লাসগুলো, যেমন String, System, বা Math, কোনো import স্টেটমেন্ট ছাড়াই সরাসরি ব্যবহার করতে পারেন।
6.যদি ক্লাস ডিক্লেয়ারেশনে অন্য কোনো ক্লাসকে এক্সটেন্ড (extend) না করা হয়, তবে এটি স্বয়ংক্রিয়ভাবে java.lang.Object ক্লাসকে এক্সটেন্ড করে।
জাভাতে, প্রতিটি ক্লাস Object ক্লাসের একটি উপশ্রেণী (subclass)। এটি সমস্ত ক্লাসের জন্য মৌলিক কার্যকারিতা প্রদান করে, যেমন equals() এবং toString() মেথড।




4. What is the output of the following application?
package woods;
interface Plant {
default String grow() { return “Grow!”; }
}
interface Living {
public default String grow() { return “Growing!”; }
}
public class Tree implements Plant, Living { // m1
public String grow(int height) { return “Super Growing!”; }
public static void main(String[] leaves) {
Plant p = new Tree(); // m2
System.out.print(((Living)p).grow()); // m3
}
}

 Grow!
 Growing!
 Super Growing!
 It does not compile because of line m1.
 It does not compile because of line m2.
 It does not compile because of line m3.






Explanation:
কোডটি কম্পাইল হবে না এবং এর প্রধান কারণ হলো লাইন m1-এর Tree ক্লাস ডিক্লেয়ারেশন।
যখন একটি ক্লাস দুটি ইন্টারফেস (Plant এবং Living) ইমপ্লিমেন্ট করে, এবং উভয় ইন্টারফেসে একই সিগনেচার (signature) সহ একটি ডিফল্ট মেথড থাকে, 
তখন সেই ক্লাসকে অবশ্যই সেই মেথডটিকে ওভাররাইড (override) করতে হবে যাতে দ্বন্দ্ব (conflict) এড়ানো যায়।

Tree ক্লাসটি 
-উভয় ইন্টারফেস ইমপ্লিমেন্ট করলেও, এটি grow() মেথডের জন্য নিজস্ব কোনো ইমপ্লিমেন্টেশন দেয়নি।
-public String grow(int height) মেথডটি একটি ওভারলোড (overload), ওভাররাইড (override) নয়, কারণ এর সিগনেচার ভিন্ন (এটি একটি int প্যারামিটার গ্রহণ করে)।


5.Which statements best describe the result of this code? (Choose two.)
package nyc;
public class TouristBus {
public static void main(String… args) {
String[] nycTourLoops = new String[] { “Downtown”, “Uptown”, “Brooklyn” };
String[] times = new String[] { “Day”, “Night” };
for (int i = 0, j = 0; i < nycTourLoops.length; i++, j++) 
System.out.println(nycTourLoops[i] + " " + times[j]); } }

 The println causes one line of output.
 The println causes two lines of output.
 The println causes three lines of output.
 The code terminates successfully.
 The code throws an exception at runtime.






Explanation:
 গুরুত্বপূর্ণ: লুপের শর্তটি nycTourLoops অ্যারের দৈর্ঘ্যের উপর নির্ভর করে, কিন্তু ভিতরে times অ্যারেটি j index ব্যবহার করে। যেহেতু times অ্যারের দৈর্ঘ্য nycTourLoops অ্যারের চেয়ে কম, 
 তাই লুপের তৃতীয় পুনরাবৃত্তিতে j এর মান 2 হলে times[j] অ্যাক্সেস করার সময় একটি ArrayIndexOutOfBoundsException হয়। তাই, কোডটি সফলভাবে শেষ হয় না, বরং একটি ব্যতিক্রম (exception) তৈরি করে।

অতএব, সঠিক বিবৃতি দুটি হলো:
The println causes two lines of output. (println দুটি লাইনে আউটপুট তৈরি করে।)
The code throws an exception at runtime. (কোডটি রানটাইমে একটি ব্যতিক্রম তৈরি করে।)


6.What is the result of the following?
package calendar;
public class Seasons {
public static void seasons(String… names) {
int l = names[1].length(); // s1
System.out.println(names[l]); // s2
}
public static void main(String[] args) {
seasons(“Summer”, “Fall”, “Winter”, “Spring”);
}
}






Explanation:
কোডটি কম্পাইল হয়। লাইন s1 কিছুটা ট্রিকি কারণ অ্যারের জন্য length ব্যবহৃত হয় এবং স্ট্রিংয়ের জন্য length() ব্যবহৃত হয়। লাইন s1-এ Fall-এর দৈর্ঘ্য একটি ভেরিয়েবলে সংরক্ষণ করা হয়, যা 4।
 লাইন s2-এ ArrayIndexOutOfBoundsException থ্রো করা হয় কারণ 4 হল একটি চারটি এলিমেন্ট বিশিষ্ট অ্যারের জন্য অবৈধ ইনডেক্স। 
 মনে রাখবেন, ইনডেক্স গণনা শূন্য থেকে শুরু হয়। তাই, ফলাফল: রানটাইমে ArrayIndexOutOfBoundsException।



7.How many lines of the following application contain compilation errors?
1: package percussion;
2:
3: interface MakesNoise {}

4: abstract class Instrument implements MakesNoise {
5: public Instrument(int beats) {}
6: public void play() {}
7: }

8: public class Drum extends Instrument {
9: public void play(int count) {}
10: public void concert() {
11: super.play(5);
12: }
13: public static void main(String[] beats) {
14: MakesNoise mn = new Drum();
15: mn.concert();
16: }
17: }

 None. The code compiles and runs without issue.
 One
 Two
 Three
 Four






Explanation:
* লাইন ৫: `Instrument` ক্লাসের কোনো ডিফল্ট কনস্ট্রাক্টর নেই। তাই, `Drum` ক্লাসকে তার নিজের কনস্ট্রাক্টর থেকে `super(int)` কল করতে হবে, যা এখানে অনুপস্থিত।
* লাইন ১১: `Instrument` ক্লাসের `play()` মেথডটি কোনো আর্গুমেন্ট গ্রহণ করে না, কিন্তু এখানে `super.play(5)` কল করে একটি ইন্টিজার আর্গুমেন্ট পাঠানো হচ্ছে।
* লাইন ১৫: `mn` ভেরিয়েবলটি `MakesNoise` টাইপের, যেটিতে `concert()` নামে কোনো মেথড নেই। তাই, কম্পাইলার এই কলটি খুঁজে পাবে না।


8.What is the output of the following when run as java EchoFirst seed flower plant?
package unix;
import java.util.*;
public class EchoFirst {
public static void main(String[] args) {
Arrays.sort(args);
int result = Arrays.binarySearch(args, args[0]);
System.out.println(result);
}
}

 0
 1
 2
 The code does not compile.
 The code compiles but throws an exception at runtime.
 The output is not guaranteed.






Explanation:
1.  প্রথমে, `Arrays.sort(args)` কমান্ডের কারণে `args` অ্যারেটি অ্যালফাবেটিক্যালি সাজানো হয়, যা দাঁড়ায় `["flower", "plant", "seed"]`।
2.  এরপর, `args[0]` এর মান হয় `"flower"`।
3.  `Arrays.binarySearch(args, args[0])` কমান্ডটি সাজানো অ্যারেতে `"flower"` এর অবস্থান খোঁজে।
4.  যেহেতু `"flower"` অ্যারের প্রথম উপাদান, তাই এর ইনডেক্স `0` হয়।

এজন্য, আউটপুট `0` প্রিন্ট করা হয়।


9. What is the output of the following?
14: int count = 0;
15: LocalDate date = LocalDate.of(2017, Month.JANUARY, 1);
16: while (date.getMonth() != Month.APRIL)
17: date = date.minusMonths(1);
18: count++;
19: System.out.println(count);

 0
 1
 3
 9
 This is an infinite loop.
 The code does not compile.






Explanation:
 while (date.getMonth() != Month.APRIL) { // একটি লুপ যা তারিখের মাস এপ্রিল না হওয়া পর্যন্ত চলবে             
        date = date.minusMonths(1);// তারিখ থেকে এক মাস কমিয়ে আপডেট করা হয়
date প্রতিবার এক মাস করে পেছনের দিকে যেতে থাকবে, লুপের শর্তটিও date এখন জানুয়ারি,ডিসেম্বর ....মোট ৯ বার লুপ চলার পর, date এর মাস এপ্রিল হয়। তখন লুপের শর্তটি মিথ্যা হয়ে যায় এবং লুপটি বন্ধ হয়ে যায়।

লুপ শেষ হওয়ার পর প্রোগ্রামটি তার পরের লাইনে চলে আসে, যা হলো count++;(count এর মান ০ থেকে বাড়িয়ে ১ করে)।
সবশেষে, System.out.println(count) লাইনটি count এর চূড়ান্ত মান, অর্থাৎ 1 প্রিন্ট করে।
সুতরাং, লুপটি শেষ হয় ঠিকই, কিন্তু count ভেরিয়েবলটি লুপের বাইরে থাকার কারণে শুধুমাত্র একবারই বাড়ে।







10.Which code will print the numbers up to 1000 (included) starting from user input, assume that user input is less than 1000? 

 int x = sc.nextInt(); do { System.out.println(x); x--; } while (x < 1000); System.out.println(x);
 int x = sc.nextInt(); do { System.out.println(x); x++; } while (x < 1000); System.out.println(x);
 int x = sc.nextInt(); do { System.out.println(x); x+=1; } while (x <= 1000); System.out.println(x);
 None of the above






Explanation:




11.There is an error in the following code. How to fix that error?
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int num = sc.nextInt();

if (num == 7) {
boolean seven = true;
} else {
boolean seven = false;
}
System.out.println(seven);
}

 "else" statement needs a boolean condition
 boolean variable "seven" has to be changed with another name
 boolean variable "seven" is a local variable. It needs to declared outside of if statement
 if statement conditions has to be like num.equals(7)






Explanation:
এখানে প্রধান ত্রুটিটি হলো boolean variable "seven" is a local variable. It needs to declared outside of if statement।




12.For the given Circle class, which of the following method defines area of the circle? 
public class Circle{
double radius = 10.0;
double x = 100.0;
double y = 100.0;

// area method goes here
}

 double getArea(int radius) {         return Math.PI * radius * radius;     }
 double getArea() { return PI * radius * radius; }
 double getArea() { return Math.PI * radius * radius; }
 None of the above






Explanation:
সঠিক উত্তর হলো: 
double getArea() { return Math.PI * radius * radius; }


13.How many lines contain a compile error?
1: import java.time.*;
2: import java.time.format.*;
3:
4: public class HowLong {
5: public void main(String h) {
6: LocalDate newYears = new LocalDate(2017, 1, 1);
7: Period period = Period.ofYears(1).ofDays(1);
8: DateTimeFormat format = DateTimeFormat.ofPattern(“MM-dd-yyyy”);
9: System.out.print(format.format(newYears.minus(period)));
10: }
11: }

 None
 One
 Two
 Three
 Four
 Five








Explanation:
1.  লাইন ৫: `main` মেথডের সঠিক সিগনেচার `public static void main(String[] args)` নয়।
2.  লাইন ৬: `LocalDate` ক্লাসের কোনো পাবলিক কনস্ট্রাক্টর নেই, এর বদলে `LocalDate.of()` ব্যবহার করতে হয়।
3.  লাইন ৭: `Period` এর মেথডগুলো `ofYears().ofDays()` এভাবে চেইন করা যায় না।
4.  লাইন ৮: সঠিক ক্লাসটির নাম `DateTimeFormat` নয়, এটি হবে `DateTimeFormatter`।
প্রদত্ত কোডে মোট 4 লাইনে কম্পাইল এরর (compile error) আছে।


14.Which is the correct statement about static variable? 
 -There may be any number of copies of static variable that can be shared among all the instances of the class
 -There is always exactly one copy of a static variable is created and shared among all the instances of the class
 -Static variables are primitive type 
 -None of the above






Explanation:
একটি স্ট্যাটিক ভেরিয়েবল ক্লাসের সাথে সম্পর্কিত, কোনো নির্দিষ্ট অবজেক্টের (instance) সাথে নয়।
আপনি যতগুলোই অবজেক্ট তৈরি করুন না কেন, স্ট্যাটিক ভেরিয়েবলের শুধুমাত্র একটিই কপি মেমরিতে তৈরি হয়।
এই একটি কপিই ক্লাসের সমস্ত অবজেক্টের মধ্যে শেয়ার করা হয়। যখন একটি অবজেক্ট এই ভেরিয়েবলের মান পরিবর্তন করে, তখন সেই পরিবর্তনটি অন্য সব অবজেক্টের জন্যও দৃশ্যমান হয়।
সঠিক উত্তর হলো: "There is always exactly one copy of a static variable is created and shared among all the instances of the class" (একটি স্ট্যাটিক ভেরিয়েবলের সবসময় ঠিক একটি কপি তৈরি হয় যা ক্লাসের সমস্ত ইনস্ট্যান্সের মধ্যে শেয়ার করা হয়)।


15.What is printed by the following code snippet?
int fish = 1 + 2 * 5>=2 ? 4 : 2;
int mammals = 3 < 3 ? 1 : 5>=5 ? 9 : 7;
System.out.print(fish+mammals+””);

 49
 13
 18
 99
 It does not compile.






Explanation:
B.13


16.What is the output for this code line? 
System.out.println(30/2*5%4);  

 1
 15
 0
 3







Explanation:
জাভাতে, `*`, `/`, এবং `%` অপারেটরগুলোর অগ্রাধিকার একই, তাই বাম দিক থেকে ডান দিকে গণনা করা হয়।
1.  প্রথমে, `30/2` গণনা করা হয়, যার ফলাফল `15`।
2.  এরপর, `15*5` গণনা করা হয়, যার ফলাফল `75`।
3.  সবশেষে, `75%4` গণনা করা হয়, যার ফলাফল `3` (কারণ 75 কে 4 দিয়ে ভাগ করলে ভাগশেষ 3 থাকে)।




17.What is the output of the following code?
public static void main(String[] args) {
final String cell = “a”;
String foo = new String(“a”);
final String bell = new String(foo);
System.out.print((cell==bell)+” “+cell.equals(bell));
}

 false true
 false false
 true true
 Code will not compile due to error








Explanation:
check carefully: false true


18.Given that SC is an scanner object. Which of the following code stores users value into an array? 

 int[] d = new int[10]; for (int i = 0; i < d.length; i++) { d[i].nextInt(); }
 int[] d = new Int[10]; for (int i = 0; i < d.length; i++) { d[i] = SC.nextInt(); }
 int[] d = new int[10]; d[i] = SC.nextInt();
 int[] d = new int[10]; for (int i = 0; i < d.length; i++) { d[i] = SC.nextInt(); }






Explanation:
* এই কোডটি একটি `for` লুপ ব্যবহার করে।
* লুপটি অ্যারের প্রতিটি ইনডেক্স (`i=0` থেকে `9` পর্যন্ত) দিয়ে চলে।
* `SC.nextInt()` ব্যবহারকারীর কাছ থেকে একটি পূর্ণসংখ্যা ইনপুট নেয়।
* প্রতিটি ইনপুটকে `d[i]` এর মাধ্যমে অ্যারের সঠিক স্থানে সংরক্ষণ করে।
-last one





19.Suppose you have a variable named passengers which stores an array of objects of type Passenger.
 What is a single line of code that will print the output of the getName() method for the first Passenger object in the passengers array?

 System.out.println(passengers.getName()); 
 System.out.println(passengers[0].getName()); 
 System.out.println(passengers.getName([0])); 
 System.out.println(getName(0));







Explanation:
 System.out.println(passengers[0].getName()); gives the first element of the given array.











20.What does this code output? 
public void foo(int[] x) {
x[0] = x[0] + 1;
}
int[] a = new int[10];
int[] b = a;
foo(a);
System.out.println(a[0]+” “+b[0]);

 0 0
 1 1
 1 0
 null null






Explanation:
2



21.Given the application below, which lines do not compile? (Choose three.)
package furryfriends;
interface Friend {
protected String getName(); // h1
}
class Cat implements Friend {
String getName() { // h2
return “Kitty”;
}
}
public class Dog implements Friend {
String getName() throws RuntimeException { // h3
return “Doggy”;
}
public static void main(String[] adoption) {
Friend friend = new Dog(); // h4
System.out.print(((Cat)friend).getName()); // h5
System.out.print(((Dog)null).getName()); // h6
}
}

 Line h1
 Line h2
 Line h3
 Line h4
 Line h5
 Line h6






Explanation:
interface abstract method Can not be protected
so output: 1,2,3




22.What is the result of compiling and executing the following application?

public class Cowboy {
private int space = 5;
private double ship = space < 2 ? 1 : 10; // g1 

public void printMessage() { 
    if(ship>1) {
        System.out.println(“Goodbye”);
   } 

if(ship<10 && space>=2) System.out.println(“Hello”); // g2
else System.out.println(“See you again”);
}

public static final void main(String… stars) {
new Cowboy().printMessage();
}
}

 It only prints Hello.
 It only prints Goodbye.
 It only prints See you again.
 It does not compile because of line g1.
 It does not compile because of line g2.
 None of the above






Explanation:
ভালো করে খেয়াল করুন: Varible: ship, space
Goodbye
See you again
Ans is :None of the above



23.Why do we use the super keyword in the case of inheritance?
 To force a call to a method from a subclass
 To force a call to a method from a superclass
 To force a call to a local variable outside of the method
 None of the above






Explanation:
B



24.What is true about constructor inheritance? (Select two)

 Constructors are not inherited
 Constructors are inherited
 Java calls the constructor you asked for, and then the no-argument constructor for every superclass
 You may call constructor again and again






Explanation:
a.কনস্ট্রাক্টরগুলো ইনহেরিট হয় না |
c.জাভা আপনি যে কনস্ট্রাক্টরের জন্য অনুরোধ করেছেন, এবং তারপরে প্রতিটি সুপারক্লাসের জন্য নো-আর্গুমেন্ট কনস্ট্রাক্টরকে কল করে।
উদাহরণস্বরূপ, 
যদি `Child` ক্লাসটি `Parent` ক্লাসকে এক্সটেন্ড করে, এবং `Parent` ক্লাসটি `Grandparent` ক্লাসকে এক্সটেন্ড করে, তাহলে `new Child()` কল করলে কনস্ট্রাক্টরগুলো এই ক্রমে এক্সিকিউট হবে:
1.  `Grandparent()` কনস্ট্রাক্টর
2.  `Parent()` কনস্ট্রাক্টর
3.  `Child()` কনস্ট্রাক্টর
একটি অবজেক্ট তৈরির সময় কনস্ট্রাক্টরগুলো ওপর থেকে নিচে (অর্থাৎ সুপারক্লাস থেকে সাবক্লাস) পর্যন্ত এক্সিকিউট হয়।
এই প্রক্রিয়াটি চলতে থাকে যতক্ষণ না এটি সব ক্লাসের মূল ক্লাস `java.lang.Object` পর্যন্ত পৌঁছায়।



25.Which code validate the user input between 1 and 10?
 int number = sc.nextInt(); while (number < 1 OR number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }
 int number = sc.nextInt(); while (number > 1 || number < 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }
 int number = sc.nextInt(); while (number < 1 && number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }
 int number = sc.nextInt(); while (number < 1 || number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }






Explanation:

a. `int number = sc.nextInt(); while (number < 1 || number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }`
*লুপের কার্যকারিতা: যতক্ষণ পর্যন্ত ব্যবহারকারী 1 থেকে 10 এর বাইরের কোনো সংখ্যা ইনপুট দেবে, লুপটি ততক্ষণ চলতে থাকবে এবং বারবার ইনপুট চাইবে। যখন একটি বৈধ সংখ্যা ইনপুট দেওয়া হবে, তখন লুপের শর্তটি মিথ্যা হবে এবং লুপটি বন্ধ হয়ে যাবে।

অন্যান্য অপশনগুলো ভুল কারণ:
* `number < 1 OR number > 10`**: এটি সঠিক লজিক হলেও, জাভাতে `OR` এর বদলে `||` ব্যবহার করতে হয়।
* `number > 1 || number < 10`**: এই লজিকটি ভুল। প্রায় যেকোনো সংখ্যাই হয় 1-এর চেয়ে বড় অথবা 10-এর চেয়ে ছোট হবে। তাই লুপটি একটি অবিরাম লুপ (infinite loop) তৈরি করবে।
* `number < 1 && number > 10`**: এই লজিকটি ভুল। একটি সংখ্যা একই সাথে 1-এর চেয়ে ছোট এবং 10-এর চেয়ে বড় হতে পারে না। তাই লুপটি একবারও চলবে না।


26.The following method compiles and executes but does not work as you might hope. What is wrong with it?
public static int[] copyArray(int[] anArray){
int[] temp = new int[anArray.length];
temp = anArray;
return temp;
}

 The method does not return an array distinct from the given argument array. 
 The temp array declaration is not valid
 The method cannot have a return type
 Nothing is wrong with the code






Explanation:
মেথডটি প্রদত্ত আর্গুমেন্ট অ্যারে থেকে ভিন্ন কোনো অ্যারে রিটার্ন করে না-The method does not return an array distinct from the given argument array ।



27.What is a line of Java code to sort only the portion of the array named anArray beginning with the index 5 and ending with the index 10?

 Arrays.sort(anArray[5:10]); 
 Arrays.sort(anArray[5], anArray[10]); 
 Arrays.sort(anArray, 5, 10); 
 Arrays.sort(anArray([5] : [10])); 






Explanation:
c



