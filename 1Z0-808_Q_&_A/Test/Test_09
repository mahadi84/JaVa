 10 August 2025


ржкрж░рзАржХрзНрж╖рж╛ржпрж╝ ржПржЗ ржзрж░ржирзЗрж░ ржкрзНрж░рж╢рзНржиржЧрзБрж▓рзЛрж░ ржЙрждрзНрждрж░ ржжрзЗржУржпрж╝рж╛рж░ рж╕ржоржпрж╝ ржХрж┐ржЫрзБ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг ржмрж┐рж╖ржпрж╝ ржорж╛ржерж╛ржпрж╝ рж░рж╛ржЦрж╛ ржЬрж░рзБрж░рж┐:

1.  **ржХрзЛржбржЯрж┐ ржХржорзНржкрж╛ржЗрж▓ рж╣ржмрзЗ ржХрж┐ ржирж╛ рждрж╛ ржкрзНрж░ржержорзЗ ржжрзЗржЦрзБржи:** ржкрзНрж░рж╢рзНржиржЧрзБрж▓рзЛрж░ ржПржХржЯрж┐ ржмржбрж╝ ржЕржВрж╢ ржерж╛ржХрзЗ ржХржорзНржкрж╛ржЗрж▓рзЗрж╢ржи ржПрж░рж░ (compilation error) ржирж┐ржпрж╝рзЗред рждрж╛ржЗ, ржХрзЛржбржЯрж┐ рж▓рж╛ржЗржи ржмрж╛ржЗ рж▓рж╛ржЗржи ржкржбрж╝рзЗ ржЬрж╛ржнрж╛рж░ рж╕рж┐ржиржЯрзНржпрж╛ржХрзНрж╕ (syntax) ржмрж╛ ржирж┐ржпрж╝ржо ржЕржирзБржпрж╛ржпрж╝рзА ржХрзЛржирзЛ ржнрзБрж▓ ржЖржЫрзЗ ржХрж┐ ржирж╛ рждрж╛ ржкрзНрж░ржержорзЗ ржпрж╛ржЪрж╛ржЗ ржХрж░рзБржиред
    * `static`, `final`, `private` ржЗрждрзНржпрж╛ржжрж┐ ржоржбрж┐ржлрж╛ржпрж╝рж╛рж░ржЧрзБрж▓рзЛ ржХрзЛржерж╛ржпрж╝ ржПржмржВ ржХрзАржнрж╛ржмрзЗ ржмрзНржпржмрж╣рзГржд рж╣ржпрж╝рзЗржЫрзЗ рждрж╛ ржжрзЗржЦрзБржиред
    * ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ рж╕рзНржХрзЛржк (variable scope) ржПржмржВ ржЗржирж╣рзЗрж░рж┐ржЯрзНржпрж╛ржирзНрж╕рзЗрж░ ржирж┐ржпрж╝ржо (ржпрзЗржоржи: ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ ржЗржирж╣рзЗрж░рж┐ржЯ рж╣ржпрж╝ ржирж╛) ржнрж╛рж▓рзЛржнрж╛ржмрзЗ ржоржирзЗ рж░рж╛ржЦрзБржиред
    * ржЕржкрж╛рж░рзЗржЯрж░ржжрзЗрж░ ржЕржЧрзНрж░рж╛ржзрж┐ржХрж╛рж░ (precedence) ржПржмржВ ржЕрзНржпрж╛рж╕рзЛрж╕рж┐ржпрж╝рзЗржЯрж┐ржнрж┐ржЯрж┐ (associativity) рж╕ржорзНржкрж░рзНржХрзЗ рж╕рзНржкрж╖рзНржЯ ржзрж╛рж░ржгрж╛ рж░рж╛ржЦрзБржи (ржпрзЗржоржи: `30/2*5%4` ржПрж░ ржорждрзЛ рж╕ржорж╕рзНржпрж╛ рж╕ржорж╛ржзрж╛ржирзЗрж░ ржЬржирзНржп)ред
    * ржХрзЛржи ржЕржкрж╛рж░рзЗржЯрж░ ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ рждрж╛ ржмрзБржЭрзБржи (ржпрзЗржоржи: `==` рж░рзЗржлрж╛рж░рзЗржирзНрж╕ рждрзБрж▓ржирж╛ ржХрж░рзЗ, ржЖрж░ `equals()` ржХржирзНржЯрзЗржирзНржЯ рждрзБрж▓ржирж╛ ржХрж░рзЗ)ред

2.  **рж▓ржЬрж┐ржХ ржмрж╛ ржпрзБржХрзНрждрж┐ ржЕржирзБрж╕рж░ржг ржХрж░рзБржи:** ржпржжрж┐ ржХрзЛржбржЯрж┐ ржХржорзНржкрж╛ржЗрж▓ рж╣ржпрж╝, рждржмрзЗ рж▓рзБржк, ржХржирзНржбрж┐рж╢ржирж╛рж▓ рж╕рзНржЯрзЗржЯржорзЗржирзНржЯ (if-else), ржПржмржВ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ ржорж╛ржи ржХрзАржнрж╛ржмрзЗ ржкрж░рж┐ржмрж░рзНрждрж┐ржд рж╣ржЪрзНржЫрзЗ рждрж╛рж░ ржПржХржЯрж┐ ржорж╛ржирж╕рж┐ржХ ржмрж╛ ржХрж╛ржЧржЬрзЗ-ржХрж▓ржорзЗ ржЯрзНрж░рзЗрж╕рж┐ржВ (tracing) ржХрж░рзБржиред
    * рж▓рзБржкрзЗрж░ рж╢рж░рзНржд (`while`, `for`) ржХржЦржи рж╕рждрзНржп ржмрж╛ ржорж┐ржерзНржпрж╛ рж╣ржЪрзНржЫрзЗ рждрж╛ ржЦрзЗрзЯрж╛рж▓ ржХрж░рзБржиред
    * ржХрзЛржи ржорзЗржержб ржХржЦржи ржХрж▓ рж╣ржЪрзНржЫрзЗ ржПржмржВ ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░ржЧрзБрж▓рзЛ ржХрзАржнрж╛ржмрзЗ ржкрж╛рж╕ рж╣ржЪрзНржЫрзЗ рждрж╛ ржмрзБржЭрзБржиред
    * рж▓ржЬрж┐ржХрзНржпрж╛рж▓ ржЕржкрж╛рж░рзЗржЯрж░ (`&&`, `||`) ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ рждрж╛ ржЬрж╛ржирзБржиред `&&` рж╢рж░рзНржЯ-рж╕рж╛рж░рзНржХрж┐ржЯ (short-circuit) ржХрж░рзЗ, ржЖрж░ `||` ржУ ржПржХржЗ ржХрж╛ржЬ ржХрж░рзЗред

3.  **ржмрзНржпрждрж┐ржХрзНрж░ржо (Exceptions) рж╕ржорзНржкрж░рзНржХрзЗ рж╕ржЪрзЗрждржи ржерж╛ржХрзБржи:** ржХржЦржи ржПржХржЯрж┐ ржХрзЛржб рж░рж╛ржиржЯрж╛ржЗржо ржмрзНржпрждрж┐ржХрзНрж░ржо (runtime exception) рждрзИрж░рж┐ ржХрж░рждрзЗ ржкрж╛рж░рзЗ рждрж╛ ржнрж╛рж▓рзЛржнрж╛ржмрзЗ ржмрзБржЭрзБржиред
    * `ArrayIndexOutOfBoundsException`: ржЕрзНржпрж╛рж░рзЗрж░ рж╕рзАржорж╛рж░ ржмрж╛ржЗрж░рзЗ ржХрзЛржирзЛ ржЗржиржбрзЗржХрзНрж╕ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржХрж░рж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рж▓рзЗ ржПржЯрж┐ ржШржЯрзЗред
    * `NullPointerException`: ржХрзЛржирзЛ `null` ржЕржмржЬрзЗржХрзНржЯрзЗрж░ ржУржкрж░ ржорзЗржержб ржХрж▓ ржХрж░рж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рж▓рзЗ ржПржЯрж┐ ржШржЯрзЗред
    * ржЗржирж╣рзЗрж░рж┐ржЯрзНржпрж╛ржирзНрж╕рзЗрж░ ржХрзНрж╖рзЗрждрзНрж░рзЗ `catch` ржмрзНрж▓ржХрзЗрж░ ржХрзНрж░ржо (order) ржЦрзБржмржЗ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржгред рж╕рж╛ржмржХрзНрж▓рж╛рж╕рзЗрж░ ржмрзНржпрждрж┐ржХрзНрж░ржоржХрзЗ рж╕рзБржкрж╛рж░ржХрзНрж▓рж╛рж╕рзЗрж░ ржмрзНржпрждрж┐ржХрзНрж░ржорзЗрж░ `catch` ржмрзНрж▓ржХрзЗрж░ ржЖржЧрзЗ ржерж╛ржХрждрзЗ рж╣ржмрзЗред

---

### ржЙрждрзНрждрж░ ржжрзЗржУржпрж╝рж╛рж░ ржХрзМрж╢рж▓ (Answering Strategy) ЁЯОп

* **ржзрж╛ржк 1: ржХржорзНржкрж╛ржЗрж▓рзЗрж╢ржи ржПрж░рж░ ржЪрзЗржХ ржХрж░рзБржи:** ржкрзНрж░ржержорзЗ ржкрзНрж░рждрж┐ржЯрж┐ рж▓рж╛ржЗржи ржжрзЗржЦрзБржи ржПржмржВ ржЬрж╛ржнрж╛рж░ ржХржорзНржкрж╛ржЗрж▓рж╛рж░рзЗрж░ ржжрзГрж╖рзНржЯрж┐ржХрзЛржг ржерзЗржХрзЗ ржХрзЛржирзЛ ржнрзБрж▓ ржЖржЫрзЗ ржХрж┐ ржирж╛ рждрж╛ ржЪрж┐рж╣рзНржирж┐ржд ржХрж░рзБржиред ржпрзЗржоржи: `2:00` ржмрж╛ `OR` ржПрж░ ржмрзНржпржмрж╣рж╛рж░ред ржпржжрж┐ ржХржорзНржкрж╛ржЗрж▓рзЗрж╢ржи ржПрж░рж░ ржерж╛ржХрзЗ, рждржмрзЗ ржЕржирзНржп ржХрзЛржирзЛ ржЕржкрж╢ржи ржжрзЗржЦрж╛рж░ ржжрж░ржХрж╛рж░ ржирзЗржЗ, рж╕рзЗржЯрж┐ржЗ ржЙрждрзНрждрж░ред
* **ржзрж╛ржк 2: рж▓ржЬрж┐ржХрзНржпрж╛рж▓ ржлрзНрж▓рзЛ ржЯрзНрж░рзЗрж╕ ржХрж░рзБржи:** ржпржжрж┐ ржХрзЛржирзЛ ржХржорзНржкрж╛ржЗрж▓рзЗрж╢ржи ржПрж░рж░ ржирж╛ ржерж╛ржХрзЗ, рждржмрзЗ ржХрзЛржбржЯрж┐ ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ рждрж╛ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ ржЕржирзБрж╕рж░ржг ржХрж░рзБржиред ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ ржорж╛ржи ржкрж░рж┐ржмрж░рзНрждржи, рж▓рзБржкрзЗрж░ ржкрзБржирж░рж╛ржмрзГрждрзНрждрж┐, ржПржмржВ ржХрзЛржи ржХрзЛржб ржмрзНрж▓ржХ ржХрж╛рж░рзНржпржХрж░ рж╣ржЪрзНржЫрзЗ рждрж╛ ржоржирзЛржпрзЛржЧ ржжрж┐рзЯрзЗ ржжрзЗржЦрзБржиред
* **ржзрж╛ржк 3: ржЖржЙржЯржкрзБржЯ ржмрж╛ ржлрж▓рж╛ржлрж▓ ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рзБржи:** ржХрзЛржбрзЗрж░ ржПржХрзНрж╕рж┐ржХрж┐ржЙрж╢ржи рж╢рзЗрж╖ рж╣ржУрзЯрж╛рж░ ржкрж░ ржХрзА ржкрзНрж░рж┐ржирзНржЯ рж╣ржмрзЗ ржмрж╛ ржХрзА ржлрж▓рж╛ржлрж▓ ржЖрж╕ржмрзЗ рждрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзБржиред `System.out.println` ржмрж╛ `System.out.print` рж╕рзНржЯрзЗржЯржорзЗржирзНржЯржЧрзБрж▓рзЛ ржХрзА ржлрж▓рж╛ржлрж▓ ржжрзЗржмрзЗ рждрж╛ ржмрзБржЭрзБржиред
* **ржзрж╛ржк 4: ржмрж┐ржХрж▓рзНржкржЧрзБрж▓рзЛ ржпрж╛ржЪрж╛ржЗ ржХрж░рзБржи:** ржЖржкржирж╛рж░ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрж░рж╛ ржлрж▓рж╛ржлрж▓рзЗрж░ рж╕рж╛ржерзЗ ржжрзЗржУржпрж╝рж╛ ржмрж┐ржХрж▓рзНржкржЧрзБрж▓рзЛ ржорж┐рж▓рж┐рзЯрзЗ ржжрзЗржЦрзБржиред ржкрзНрж░рж╛ржпрж╝рж╢ржЗ, ржПржХржЯрж┐ ржмрж┐ржХрж▓рзНржк ржЖржкржирж╛рж░ рж╕ржарж┐ржХ ржлрж▓рж╛ржлрж▓рзЗрж░ рж╕рж╛ржерзЗ ржорж┐рж▓рзЗ ржпрж╛ржмрзЗред рждржмрзЗ, ржпржжрж┐ ржЖржкржирж╛рж░ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрзЛржирзЛ ржмрж┐ржХрж▓рзНржкрзЗрж░ рж╕рж╛ржерзЗ ржирж╛ ржорзЗрж▓рзЗ, рждржмрзЗ ржкрзНрж░рж╢рзНржиржЯрж┐ ржПржмржВ ржЖржкржирж╛рж░ ржмрж┐рж╢рзНрж▓рзЗрж╖ржгржЯрж┐ ржЖржмрж╛рж░ ржкрж░рзАржХрзНрж╖рж╛ ржХрж░рзБржиред

ржПржЗ ржХрзМрж╢рж▓ржЧрзБрж▓рзЛ ржЕржирзБрж╕рж░ржг ржХрж░рж▓рзЗ ржЖржкржирж┐ ржЬрж╛ржнрж╛ ржкрж░рзАржХрзНрж╖рж╛рж░ ржкрзНрж░рж╢рзНржиржЧрзБрж▓рзЛрж░ ржЙрждрзНрждрж░ рж╕ржарж┐ржХржнрж╛ржмрзЗ ржПржмржВ ржжрзНрж░рзБржд ржжрж┐рждрзЗ ржкрж╛рж░ржмрзЗржиред



1.class OpenDoorException extends Exception {}
class CableSnapException extends OpenDoorException {}

public class Palace {
public void openDrawbridge() throws Exception {
try {
throw new Exception(тАЬProblemтАЭ);
} catch (OpenDoorException e) {
throw new OpenDoorException();
} catch (CableSnapException ex) {
        try {
        throw new OpenDoorException();
        } catch (Exception ex) {
        } finally {
        System.out.println(тАЬAlmost doneтАЭ);
        }
} finally {
throw new RuntimeException(тАЬUnending problemтАЭ);
}
}

public static void main(String[] moat) throws IllegalArgumentException {
new Palace().openDrawbridge();
}
}


a.None. The code compiles and produces a stack trace at runtime.
b. One
c. Two
d. Three
e. Four
f. Five






Explanation:
ржПржЦрж╛ржирзЗ ржкрж╛ржБржЪржЯрж┐ ржХржорзНржкрж╛ржЗрж▓рзЗрж╢ржи ржПрж░рж░ (Compilation Error) ржЖржЫрзЗред

### ржПрж░рж░ржЧрзБрж▓рзЛ рж╣рж▓рзЛ:
1.  Duplicate catch block: `catch (OpenDoorException e)` ржмрзНрж▓ржХржЯрж┐ `catch (CableSnapException ex)` ржмрзНрж▓ржХрзЗрж░ ржЖржЧрзЗ рж▓рзЗржЦрж╛ рж╣ржпрж╝рзЗржЫрзЗред 
    ржпрзЗрж╣рзЗрждрзБ `CableSnapException` рж╣рж▓рзЛ `OpenDoorException`-ржПрж░ рж╕рж╛ржмржХрзНрж▓рж╛рж╕, рждрж╛ржЗ рж╕рж╛ржмржХрзНрж▓рж╛рж╕рзЗрж░ `catch` ржмрзНрж▓ржХржЯрж┐ рж╕рзБржкрж╛рж░ржХрзНрж▓рж╛рж╕рзЗрж░ `catch` ржмрзНрж▓ржХрзЗрж░ ржЖржЧрзЗ ржерж╛ржХрждрзЗ рж╣ржмрзЗред 
    ржХржорзНржкрж╛ржЗрж▓рж╛рж░ ржПржЯрж┐ ржПржХржЯрж┐ ржЕржкрзНрж░рж╛ржкрзНржп (unreachable) ржХрзЛржб рж╣рж┐рж╕рзЗржмрзЗ ржжрзЗржЦржмрзЗ ржПржмржВ ржПрж░рж░ ржжрзЗржмрзЗред
2.  Duplicate local variable: `catch (CableSnapException ex)` ржмрзНрж▓ржХрзЗрж░ ржнрзЗрждрж░рзЗ ржПржХржЯрж┐ ржирзЗрж╕рзНржЯрзЗржб `catch` ржмрзНрж▓ржХ ржЖржЫрзЗ, ржпрж╛рж░ ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░ рж╣рж┐рж╕рзЗржмрзЗ `Exception ex` рж▓рзЗржЦрж╛ рж╣ржпрж╝рзЗржЫрзЗред 
    ржПржЦрж╛ржирзЗ `ex` ржирж╛ржорзЗрж░ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ржЯрж┐ ржмрж╛ржЗрж░рзЗрж░ `catch` ржмрзНрж▓ржХрзЗрж░ `ex` ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓рзЗрж░ рж╕рж╛ржерзЗ рж╕ржВржШрж░рзНрж╖ (clash) ржХрж░ржЫрзЗред
3.  Duplicate local variable: ржПржХржЗ ржХрж╛рж░ржгрзЗ, `try...catch...finally` ржмрзНрж▓ржХрзЗрж░ ржнрзЗрждрж░рзЗржУ `Exception ex` ржПрж░ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ ржирзЗржоржЯрж┐ ржкрзБржирж░рж╛ржпрж╝ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ, ржпрж╛ ржЕржирзБржорзЛржжрж┐ржд ржирзЯред
4.  `main` method declaration: `main` ржорзЗржержбржЯрж┐ `IllegalArgumentException` ржерзНрж░рзЛ ржХрж░ржЫрзЗ, ржХрж┐ржирзНрждрзБ `new Palace().openDrawbridge()` ржПрж░рж░ржЯрж┐ `RuntimeException` ржерзНрж░рзЛ ржХрж░рзЗ, 
    ржпрж╛ `IllegalArgumentException` ржПрж░ рж╕рзБржкрж╛рж░ржХрзНрж▓рж╛рж╕ред ржХржорзНржкрж╛ржЗрж▓рж╛рж░ ржПржЯрж┐ ржзрж░рждрзЗ ржкрж╛рж░ржмрзЗ ржирж╛ред
5.  Unreachable statement: `catch (OpenDoorException e)` ржмрзНрж▓ржХрзЗрж░ ржнрзЗрждрж░рзЗ `throw new OpenDoorException();` 
   ржПрж░ ржкрж░рзЗ ржХрзЛржирзЛ ржХрзЛржб рж▓рж┐ржЦрж▓рзЗ рждрж╛ ржЕржкрзНрж░рж╛ржкрзНржп рж╣ржмрзЗ, ржХрж╛рж░ржг `throw` рж╕рзНржЯрзЗржЯржорзЗржирзНржЯржЯрж┐ ржорзЗржержбрзЗрж░ рж╕рзНржмрж╛ржнрж╛ржмрж┐ржХ ржкрзНрж░ржмрж╛рж╣ ржмржирзНржз ржХрж░рзЗ ржжрзЗрзЯред 
   ржПржЗ рж▓рж╛ржЗржирзЗрж░ ржкрж░ `catch (CableSnapException ex)` ржмрзНрж▓ржХржЯрж┐ ржЕржкрзНрж░рж╛ржкрзНржп рж╣ржпрж╝рзЗ ржпрж╛рзЯ, ржХрж╛рж░ржг ржПржЯрж┐ ржПржХржЯрж┐ рж╕рж╛ржмржХрзНрж▓рж╛рж╕рзЗрж░ ржПржХрзНрж╕рж╕рзЗржкрж╢ржиржХрзЗ рж╣рзНржпрж╛ржирзНржбрзЗрж▓ ржХрж░рж╛рж░ ржХржерж╛, ржпрж╛ ржПрж░ рж╕рзБржкрж╛рж░ржХрзНрж▓рж╛рж╕ ржжрзНржмрж╛рж░рж╛ ржЗрждрж┐ржоржзрзНржпрзЗржЗ рж╣рзНржпрж╛ржирзНржбрзЗрж▓ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред
   ржПржЗ ржкрж╛ржБржЪржЯрж┐ ржХрж╛рж░ржгрзЗ ржХрзЛржбржЯрж┐ ржХржорзНржкрж╛ржЗрж▓ рж╣ржмрзЗ ржирж╛ред




2.What is the output of the following?
12: int result = 8;
13: loop: while (result > 7) {
14: result++;
15: do {
16: resultтАУ;
17: } while (result > 5);
18: break loop;
19: }
20: System.out.println(result);

 5
 7
 8
 The code does not compile.
 The code compiles but throws an exception at runtime.






Explanation:
loop ржПржХржЯрж┐ ржЬрж╛ржнрж╛ ржХрзАржУржпрж╝рж╛рж░рзНржб (keyword) ржиржпрж╝ред рждржмрзЗ, ржПржЯрж┐ ржПржХржЯрж┐ рж▓рзЗржмрзЗрж▓ (label) рж╣рж┐рж╕рзЗржмрзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ ржпрж╛рзЯ, ржпрж╛ ржЬрж╛ржнрж╛рждрзЗ ржПржХржЯрж┐ рж▓рзБржкржХрзЗ ржЪрж┐рж╣рзНржирж┐ржд ржХрж░рж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рж╣ржпрж╝ред


1.  рж▓рж╛ржЗржи 12: ржкрзНрж░ржержорзЗ `result` ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ржЯрж┐рж░ ржорж╛ржи `8` ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рж╛ рж╣ржпрж╝ред
2.  рж▓рж╛ржЗржи 13: `while` рж▓рзБржк рж╢рзБрж░рзБ рж╣ржпрж╝ред рж╢рж░рзНрждржЯрж┐ рж╣рж▓рзЛ `result > 7`, ржпрж╛ рж╕рждрзНржп (ржХрж╛рж░ржг `8` `7` ржПрж░ ржерзЗржХрзЗ ржмржбрж╝)ред ржкрзНрж░рзЛржЧрзНрж░рж╛ржо рж▓рзБржкрзЗрж░ ржнрзЗрждрж░рзЗ ржкрзНрж░ржмрзЗрж╢ ржХрж░рзЗред
3.  рж▓рж╛ржЗржи 14: `result` ржПрж░ ржорж╛ржи ржПржХ ржмрж╛ржбрж╝рж╛ржирзЛ рж╣ржпрж╝, ржлрж▓рзЗ ржирждрзБржи ржорж╛ржи рж╣ржпрж╝ `9`ред
4.  рж▓рж╛ржЗржи 15: ржПржХржЯрж┐ `do-while` рж▓рзБржк рж╢рзБрж░рзБ рж╣ржпрж╝ред ржПржЗ рж▓рзБржкрзЗрж░ ржмрзИрж╢рж┐рж╖рзНржЯрзНржп рж╣рж▓рзЛ, рж╢рж░рзНржд ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛рж░ ржЖржЧрзЗржЗ ржПрж░ ржнрзЗрждрж░рзЗрж░ ржХрзЛржб ржЕржирзНрждржд ржПржХржмрж╛рж░ ржПржХрзНрж╕рж┐ржХрж┐ржЙржЯ рж╣ржпрж╝ред
5.  рж▓рж╛ржЗржи 16: `do-while` рж▓рзБржкрзЗрж░ ржнрзЗрждрж░рзЗ `result` ржПрж░ ржорж╛ржи ржПржХ ржХржорж╛ржирзЛ рж╣ржпрж╝, ржлрж▓рзЗ ржорж╛ржи рж╣ржпрж╝ `8`ред
6.  рж▓рж╛ржЗржи 17: `do-while` рж▓рзБржкрзЗрж░ рж╢рж░рзНржд (`result > 5`) ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛ рж╣ржпрж╝ред рж╢рж░рзНрждржЯрж┐ рж╕рждрзНржп (`8 > 5`), рждрж╛ржЗ рж▓рзБржкржЯрж┐ ржЖржмрж╛рж░ ржЪрж▓рзЗред as ; (comma) end of while (result > 5);
7.  рж▓рж╛ржЗржи 16: `result` ржПрж░ ржорж╛ржи ржЖржмрж╛рж░ ржПржХ ржХржорж╛ржирзЛ рж╣ржпрж╝, ржлрж▓рзЗ ржорж╛ржи рж╣ржпрж╝ `7`ред
8.  рж▓рж╛ржЗржи 17: рж╢рж░рзНрждржЯрж┐ ржЖржмрж╛рж░ ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛ рж╣ржпрж╝, ржпрж╛ ржПржЦржирзЛ рж╕рждрзНржп (`7 > 5`), рждрж╛ржЗ рж▓рзБржкржЯрж┐ рждрзГрждрзАржпрж╝ржмрж╛рж░рзЗрж░ ржорждрзЛ ржЪрж▓рзЗред
9.  рж▓рж╛ржЗржи 16: `result` ржПрж░ ржорж╛ржи ржЖржмрж╛рж░ ржПржХ ржХржорж╛ржирзЛ рж╣ржпрж╝, ржлрж▓рзЗ ржорж╛ржи рж╣ржпрж╝ `6`ред
10. рж▓рж╛ржЗржи 17: рж╢рж░рзНрждржЯрж┐ ржЖржмрж╛рж░ ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛ рж╣ржпрж╝, ржпрж╛ ржПржЦржирзЛ рж╕рждрзНржп (`6 > 5`), рждрж╛ржЗ рж▓рзБржкржЯрж┐ ржЪрждрзБрж░рзНржержмрж╛рж░рзЗрж░ ржорждрзЛ ржЪрж▓рзЗред
11. рж▓рж╛ржЗржи 16: `result` ржПрж░ ржорж╛ржи рж╢рзЗрж╖ржмрж╛рж░рзЗрж░ ржорждрзЛ ржПржХ ржХржорж╛ржирзЛ рж╣ржпрж╝, ржлрж▓рзЗ ржорж╛ржи рж╣ржпрж╝ `5`ред
12. рж▓рж╛ржЗржи 17: рж╢рж░рзНрждржЯрж┐ ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛ рж╣ржпрж╝ред ржПржмрж╛рж░ ржПржЯрж┐ ржорж┐ржерзНржпрж╛ (ржХрж╛рж░ржг `5` `5` ржПрж░ ржерзЗржХрзЗ ржмржбрж╝ ржиржпрж╝)ред `do-while` рж▓рзБржк рж╢рзЗрж╖ рж╣ржпрж╝ред
13. рж▓рж╛ржЗржи 18: `break loop;` рж╕рзНржЯрзЗржЯржорзЗржирзНржЯржЯрж┐ ржПржХрзНрж╕рж┐ржХрж┐ржЙржЯ рж╣ржпрж╝ред ржПржЯрж┐ рж▓рзЗржмрзЗрж▓ржпрзБржХрзНржд (`loop`) ржмрж╛ржЗрж░рзЗрж░ `while` рж▓рзБржк ржерзЗржХрзЗ ржкрзНрж░рзЛржЧрзНрж░рж╛ржоржХрзЗ рж╕рж░рж╛рж╕рж░рж┐ ржмрзЗрж░ ржХрж░рзЗ ржирж┐ржпрж╝рзЗ ржЖрж╕рзЗред
14. рж▓рж╛ржЗржи 20: рж╕ржмрж╢рзЗрж╖рзЗ, `result` ржПрж░ ржЪрзВржбрж╝рж╛ржирзНржд ржорж╛ржи, ржпрж╛ `5`, рждрж╛ ржХржирж╕рзЛрж▓рзЗ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рж╛ рж╣ржпрж╝ред



3.What statements are true about compiling a Java class file? (Choose two.)

 If the file does not contain a package statement, then the compiler considers the class part of the java.lang package.
 The compiler assumes every class implicitly imports the java.lang.* package.
 The compiler assumes every class implicitly imports the java.util.* package.
 Java requires every file to declare a package statement.
 Java requires every file to declare at least one import statement.
 If the class declaration does not extend another class, then it implicitly extends the java.lang.Object class.










Explanation:
2. рж╕ржВржХрж▓ржХ (compiler) ржзрж░рзЗ ржирзЗржпрж╝ ржпрзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржХрзНрж▓рж╛рж╕ рж╕рзНржмржпрж╝ржВржХрзНрж░рж┐ржпрж╝ржнрж╛ржмрзЗ java.lang.* ржкрзНржпрж╛ржХрзЗржЬржЯрж┐ ржЖржоржжрж╛ржирж┐ (import) ржХрж░рзЗред
ржПрж░ ржЕрж░рзНрже рж╣рж▓рзЛ, ржЖржкржирж┐ java.lang ржкрзНржпрж╛ржХрзЗржЬрзЗрж░ ржХрзНрж▓рж╛рж╕ржЧрзБрж▓рзЛ, ржпрзЗржоржи String, System, ржмрж╛ Math, ржХрзЛржирзЛ import рж╕рзНржЯрзЗржЯржорзЗржирзНржЯ ржЫрж╛ржбрж╝рж╛ржЗ рж╕рж░рж╛рж╕рж░рж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░рзЗржиред
6.ржпржжрж┐ ржХрзНрж▓рж╛рж╕ ржбрж┐ржХрзНрж▓рзЗржпрж╝рж╛рж░рзЗрж╢ржирзЗ ржЕржирзНржп ржХрзЛржирзЛ ржХрзНрж▓рж╛рж╕ржХрзЗ ржПржХрзНрж╕ржЯрзЗржирзНржб (extend) ржирж╛ ржХрж░рж╛ рж╣ржпрж╝, рждржмрзЗ ржПржЯрж┐ рж╕рзНржмржпрж╝ржВржХрзНрж░рж┐ржпрж╝ржнрж╛ржмрзЗ java.lang.Object ржХрзНрж▓рж╛рж╕ржХрзЗ ржПржХрзНрж╕ржЯрзЗржирзНржб ржХрж░рзЗред
ржЬрж╛ржнрж╛рждрзЗ, ржкрзНрж░рждрж┐ржЯрж┐ ржХрзНрж▓рж╛рж╕ Object ржХрзНрж▓рж╛рж╕рзЗрж░ ржПржХржЯрж┐ ржЙржкрж╢рзНрж░рзЗржгрзА (subclass)ред ржПржЯрж┐ рж╕ржорж╕рзНржд ржХрзНрж▓рж╛рж╕рзЗрж░ ржЬржирзНржп ржорзМрж▓рж┐ржХ ржХрж╛рж░рзНржпржХрж╛рж░рж┐рждрж╛ ржкрзНрж░ржжрж╛ржи ржХрж░рзЗ, ржпрзЗржоржи equals() ржПржмржВ toString() ржорзЗржержбред




4. What is the output of the following application?
package woods;
interface Plant {
default String grow() { return тАЬGrow!тАЭ; }
}
interface Living {
public default String grow() { return тАЬGrowing!тАЭ; }
}
public class Tree implements Plant, Living { // m1
public String grow(int height) { return тАЬSuper Growing!тАЭ; }
public static void main(String[] leaves) {
Plant p = new Tree(); // m2
System.out.print(((Living)p).grow()); // m3
}
}

 Grow!
 Growing!
 Super Growing!
 It does not compile because of line m1.
 It does not compile because of line m2.
 It does not compile because of line m3.






Explanation:
ржХрзЛржбржЯрж┐ ржХржорзНржкрж╛ржЗрж▓ рж╣ржмрзЗ ржирж╛ ржПржмржВ ржПрж░ ржкрзНрж░ржзрж╛ржи ржХрж╛рж░ржг рж╣рж▓рзЛ рж▓рж╛ржЗржи m1-ржПрж░ Tree ржХрзНрж▓рж╛рж╕ ржбрж┐ржХрзНрж▓рзЗрзЯрж╛рж░рзЗрж╢ржиред
ржпржЦржи ржПржХржЯрж┐ ржХрзНрж▓рж╛рж╕ ржжрзБржЯрж┐ ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ (Plant ржПржмржВ Living) ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯ ржХрж░рзЗ, ржПржмржВ ржЙржнржпрж╝ ржЗржирзНржЯрж╛рж░ржлрзЗрж╕рзЗ ржПржХржЗ рж╕рж┐ржЧржирзЗржЪрж╛рж░ (signature) рж╕рж╣ ржПржХржЯрж┐ ржбрж┐ржлрж▓рзНржЯ ржорзЗржержб ржерж╛ржХрзЗ, 
рждржЦржи рж╕рзЗржЗ ржХрзНрж▓рж╛рж╕ржХрзЗ ржЕржмрж╢рзНржпржЗ рж╕рзЗржЗ ржорзЗржержбржЯрж┐ржХрзЗ ржУржнрж╛рж░рж░рж╛ржЗржб (override) ржХрж░рждрзЗ рж╣ржмрзЗ ржпрж╛рждрзЗ ржжрзНржмржирзНржжрзНржм (conflict) ржПржбрж╝рж╛ржирзЛ ржпрж╛ржпрж╝ред

Tree ржХрзНрж▓рж╛рж╕ржЯрж┐ 
-ржЙржнржпрж╝ ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯ ржХрж░рж▓рзЗржУ, ржПржЯрж┐ grow() ржорзЗржержбрзЗрж░ ржЬржирзНржп ржирж┐ржЬрж╕рзНржм ржХрзЛржирзЛ ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯрзЗрж╢ржи ржжрзЗржпрж╝ржирж┐ред
-public String grow(int height) ржорзЗржержбржЯрж┐ ржПржХржЯрж┐ ржУржнрж╛рж░рж▓рзЛржб (overload), ржУржнрж╛рж░рж░рж╛ржЗржб (override) ржиржпрж╝, ржХрж╛рж░ржг ржПрж░ рж╕рж┐ржЧржирзЗржЪрж╛рж░ ржнрж┐ржирзНржи (ржПржЯрж┐ ржПржХржЯрж┐ int ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░ ржЧрзНрж░рж╣ржг ржХрж░рзЗ)ред


5.Which statements best describe the result of this code? (Choose two.)
package nyc;
public class TouristBus {
public static void main(StringтАж args) {
String[] nycTourLoops = new String[] { тАЬDowntownтАЭ, тАЬUptownтАЭ, тАЬBrooklynтАЭ };
String[] times = new String[] { тАЬDayтАЭ, тАЬNightтАЭ };
for (int i = 0, j = 0; i < nycTourLoops.length; i++, j++) 
System.out.println(nycTourLoops[i] + " " + times[j]); } }

 The println causes one line of output.
 The println causes two lines of output.
 The println causes three lines of output.
 The code terminates successfully.
 The code throws an exception at runtime.






Explanation:
 ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг: рж▓рзБржкрзЗрж░ рж╢рж░рзНрждржЯрж┐ nycTourLoops ржЕрзНржпрж╛рж░рзЗрж░ ржжрзИрж░рзНржШрзНржпрзЗрж░ ржЙржкрж░ ржирж┐рж░рзНржнрж░ ржХрж░рзЗ, ржХрж┐ржирзНрждрзБ ржнрж┐рждрж░рзЗ times ржЕрзНржпрж╛рж░рзЗржЯрж┐ j index ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗред ржпрзЗрж╣рзЗрждрзБ times ржЕрзНржпрж╛рж░рзЗрж░ ржжрзИрж░рзНржШрзНржп nycTourLoops ржЕрзНржпрж╛рж░рзЗрж░ ржЪрзЗржпрж╝рзЗ ржХржо, 
 рждрж╛ржЗ рж▓рзБржкрзЗрж░ рждрзГрждрзАржпрж╝ ржкрзБржирж░рж╛ржмрзГрждрзНрждрж┐рждрзЗ j ржПрж░ ржорж╛ржи 2 рж╣рж▓рзЗ times[j] ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржХрж░рж╛рж░ рж╕ржоржпрж╝ ржПржХржЯрж┐ ArrayIndexOutOfBoundsException рж╣ржпрж╝ред рждрж╛ржЗ, ржХрзЛржбржЯрж┐ рж╕ржлрж▓ржнрж╛ржмрзЗ рж╢рзЗрж╖ рж╣ржпрж╝ ржирж╛, ржмрж░ржВ ржПржХржЯрж┐ ржмрзНржпрждрж┐ржХрзНрж░ржо (exception) рждрзИрж░рж┐ ржХрж░рзЗред

ржЕрждржПржм, рж╕ржарж┐ржХ ржмрж┐ржмрзГрждрж┐ ржжрзБржЯрж┐ рж╣рж▓рзЛ:
The println causes two lines of output. (println ржжрзБржЯрж┐ рж▓рж╛ржЗржирзЗ ржЖржЙржЯржкрзБржЯ рждрзИрж░рж┐ ржХрж░рзЗред)
The code throws an exception at runtime. (ржХрзЛржбржЯрж┐ рж░рж╛ржиржЯрж╛ржЗржорзЗ ржПржХржЯрж┐ ржмрзНржпрждрж┐ржХрзНрж░ржо рждрзИрж░рж┐ ржХрж░рзЗред)


6.What is the result of the following?
package calendar;
public class Seasons {
public static void seasons(StringтАж names) {
int l = names[1].length(); // s1
System.out.println(names[l]); // s2
}
public static void main(String[] args) {
seasons(тАЬSummerтАЭ, тАЬFallтАЭ, тАЬWinterтАЭ, тАЬSpringтАЭ);
}
}






Explanation:
ржХрзЛржбржЯрж┐ ржХржорзНржкрж╛ржЗрж▓ рж╣рзЯред рж▓рж╛ржЗржи s1 ржХрж┐ржЫрзБржЯрж╛ ржЯрзНрж░рж┐ржХрж┐ ржХрж╛рж░ржг ржЕрзНржпрж╛рж░рзЗрж░ ржЬржирзНржп length ржмрзНржпржмрж╣рзГржд рж╣рзЯ ржПржмржВ рж╕рзНржЯрзНрж░рж┐ржВрзЯрзЗрж░ ржЬржирзНржп length() ржмрзНржпржмрж╣рзГржд рж╣рзЯред рж▓рж╛ржЗржи s1-ржП Fall-ржПрж░ ржжрзИрж░рзНржШрзНржп ржПржХржЯрж┐ ржнрзЗрж░рж┐рзЯрзЗржмрж▓рзЗ рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рж╛ рж╣рзЯ, ржпрж╛ 4ред
 рж▓рж╛ржЗржи s2-ржП ArrayIndexOutOfBoundsException ржерзНрж░рзЛ ржХрж░рж╛ рж╣рзЯ ржХрж╛рж░ржг 4 рж╣рж▓ ржПржХржЯрж┐ ржЪрж╛рж░ржЯрж┐ ржПрж▓рж┐ржорзЗржирзНржЯ ржмрж┐рж╢рж┐рж╖рзНржЯ ржЕрзНржпрж╛рж░рзЗрж░ ржЬржирзНржп ржЕржмрзИржз ржЗржиржбрзЗржХрзНрж╕ред 
 ржоржирзЗ рж░рж╛ржЦржмрзЗржи, ржЗржиржбрзЗржХрзНрж╕ ржЧржгржирж╛ рж╢рзВржирзНржп ржерзЗржХрзЗ рж╢рзБрж░рзБ рж╣рзЯред рждрж╛ржЗ, ржлрж▓рж╛ржлрж▓: рж░рж╛ржиржЯрж╛ржЗржорзЗ ArrayIndexOutOfBoundsExceptionред



7.How many lines of the following application contain compilation errors?
1: package percussion;
2:
3: interface MakesNoise {}

4: abstract class Instrument implements MakesNoise {
5: public Instrument(int beats) {}
6: public void play() {}
7: }

8: public class Drum extends Instrument {
9: public void play(int count) {}
10: public void concert() {
11: super.play(5);
12: }
13: public static void main(String[] beats) {
14: MakesNoise mn = new Drum();
15: mn.concert();
16: }
17: }

 None. The code compiles and runs without issue.
 One
 Two
 Three
 Four






Explanation:
* рж▓рж╛ржЗржи рзл: `Instrument` ржХрзНрж▓рж╛рж╕рзЗрж░ ржХрзЛржирзЛ ржбрж┐ржлрж▓рзНржЯ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ ржирзЗржЗред рждрж╛ржЗ, `Drum` ржХрзНрж▓рж╛рж╕ржХрзЗ рждрж╛рж░ ржирж┐ржЬрзЗрж░ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ ржерзЗржХрзЗ `super(int)` ржХрж▓ ржХрж░рждрзЗ рж╣ржмрзЗ, ржпрж╛ ржПржЦрж╛ржирзЗ ржЕржирзБржкрж╕рзНржерж┐рждред
* рж▓рж╛ржЗржи рззрзз: `Instrument` ржХрзНрж▓рж╛рж╕рзЗрж░ `play()` ржорзЗржержбржЯрж┐ ржХрзЛржирзЛ ржЖрж░рзНржЧрзБржорзЗржирзНржЯ ржЧрзНрж░рж╣ржг ржХрж░рзЗ ржирж╛, ржХрж┐ржирзНрждрзБ ржПржЦрж╛ржирзЗ `super.play(5)` ржХрж▓ ржХрж░рзЗ ржПржХржЯрж┐ ржЗржирзНржЯрж┐ржЬрж╛рж░ ржЖрж░рзНржЧрзБржорзЗржирзНржЯ ржкрж╛ржарж╛ржирзЛ рж╣ржЪрзНржЫрзЗред
* рж▓рж╛ржЗржи рззрзл: `mn` ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ржЯрж┐ `MakesNoise` ржЯрж╛ржЗржкрзЗрж░, ржпрзЗржЯрж┐рждрзЗ `concert()` ржирж╛ржорзЗ ржХрзЛржирзЛ ржорзЗржержб ржирзЗржЗред рждрж╛ржЗ, ржХржорзНржкрж╛ржЗрж▓рж╛рж░ ржПржЗ ржХрж▓ржЯрж┐ ржЦрзБржБржЬрзЗ ржкрж╛ржмрзЗ ржирж╛ред


8.What is the output of the following when run as java EchoFirst seed flower plant?
package unix;
import java.util.*;
public class EchoFirst {
public static void main(String[] args) {
Arrays.sort(args);
int result = Arrays.binarySearch(args, args[0]);
System.out.println(result);
}
}

 0
 1
 2
 The code does not compile.
 The code compiles but throws an exception at runtime.
 The output is not guaranteed.






Explanation:
1.  ржкрзНрж░ржержорзЗ, `Arrays.sort(args)` ржХржорж╛ржирзНржбрзЗрж░ ржХрж╛рж░ржгрзЗ `args` ржЕрзНржпрж╛рж░рзЗржЯрж┐ ржЕрзНржпрж╛рж▓ржлрж╛ржмрзЗржЯрж┐ржХрзНржпрж╛рж▓рж┐ рж╕рж╛ржЬрж╛ржирзЛ рж╣ржпрж╝, ржпрж╛ ржжрж╛ржБрзЬрж╛рзЯ `["flower", "plant", "seed"]`ред
2.  ржПрж░ржкрж░, `args[0]` ржПрж░ ржорж╛ржи рж╣ржпрж╝ `"flower"`ред
3.  `Arrays.binarySearch(args, args[0])` ржХржорж╛ржирзНржбржЯрж┐ рж╕рж╛ржЬрж╛ржирзЛ ржЕрзНржпрж╛рж░рзЗрждрзЗ `"flower"` ржПрж░ ржЕржмрж╕рзНржерж╛ржи ржЦрзЛржБржЬрзЗред
4.  ржпрзЗрж╣рзЗрждрзБ `"flower"` ржЕрзНржпрж╛рж░рзЗрж░ ржкрзНрж░ржержо ржЙржкрж╛ржжрж╛ржи, рждрж╛ржЗ ржПрж░ ржЗржиржбрзЗржХрзНрж╕ `0` рж╣ржпрж╝ред

ржПржЬржирзНржп, ржЖржЙржЯржкрзБржЯ `0` ржкрзНрж░рж┐ржирзНржЯ ржХрж░рж╛ рж╣рзЯред


9.What is the output of the following?
14: int count = 0;
15: LocalDate date = LocalDate.of(2017, Month.JANUARY, 1);
16: while (date.getMonth() != Month.APRIL)
17: date = date.minusMonths(1);
18: count++;
19: System.out.println(count);

 0
 1
 3
 9
 This is an infinite loop.
 The code does not compile.






Explanation:

1.  ржЕрзНржпрж╛рж░рзЗ рж╕рж╛ржЬрж╛ржирзЛ: `Arrays.sort(args)` ржХржорж╛ржирзНржбржЯрж┐ `args` ржЕрзНржпрж╛рж░рзЗржЯрж┐ржХрзЗ ржмрж░рзНржгрж╛ржирзБржХрзНрж░ржорж┐ржХржнрж╛ржмрзЗ рж╕рж╛ржЬрж╛рзЯред `["seed", "flower", "plant"]` рж╣рзЯрзЗ ржпрж╛рзЯ `["flower", "plant", "seed"]`ред
2.  ржорзВрж▓рзНржп ржирж┐рж░рзНржзрж╛рж░ржг: `args[0]` ржПржЦржи `"flower"`ред
3.  рж╕ржирзНржзрж╛ржи ржХрж░рж╛: `binarySearch` ржорзЗржержбржЯрж┐ рж╕рж╛ржЬрж╛ржирзЛ ржЕрзНржпрж╛рж░рзЗрждрзЗ `"flower"` ржЦрзЛржБржЬрзЗред
4.  ржлрж▓рж╛ржлрж▓: ржпрзЗрж╣рзЗрждрзБ `"flower"` ржЕрзНржпрж╛рж░рзЗрж░ ржкрзНрж░ржержо ржЙржкрж╛ржжрж╛ржи, рждрж╛ржЗ ржорзЗржержбржЯрж┐ ржПрж░ ржЗржиржбрзЗржХрзНрж╕ `0` рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗред




10.Which code will print the numbers up to 1000 (included) starting from user input, assume that user input is less than 1000? 

 int x = sc.nextInt(); do { System.out.println(x); x--; } while (x < 1000); System.out.println(x);
 int x = sc.nextInt(); do { System.out.println(x); x++; } while (x < 1000); System.out.println(x);
 int x = sc.nextInt(); do { System.out.println(x); x+=1; } while (x <= 1000); System.out.println(x);
 None of the above






Explanation:




11.There is an error in the following code. How to fix that error?
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int num = sc.nextInt();

if (num == 7) {
boolean seven = true;
} else {
boolean seven = false;
}
System.out.println(seven);
}

 "else" statement needs a boolean condition
 boolean variable "seven" has to be changed with another name
 boolean variable "seven" is a local variable. It needs to declared outside of if statement
 if statement conditions has to be like num.equals(7)






Explanation:
ржПржЦрж╛ржирзЗ ржкрзНрж░ржзрж╛ржи рждрзНрж░рзБржЯрж┐ржЯрж┐ рж╣рж▓рзЛ boolean variable "seven" is a local variable. It needs to declared outside of if statementред
ржмрзНржпрж╛ржЦрзНржпрж╛
seven ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ржЯрж┐ if ржПржмржВ else ржмрзНрж▓ржХрзЗрж░ ржоржзрзНржпрзЗ ржШрзЛрж╖ржгрж╛ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред рждрж╛ржЗ ржПрж░ рж╕рзНржХрзЛржк ржмрж╛ ржХрж╛рж░рзНржпржХрж╛рж░рж┐рждрж╛рж░ ржкрж░рж┐ржзрж┐ рж╢рзБржзрзБржорж╛рждрзНрж░ рж╕рзЗржЗ ржмрзНрж▓ржХржЧрзБрж▓рзЛрж░ ржоржзрзНржпрзЗ рж╕рзАржорж╛ржмржжрзНржзред 
System.out.println(seven) рж▓рж╛ржЗржиржЯрж┐ рж╕рзЗржЗ ржмрзНрж▓ржХржЧрзБрж▓рзЛрж░ ржмрж╛ржЗрж░рзЗ ржерж╛ржХрж╛рзЯ, ржХржорзНржкрж╛ржЗрж▓рж╛рж░ seven ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ржЯрж┐ржХрзЗ ржЦрзБржБржЬрзЗ ржкрж╛рзЯ ржирж╛, ржлрж▓рзЗ ржПржХржЯрж┐ ржХржорзНржкрж╛ржЗрж▓рзЗрж╢ржи рждрзНрж░рзБржЯрж┐ рж╣рзЯред
ржПржЗ рждрзНрж░рзБржЯрж┐ ржарж┐ржХ ржХрж░рж╛рж░ ржЬржирзНржп, seven ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ржЯрж┐ржХрзЗ if рж╕рзНржЯрзЗржЯржорзЗржирзНржЯрзЗрж░ ржЖржЧрзЗ ржШрзЛрж╖ржгрж╛ ржХрж░рждрзЗ рж╣ржмрзЗред



12.For the given Circle class, which of the following method defines area of the circle? 
public class Circle{
double radius = 10.0;
double x = 100.0;
double y = 100.0;

// area method goes here
}

 double getArea(int radius) {         return Math.PI * radius * radius;     }
 double getArea() { return PI * radius * radius; }
 double getArea() { return Math.PI * radius * radius; }
 None of the above



Explanation:
Are of circle = pi * radius*radius, pi=3.142. Pi is a built-in math function thatтАЩs part of the overall Math class?. So for getting pi value you have to use Math.PI.
 For getArea(int radius) would not work because local variable radius and instance variable radius has an conflict.











13.How many lines contain a compile error?
1: import java.time.*;
2: import java.time.format.*;
3:00
4: public class HowLong {
5: public void main(String h) {
6: LocalDate newYears = new LocalDate(2017, 1, 1);
7: Period period = Period.ofYears(1).ofDays(1);
8: DateTimeFormat format = DateTimeFormat.ofPattern(тАЬMM-dd-yyyyтАЭ);
9: System.out.print(format.format(newYears.minus(period)));
10: }
11: }

 None
 One
 Two
 Three
 Four
 Five




14.Which is the correct statement about static variable? 

 There may be any number of copies of static variable that can be shared among all the instances of the class
 There is always exactly one copy of a static variable is created and shared among all the instances of the class
 Static variables are primitive type 
 None of the above





Explanation:
A static variable is common to all the instances (or objects) of the class because it is a class level variable










15.What is printed by the following code snippet?
int fish = 1 + 2 * 5>=2 ? 4 : 2;
int mammals = 3 < 3 ? 1 : 5>=5 ? 9 : 7;
System.out.print(fish+mammals+тАЭтАЭ);

 49
 13
 18
 99
 It does not compile.






Explanation:
B.13


16.What is the output for this code line? 
System.out.println(30/2*5%4);  

 1
 15
 0
 3







Explanation:
ржЬрж╛ржнрж╛рждрзЗ, `*`, `/`, ржПржмржВ `%` ржЕржкрж╛рж░рзЗржЯрж░ржЧрзБрж▓рзЛрж░ ржЕржЧрзНрж░рж╛ржзрж┐ржХрж╛рж░ ржПржХржЗ, рждрж╛ржЗ ржмрж╛ржо ржжрж┐ржХ ржерзЗржХрзЗ ржбрж╛ржи ржжрж┐ржХрзЗ ржЧржгржирж╛ ржХрж░рж╛ рж╣рзЯред
1.  ржкрзНрж░ржержорзЗ, `30/2` ржЧржгржирж╛ ржХрж░рж╛ рж╣ржпрж╝, ржпрж╛рж░ ржлрж▓рж╛ржлрж▓ `15`ред
2.  ржПрж░ржкрж░, `15*5` ржЧржгржирж╛ ржХрж░рж╛ рж╣ржпрж╝, ржпрж╛рж░ ржлрж▓рж╛ржлрж▓ `75`ред
3.  рж╕ржмрж╢рзЗрж╖рзЗ, `75%4` ржЧржгржирж╛ ржХрж░рж╛ рж╣ржпрж╝, ржпрж╛рж░ ржлрж▓рж╛ржлрж▓ `3` (ржХрж╛рж░ржг 75 ржХрзЗ 4 ржжрж┐ржпрж╝рзЗ ржнрж╛ржЧ ржХрж░рж▓рзЗ ржнрж╛ржЧрж╢рзЗрж╖ 3 ржерж╛ржХрзЗ)ред




17.What is the output of the following code?
public static void main(String[] args) {
final String cell = тАЬaтАЭ;
String foo = new String(тАЬaтАЭ);
final String bell = new String(foo);
System.out.print((cell==bell)
+тАЭ тАЬ+cell.equals(bell));
}

 false true
 false false
 true true
 Code will not compile due to error






Explanation:




18.Given that SC is an scanner object. Which of the following code stores users value into an array? 
 int[] d = new int[10]; for (int i = 0; i < d.length; i++) { d[i].nextInt(); }
 int[] d = new Int[10]; for (int i = 0; i < d.length; i++) { d[i] = SC.nextInt(); }
 int[] d = new int[10]; d[i] = SC.nextInt();
 int[] d = new int[10]; for (int i = 0; i < d.length; i++) { d[i] = SC.nextInt(); }






Explanation:
* ржПржЗ ржХрзЛржбржЯрж┐ ржПржХржЯрж┐ `for` рж▓рзБржк ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗред
* рж▓рзБржкржЯрж┐ ржЕрзНржпрж╛рж░рзЗрж░ ржкрзНрж░рждрж┐ржЯрж┐ ржЗржиржбрзЗржХрзНрж╕ (`i=0` ржерзЗржХрзЗ `9` ржкрж░рзНржпржирзНржд) ржжрж┐рзЯрзЗ ржЪрж▓рзЗред
* `SC.nextInt()` ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржХрж╛ржЫ ржерзЗржХрзЗ ржПржХржЯрж┐ ржкрзВрж░рзНржгрж╕ржВржЦрзНржпрж╛ ржЗржиржкрзБржЯ ржирзЗрзЯред
* ржкрзНрж░рждрж┐ржЯрж┐ ржЗржиржкрзБржЯржХрзЗ `d[i]` ржПрж░ ржорж╛ржзрзНржпржорзЗ ржЕрзНржпрж╛рж░рзЗрж░ рж╕ржарж┐ржХ рж╕рзНржерж╛ржирзЗ рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рзЗред
`int[] d = new int[10]; for (int i = 0; i < d.length; i++) { d[i] = SC.nextInt(); }`





19.Suppose you have a variable named passengers which stores an array of objects of type Passenger. What is a single line of code that will print the output of the getName() method for the first Passenger object in the passengers array?

 System.out.println(passengers.getName()); 
 System.out.println(passengers[0].getName()); 
 System.out.println(passengers.getName([0])); 
 System.out.println(getName(0));



Explanation:
passengers[0] gives the first element of the given array.











20.What does this code output? 
public void foo(int[] x) {
x[0] = x[0] + 1;
}
int[] a = new int[10];
int[] b = a;
foo(a);
System.out.println(a[0]+тАЭ тАЬ+b[0]);

 0 0
 1 1
 1 0
 null null






Explanation:
2



21.Given the application below, which lines do not compile? (Choose three.)
package furryfriends;
interface Friend {
protected String getName(); // h1
}
class Cat implements Friend {
String getName() { // h2
return тАЬKittyтАЭ;
}
}
public class Dog implements Friend {
String getName() throws RuntimeException { // h3
return тАЬDoggyтАЭ;
}
public static void main(String[] adoption) {
Friend friend = new Dog(); // h4
System.out.print(((Cat)friend).getName()); // h5
System.out.print(((Dog)null).getName()); // h6
}
}

 Line h1
 Line h2
 Line h3
 Line h4
 Line h5
 Line h6






Explanation:
interface abstract method Can not be protected
so output: 1,2,3




22.What is the result of compiling and executing the following application?
package ranch;

public class Cowboy {
private int space = 5;
private double ship = space < 2 ? 1 : 10; // g1 

public void printMessage() { 
    if(ship>1) {
        System.out.println(тАЬGoodbyeтАЭ);
   } 

if(ship<10 && space>=2) System.out.println(тАЬHelloтАЭ); // g2
else System.out.println(тАЬSee you againтАЭ);
}

public static final void main(StringтАж stars) {
new Cowboy().printMessage();
}
}

 It only prints Hello.
 It only prints Goodbye.
 It only prints See you again.
 It does not compile because of line g1.
 It does not compile because of line g2.
 None of the above






Explanation:
Goodbye
See you again
Ans is :None of the above



23.Why do we use the super keyword in the case of inheritance?
 To force a call to a method from a subclass
 To force a call to a method from a superclass
 To force a call to a local variable outside of the method
 None of the above






Explanation:
B



24.What is true about constructor inheritance? (Select two)

 Constructors are not inherited
 Constructors are inherited
 Java calls the constructor you asked for, and then the no-argument constructor for every superclass
 You may call constructor again and again






Explanation:
ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ржЧрзБрж▓рзЛ ржЗржирж╣рзЗрж░рж┐ржЯ рж╣рзЯ ржирж╛ |
ржЬрж╛ржнрж╛ ржЖржкржирж┐ ржпрзЗ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░рзЗрж░ ржЬржирзНржп ржЕржирзБрж░рзЛржз ржХрж░рзЗржЫрзЗржи, ржПржмржВ рждрж╛рж░ржкрж░рзЗ ржкрзНрж░рждрж┐ржЯрж┐ рж╕рзБржкрж╛рж░ржХрзНрж▓рж╛рж╕рзЗрж░ ржЬржирзНржп ржирзЛ-ржЖрж░рзНржЧрзБржорзЗржирзНржЯ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ржХрзЗ ржХрж▓ ржХрж░рзЗред
a,c




25.Which code validate the user input between 1 and 10?
 int number = sc.nextInt(); while (number < 1 OR number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }
 int number = sc.nextInt(); while (number > 1 || number < 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }
 int number = sc.nextInt(); while (number < 1 && number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }
 int number = sc.nextInt(); while (number < 1 || number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }






Explanation:
* ржПржЗ ржХрзЛржбржЯрж┐ `||` (OR) ржЕржкрж╛рж░рзЗржЯрж░ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзЗ ржпрзЗ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржЗржиржкрзБржЯ 1 ржПрж░ ржЪрзЗржпрж╝рзЗ ржХржо ржЕржержмрж╛ 10 ржПрж░ ржЪрзЗржпрж╝рзЗ ржмрзЗрж╢рж┐ рж╣рж▓рзЗ рж▓рзБржкржЯрж┐ ржЪрж▓ржмрзЗред
* ржпржжрж┐ ржЗржиржкрзБржЯржЯрж┐ 1 ржерзЗржХрзЗ 10 ржПрж░ ржоржзрзНржпрзЗ ржирж╛ рж╣ржпрж╝, рждржмрзЗ ржПржЯрж┐ рж▓рзБржкрзЗрж░ рж╢рж░рзНрждржХрзЗ рж╕рждрзНржп ржХрж░рзЗ ржПржмржВ ржПржХржЯрж┐ ржирждрзБржи ржЗржиржкрзБржЯ ржЧрзНрж░рж╣ржгрзЗрж░ ржЬржирзНржп ржЕржирзБрж░рзЛржз ржХрж░рзЗред
* ржЕржирзНржпрж╛ржирзНржп ржмрж┐ржХрж▓рзНржкржЧрзБрж▓рзЛрждрзЗ ржнрзБрж▓ рж▓ржЬрж┐ржХрзНржпрж╛рж▓ ржЕржкрж╛рж░рзЗржЯрж░ (`OR`, `&&`) ржмрж╛ ржнрзБрж▓ рж╢рж░рзНржд ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред
`int number = sc.nextInt(); while (number < 1 || number > 10) { System.err.println("Invalid range, Enter a number from 1 to 10"); number = sc.nextInt(); }`


26.he following method compiles and executes but does not work as you
might hope. What is wrong with it?
public static int[] copyArray(int[] anArray){
int[] temp = new int[anArray.length];
temp = anArray;
return temp;
}

 The method does not return an array distinct from the given argument array. 
 The temp array declaration is not valid
 The method cannot have a return type
 Nothing is wrong with the code






Explanation:
a



27.What is a line of Java code to sort only the portion of the array named anArray beginning with the index 5 and ending with the index 10?

 Arrays.sort(anArray[5:10]); 
 Arrays.sort(anArray[5], anArray[10]); 
 Arrays.sort(anArray, 5, 10); 
 Arrays.sort(anArray([5] : [10])); 






Explanation:
c



