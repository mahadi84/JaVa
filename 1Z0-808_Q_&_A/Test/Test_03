

1. What will be the result of compiling and executing Test class?
   public class Test {
   public static void main(String[] args) {
   int [] arr = {3, 2, 1};
   for(int i : arr) {
   System.out.println(arr[i]);
   }}}


1. Answer: 
   `int[] arr = {3, 2, 1};` উপাদানগুলি হলো 3, 2, 1। 
    ** `arr[0]` হলো 3   * `arr[1]` হলো 2   * `arr[2]` হলো 1            
    ** প্রথম পুনরাবৃত্তিতে, `i` এর মান হবে অ্যারের প্রথম উপাদান, যা 3। এরপর `System.out.println(arr[i]);` অর্থাৎ `System.out.println(arr[3]);` কার্যকর করার চেষ্টা করা হবে।
    যেহেতু অ্যারের বৈধ ইনডেক্সগুলি 0, 1, 2 পর্যন্ত, এবং 3 একটি অবৈধ ইনডেক্স, 
    তাই জাভা ভার্চুয়াল মেশিন (`JVM`) একটি `ArrayIndexOutOfBoundsException` নিক্ষেপ করবে এবং প্রোগ্রামটি বন্ধ হয়ে যাবে।

----------

2. Consider below code of Test.java file:
   public class Test {
   public static void main(String[] args) {
   int elements = 0;
   Object [] arr = {“A”, “E”, “I”, new Object(), “O”, “U”}; //Line n1
   for(Object obj : arr) { //Line n2
      if(obj instanceof String) {
      continue;
      } else {
      break;
      }
   elements++; //Line n3
   }
   System.out.println(elements); //Line n4
   }}
   What will be the result of compiling and executing Test class?
    Compilation error at Line n1
    Compilation error at Line n2
    Compilation error at Line n3
    Compilation error at Line n4



2.Answer: 
   যেহেতু elements++ লাইনটি কোনো অবস্থাতেই কার্যকর করা সম্ভব নয় (কারণ এর ঠিক উপরে continue অথবা break সর্বদা কার্যকর হবে), তাই জাভা কম্পাইলার এটিকে একটি "unreachable statement" ত্রুটি হিসেবে ধরবে।
   অতএব, সঠিক উত্তরটি হলো: Line n3 তে একটি কম্পাইলেশন ত্রুটি হবে, কারণ elements++; লাইনটি Unreachable statement।
   **চতুর্থ পুনরাবৃত্তি: obj এর মান new Object()।
   new Object() একটি String নয়।
   if(obj instanceof String) শর্তটি মিথ্যা হয়।
   else ব্লক কার্যকর হয় এবং break স্টেটমেন্টটি লুপটিকে সম্পূর্ণরূপে বন্ধ করে দেয়।

----------

3. Consider below code of Test.java file:
  public class Test {
   public static void main(String[] args) {
   String [][] arr = { {“%”, “$$”}, {“***”, “@@@@”, “#####”}};
   for(String [] str : arr) {
         for(String s : str) {
         System.out.println(s);
         if(s.length() == 4) //Line n1
         break; //Line n2
         }
   break; //Line n3
  }}}
   What will be the result of compiling and executing Test class?
    %
    % $$
    % $$ ***
    % $$ *** @@@@
    % $$ *** @@@@ #####


3. Answer: 
      Setp_1.অ্যারের ইনিশিয়ালাইজেশন (Array Initialization): `String [][] arr = { {"%", "$$"}, {"", "@@@@", "#####"}};`  এটি একটি দ্বি-মাত্রিক (two-dimensional) অ্যারে।
              arr[0] হলো {"%", "$$"};  
              arr[1] হলো {"", "@@@@", "#####"}

      Setp_2.আউটার লুপ (Outer Loop): `for(String [] str : arr)`: এই লুপটি `arr` অ্যারের প্রতিটি ভেতরের অ্যারের উপর পুনরাবৃত্তি (iterate) করে।
             প্রথম পুনরাবৃত্তি: `str` এর মান হবে `{"%", "$$"}`।  

      Setp_3.ইনার লুপ (Inner Loop): `for(String s : str)`:  এই লুপটি `str` (বর্তমানে `{"%", "$$"}`) অ্যারের প্রতিটি স্ট্রিং উপাদানের উপর পুনরাবৃত্তি করে।
             প্রথম পুনরাবৃত্তি (ইনার লুপ): `s` এর মান হবে `"%"`।
                 `System.out.println(s);` আউটপুট করবে: `%`
                 `if(s.length() == 4)`: `"%"` এর দৈর্ঘ্য 1, যা 4 এর সমান নয়। তাই `if` শর্তটি মিথ্যা হয়।         
             দ্বিতীয় পুনরাবৃত্তি (ইনার লুপ): `s` এর মান হবে `"$$"`।
                 `System.out.println(s);` আউটপুট করবে: `$$`
                 `if(s.length() == 4)`: `"$$"` এর দৈর্ঘ্য $, যা 4 এর সমান নয়। তাই `if` শর্তটি মিথ্যা হয়।
                 ইনার লুপের এই `str` অ্যারের আর কোনো উপাদান নেই, তাই ইনার লুপটি শেষ হয়।         
      Setp_4.আউটার লুপের `break` (Line n3): ইনার লুপ শেষ হওয়ার পর, কন্ট্রোল `break;` (Line n3) স্টেটমেন্টে আসে। এই `break` স্টেটমেন্টটি আউটার লুপকে সম্পূর্ণরূপে বন্ধ করে দেয়।         
      
      ### ফলাফল (Result)
      যেহেতু আউটার লুপটি প্রথম পুনরাবৃত্তির পরেই `break` হয়ে যাচ্ছে, দ্বিতীয় ভেতরের অ্যারে (`{"", "@@@@", "#####"}`) কখনোই প্রসেস হবে না।
      অতএব, কোডটি কম্পাইল ও এক্সিকিউট করলে যে আউটপুট দেবে তা হলো:
      %
      $$

----------

4. public class Test {
   public static void main(String[] args) {
   int i = 1;
   int j = 5;
   int k = 0;
   A: while(true) { i++;
   B: while(true) { j--;
   C: while(true) {
       k += i + j;
       if(i == j) break A;
       else if (i > j) continue A;
       else continue B;
      }}}
       System.out.println(k);
      }}   
   What will be the result of compiling and executing Test class?   
    Compilation error
    Program never terminates as above code causes infinite loop
    6
    11
    15



4. Answer: 
 আমরা `i`, `j`, এবং `k` এর মানগুলো ট্র্যাক করব, এবং দেখব প্রোগ্রাম ফ্লো কিভাবে পরিবর্তিত হয়।
      প্রাথমিক মান:  * `i = 1`  * `j = 5`  * `k = 0`
      ১ম পুনরাবৃত্তি (আউটার লুপ A):
      1.  `i++` হয়, তাই `i` এর মান হয় 2।
      2.  ১ম পুনরাবৃত্তি (মাঝের লুপ B):
            * `j--` হয়, তাই `j` এর মান হয় 4।
            * ১ম পুনরাবৃত্তি (ইনার লুপ C):
                * `k += i + j` মানে `k = k + (2 + 4) = 0 + 6 = 6`। এখন `k` এর মান 6।
                * `if(i == j)` (2 == 4)? `false`।
                * `else if (i > j)` (2 \> 4)? `false`।
                * `else` ব্লকে প্রবেশ করে (`i < j` সত্য)। `continue B;` কার্যকর হয়।
                * এটি প্রোগ্রামকে সরাসরি মাঝের লুপ (B) এর পরবর্তী পুনরাবৃত্তিতে নিয়ে যায়।
      -----      
      ২য় পুনরাবৃত্তি (মাঝের লুপ B):
      1.  `j--` হয়, তাই `j` এর মান হয় 3। (`i` এর মান 2 ই থাকে)
      2.  ১ম পুনরাবৃত্তি (ইনার লুপ C):
            * `k += i + j` মানে `k = k + (2 + 3) = 6 + 5 = 11`। এখন `k` এর মান 11।
            * `if(i == j)` (2 == 3)? `false`।
            * `else if (i > j)` (2 \> 3)? `false`।
            * `else` ব্লকে প্রবেশ করে (`i < j` সত্য)। `continue B;` কার্যকর হয়।
            * এটি প্রোগ্রামকে সরাসরি মাঝের লুপ (B) এর পরবর্তী পুনরাবৃত্তিতে নিয়ে যায়।
      -----
      ৩য় পুনরাবৃত্তি (মাঝের লুপ B):
      1.  `j--` হয়, তাই `j` এর মান হয় 2। (`i` এর মান 2 ই থাকে)
      2.  ১ম পুনরাবৃত্তি (ইনার লুপ C):
            * `k += i + j` মানে `k = k + (2 + 2) = 11 + 4 = 15`। এখন `k` এর মান 15।
            * `if(i == j)` (2 == 2)? হ্যাঁ, সত্য\!
            * `break A;` কার্যকর হয়।
            * এই `break` স্টেটমেন্টটি লেবেল `A` দ্বারা চিহ্নিত আউটার `while(true)` লুপ থেকে সম্পূর্ণভাবে প্রোগ্রামকে বের করে দেয়।      
      -----      
      ### ফলাফল:  লুপ থেকে বেরিয়ে আসার পর, `System.out.println(k);` কার্যকর হয়। `k` এর চূড়ান্ত মান হলো 15।


----------

5. public class Test {
       public static void main(String[] args) {
           String [][] arr = { {"%", ""}, {"", "@@@@", "#####"}};
           for(String [] str : arr) { // Outer loop
               for(String s : str) { // Inner loop
                   System.out.println(s);
                   if(s.length() == 4) { // Line n1
                       break; // Line n2: Breaks out of the INNER loop
                   }
               }
               break; // Line n3: Breaks out of the OUTER loop
           }
       }
   }


5. Answer: 
    1.  অ্যারে ইনিশিয়ালাইজেশন:
    `String [][] arr = { {"%", ""}, {"", "@@@@", "#####"}};`
    এখানে একটি দ্বি-মাত্রিক অ্যারে (`2D array`) তৈরি করা হয়েছে:
      * `arr[0]` হল `{"%", ""}`
      * `arr[1]` হল `{"", "@@@@", "#####"}`
   2. আউটার লুপ (`for(String [] str : arr)`): এই লুপটি `arr` অ্যারের প্রতিটি ভেতরের অ্যারের উপর পুনরাবৃত্তি করে।
      * প্রথম পুনরাবৃত্তি: `str` এর মান হয় `{"%", ""}`।
   3. ইনার লুপ (`for(String s : str)`): এই লুপটি বর্তমান `str` অ্যারের স্ট্রিং উপাদানগুলির উপর পুনরাবৃত্তি করে।
      * ইনার লুপের প্রথম পুনরাবৃত্তি: `s` এর মান হয় ` "%"  `।
          * `System.out.println(s);` আউটপুট করবে: `%`
          * `if(s.length() == 4)`: `"%"` এর দৈর্ঘ্য 1। 1 == 4 মিথ্যা।
      * ইনার লুপের দ্বিতীয় পুনরাবৃত্তি: `s` এর মান হয় `""` (একটি খালি স্ট্রিং)।
          * `System.out.println(s);` আউটপুট করবে: (একটি খালি লাইন)
          * `if(s.length() == 4)`: `""` এর দৈর্ঘ্য 0। 0 == 4 মিথ্যা।
          * `{"%", ""}` অ্যারেতে আর কোনো উপাদান না থাকায়, এই ইনার লুপটি শেষ হয়।
   4. আউটার লুপের `break` (Line n3):
    ইনার লুপ শেষ হওয়ার পর, কন্ট্রোল `break;` (Line n3) স্টেটমেন্টে আসে। এই `break` স্টেটমেন্টটি আউটার লুপকে সম্পূর্ণরূপে বন্ধ করে দেয়।
   ### ফলাফল
   যেহেতু আউটার লুপটি শুধুমাত্র প্রথম ভেতরের অ্যারে (`{"%", ""}`) প্রসেস করার পরেই `break` হয়ে যাচ্ছে, তাই দ্বিতীয় ভেতরের অ্যারে (`{"", "@@@@", "#####"}`) কখনোই প্রসেস হবে না।
   কম্পাইল এবং এক্সিকিউট করার পর, আউটপুট হবে: %


-------------
6. public class Test {
   public static void main(String[] args) {
      int i = 0;
      for(System.out.print(i++); i < 2; System.out.print(i++)) {
      System.out.print(i);
   }}}
   What will be the result of compiling and executing the Test class?


6. Answer: 
কোডটি একটি `for` লুপের ভেতরের অংশগুলো কিভাবে কাজ করে, তা বোঝার জন্য খুব ভালো একটি উদাহরণ। একটি `for` লুপের তিনটি অংশ থাকে:
1.  Initialization (শুরু): `System.out.print(i++);` - লুপ শুরু হওয়ার আগে একবারই কার্যকর হয়।
2.  Condition (শর্ত): `i < 2;` - প্রতিটি পুনরাবৃত্তির (iteration) আগে এই শর্তটি পরীক্ষা করা হয়।
3.  Increment/Decrement (বৃদ্ধি/হ্রাস): `System.out.print(i++);` - প্রতিটি পুনরাবৃত্তি শেষ হওয়ার পর এই অংশটি কার্যকর হয়।

### এক্সিকিউশন ট্রেস
চলুন, `i` এর মান এবং আউটপুট ট্র্যাক করি:
1.  Initialization (শুরু):
      * `i` এর প্রাথমিক মান `0`।
      * `System.out.print(i++);` কার্যকর হয়।
          * প্রথমে `i` এর বর্তমান মান (`0`) প্রিন্ট হয়। আউটপুট: `0`
          * তারপর `i` এর মান 1 বৃদ্ধি পায়। এখন `i` এর মান `1`।

2.  প্রথম পুনরাবৃত্তি (Loop 1):
      * Condition (শর্ত): `i < 2` মানে `1 < 2`। এটি সত্য। তাই লুপের বডিতে প্রবেশ করে।
      * Loop Body: `System.out.print(i);` কার্যকর হয়।
          * `i` এর বর্তমান মান (`1`) প্রিন্ট হয়। আউটপুট: `01`
      * Increment/Decrement (বৃদ্ধি/হ্রাস): `System.out.print(i++);` কার্যকর হয়।
          * প্রথমে `i` এর বর্তমান মান (`1`) প্রিন্ট হয়। আউটপুট: `011`
          * তারপর `i` এর মান 1 বৃদ্ধি পায়। এখন `i` এর মান `2`।

3.  দ্বিতীয় পুনরাবৃত্তি (Loop 2):
      * Condition (শর্ত): `i < 2` মানে `2 < 2`। এটি মিথ্যা।
      * শর্ত মিথ্যা হওয়ায় লুপটি বন্ধ হয়ে যায়।

### চূড়ান্ত ফলাফল কম্পাইল এবং এক্সিকিউট করার পর, `Test` ক্লাসটির আউটপুট হবে: 011


-----------

7. public class Test {
   public static void main(String[] args) {
   boolean flag = false;
   do {
   if(flag = !flag) { //Line n1
   System.out.print(1); //Line n2
   continue; //Line n3
   }
   System.out.print(2); //Line n4
   } while(flag); //Line n5
   }}   
   What will be the result of compiling and executing Test class?   
    1
    2
    12
    21
    212
    121

8.public class Greetings {
   String msg = null;
   public Greetings() {
   this(“Good Morning!”);
   }
   public Greetings(String str) {
   msg = str;
   }
   
   public void display() {
     System.out.println(msg);
   }

   public static void main(String [] args) {
   Greetings g1 = new Greetings();
   Greetings g2 = new Greetings(“Good Evening!”);
   g1.display();
   g2.display();
   }}
   
    -null Good Evening!
    -Good Morning! Good Evening!
    -Good Morning! null
    -null null

9. class Message {
   String msg = “Happy New Year!”;
   public void print() {
   System.out.println(msg);
   }}
   
   public class Test {
   public static void change(Message m) {
   m.msg = “Happy Holidays!”;
   }
   
   public static void main(String[] args) {
   Message obj = new Message();
   obj.print();
   change(obj);
   obj.print();
   }}
   
    null Happy Holidays!
    Happy Holidays! Happy Holidays!
    null null
    Happy New Year! Happy Holidays!

10.class Message {
      String msg = “Happy New Year!”;   
      public void print() {
      System.out.println(msg);
   }   }
   
   public class Test {
      public static void change(Message m) {
      m = new Message();
      m.msg = “Happy Holidays!”;
   }
   
   public static void main(String[] args) {
      Message obj = new Message();
      obj.print();
      change(obj);
      obj.print();
   }}
   
    Happy New Year! Happy Holidays!
    Happy Holidays! Happy Holidays!
    Happy New Year! Happy New Year!
    null Happy New Year!

11.public class Test {
public static void print() {
System.out.println(“static method”);
}

public static void main(String[] args) {
Test obj = null;
obj.print();
}
}

12.public class Wall {
public static void main(String args[]) {
double area = 5.7;
String color;
if (area < 7) color = "green"; System.out.println(color); } }

 green
 NullPointerException
 Compilation error

13.public class Test {
public static void main(String[] args) {
double price = 90000;
String model;
if(price > 100000) {
model = “Tesla Model X”;
} else if(price <= 100000) { model = "Tesla Model S"; } System.out.println(model); } }

 Tesla Model X
 Tesla Model S
 Compilation Error

14.Following statement in a Java program compiles successfully:
student.report(course); 
What can you say for sure?

 student is the reference variable name
 student is the class name
 report is the method name
 course must be of String type

15.public class Test {
private static void m(int x) {
System.out.println(“int version”);
}

private static void m(char x) {
System.out.println(“char version”);
}

public static void main(String [] args) {
int i = ‘5’;
m(i);
m(‘5’);
}
}

 int version int version
 char version char version
 int version char version
 char version int version
 Compilation error

16.public class Test {
public static void main(String [] args) {
int [] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
System.out.println(process(arr, 3, 8)); //Line 5
}

/*INSERT*/
}
Line 5 causes compilation error as process method is not found. 
Which of the following method definitions, if used to replace /*INSERT*/, will resolve the compilation error?
Select ALL that apply.

 private static int[] process(int [] arr, int start, int end) { return null; }
 private static String process(int [] arr, int start, int end) { return null; }
 private static int process(int [] arr, int start, int end) { return null; }
 private static String[] process(int [] arr, int start, int end) { return null; }

17.class Point {
static int x;
int y, z;

public String toString() {
return “Point(” + x + “, ” + y + “, ” + z + “)”;
}
}

public class Test {
public static void main(String[] args) {
Point p1 = new Point();
p1.x = 17;
p1.y = 35;
p1.z = -1;

Point p2 = new Point();
p2.x = 19;
p2.y = 40;
p2.z = 0;

System.out.println(p1); //Line n1
System.out.println(p2); //Line n2
}
}

 Point(17, 35, -1) Point(19, 40, 0)
 Point(19, 35, -1) Point(19, 40, 0)
 Point(17, 35, -1) Point(17, 40, 0)
 Point(19, 40, 0) Point(19, 40, 0)

18.public class Test {
public static void main(String[] args) {
short [] args = new short[]{50, 50};
args[0] = 5;
args[1] = 10;
System.out.println(“[” + args[0] + “, ” + args[1] + “]”);
}
}

 Compilation error
 An exception is thrown at runtime
 [50, 50]
 [5, 10]

19.public class Test {
static String msg; //Line 2
public static void main(String[] args) {
String msg; //Line 4
if(args.length > 0) {
msg = args[0]; //Line 6
}
System.out.println(msg); //Line 8
}
}

 Line 2 causes compilation failure
 Line 4 causes compilation failure
 An exception is thrown at runtime by Line 6
 Line 8 causes compilation failure

20.public class Test {

private static void add(int i, int j) {
System.out.println(“int version”);
}

private static void add(Integer i, Integer j) {
System.out.println(“Integer version”);
}

public static void main(String[] args) {
add(10, 20);
}

}
Which modifications, done independently, print “Integer version” on to the console? Select ALL that apply.

 Remove add(int i, int j)  method declaration and definition.
 Replace add(10, 20);  by add(new Integer(10), new Integer(20)); 
 Replace add(10, 20);  by add(10.0, 20.0); 
 Replace add(10, 20);  by add(null, null); 

21.public class Test {

private static void add(double d1, double d2) {
System.out.println(“double version: ” + (d1 + d2));
}

private static void add(Double d1, Double d2) {
System.out.println(“Double version: ” + (d1 + d2));
}

public static void main(String[] args) {
add(10.0, new Integer(10));
}

}

 Compilation error
 double version: 20.0
 Double version: 20.0
 An exception is thrown at runtime

22.public class Test {

private static void add(double d1, double d2) {
System.out.println(“double version: ” + (d1 + d2));
}

private static void add(Double d1, Double d2) {
System.out.println(“Double version: ” + (d1 + d2));
}

public static void main(String[] args) {
add(10.0, new Double(10.0));
}

}

 Compilation error
 double version: 20.0
 Double version: 20.0
 An exception is thrown at runtime

23.public class Test {
public static void main(String[] args) {
int x = 1;
while(checkAndIncrement(x)) {
System.out.println(x);
}
}

private static boolean checkAndIncrement(int x) {
if(x < 5) { x++; return true; } else { return false; } } }

 2 3 4 5
 1 2 3 4
 1 2 3 4 5
 Infinite loop

24.class Student {
String name;
int age;

Student() {
Student(“James”, 25);
}

Student(String name, int age) {
this.name = name;
this.age = age;
}
}

public class Test {
public static void main(String[] args) {
Student s = new Student();
System.out.println(s.name + “:” + s.age);
}
}
What will be the result of compiling and executing Test class?

 Compilation error
 null:0
 James:25
 An exception is thrown at runtime

25.public class Test {
static String str = “KEEP IT “; //Line n1
public static void main(String[] args) {
String str = str + “SIMPLE”; //Line n2
System.out.println(str);
}
}

What will be the result of compiling and executing Test class?

 KEEP IT
 KEEP IT SIMPLE
 SIMPLE
 Compilation error

26.class Square {
int length;
Square sq;

Square(int length) {
this.length = length;
}

void setInner(Square sq) {
this.sq = sq;
}

int getLength() {
return this.length;
}
}

public class TestSquare {
public static void main(String[] args) {
Square sq1 = new Square(10); //Line n1
Square sq2 = new Square(5); //Line n2
sq1.setInner(sq2); //Line n3
System.out.println(sq1.sq.length); //Line n4
}
}

What will be the result of compiling and executing TestSquare class?

 It prints 0 on to the console
 It prints 5 on to the console
 It prints 10 on to the console
 It prints null on to the console
 Compilation error
 An exception is thrown at runtime

27. class Car {
void speed(Byte val) { //Line n1
System.out.println(“DARK”); //Line n2
} //Line n3

void speed(byte… vals) {
System.out.println(“LIGHT”);
}
}

public class Test {
public static void main(String[] args) {
byte b = 10; //Line n4
new Car().speed(b); //Line n5
}
}

Which of the following needs to be done so that LIGHT is printed on to the console?

 No changes are required as given code prints LIGHT on execution
 Delete Line n1, Line n2 and Line n3
 Replace Line n4 with byte... b = 10;
 Replace Line n5 with new Car().speed((byte...)b);

28.Consider below code of AvoidThreats.java file:
public class AvoidThreats {
public static void evaluate(Threat t) { //Line n5
t = new Threat(); //Line n6
t.name = “PHISHING”; //Line n7
}

public static void main(String[] args) {
Threat obj = new Threat(); //Line n1
obj.print(); //Line n2
evaluate(obj); //Line n3
obj.print(); //Line n4
}
}

class Threat {
String name = “VIRUS”;

public void print() {
System.out.println(name);
}
}

What will be the result of compiling and executing AvoidThreats class?

 VIRUS PHISHING
 PHISHING PHISHING
 VIRUS VIRUS
 null VIRUS
 null null
 None of the other options
Incorrect
Threat class doesn’t specify any constructor, hence Java compiler adds below default constructor:
Threat() {super();}

29.public class Test {
int i1 = 10;
static int i2 = 20;

private void change1(int val) {
i1 = ++val; //Line n1
i2 = val++; //Line n2
}

private static void change2(int val) {
i1 = –val; //Line n3
i2 = val–; //Line n4
}

public static void main(String[] args) {
change1(5); //Line n5
change2(5); //Line n6
System.out.println(i1 + i2); //Line n7
}
}

Which of the following statements are correct regarding above code?
Select ALL that apply.

 Line n1 causes compilation error
 Line n2 causes compilation error
 Line n3 causes compilation error
 Line n4 causes compilation error
 Line n5 causes compilation error
 Line n7 causes compilation error

30.class Counter {
static int ctr = 0;
int count = 0;
}

public class Test {
public static void main(String[] args) {
Counter ctr1 = new Counter();
Counter ctr2 = new Counter();
Counter ctr3 = new Counter();

for(int i = 1; i <= 5; i++ ) { ctr1.ctr++; ctr1.count++; ctr2.ctr++; ctr2.count++; ctr3.ctr++; ctr3.count++; } System.out.println(ctr3.ctr + ":" + ctr3.count); } } What will be the result of compiling and executing Test class?

31.public class Test {
private static void m(int i) {
System.out.print(1);
}

private static void m(int i1, int i2) {
System.out.print(2);
}

private static void m(char… args) {
System.out.print(3);
}

public static void main(String… args) {
m(‘A’);
m(‘A’, ‘B’);
m(‘A’, ‘B’, ‘C’);
m(‘A’, ‘B’, ‘C’, ‘D’);
}
}

What will be the result of compiling and executing Test class?

 Above code causes compilation error
 It compiles successfully and on execution prints 3333 on to the console
 It compiles successfully and on execution prints 1233 on to the console
 It compiles successfully and on execution prints 1333 on to the console

32.class Book {
private String name;
private String author;

Book() {}

Book(String name, String author) {
name = name;
author = author;
}

String getName() {
return name;
}

String getAuthor() {
return author;
}
}

public class TestBook {
public static void main(String[] args) {
private Book book = new Book(“Head First Java”, “Kathy Sierra”);
System.out.println(book.getName());
System.out.println(book.getAuthor());
}
}

What will be the result of compiling and executing above code?

 Compilation error in Book class
 Compilation error in TestBook class
 null null
 Head First Java Kathy Sierra

------------------------- Answers --------------------------------------



5. Output: 
   12 
   (Prints `i` (1) and `j` (2) before breaking `outer` loop.)

6. Output: 
   0112 
   (Initial `i=0`, prints `0`, then loops with `i=1` and `i=2`.)

7. Output: 
   21 
   (Toggles `flag`, prints `2` first, then `1` before exiting loop.)

8. Output: 
   Good Morning! Good Evening! 
   (Constructor chaining sets `msg` correctly.)

9. Output: 
   Happy New Year! Happy Holidays! 
   (Method `change` modifies the object’s `msg`.)

10. Output: 
    Happy New Year! Happy New Year! 
    (Method `change` creates a new object, original `obj` unchanged.)

11. Output: 
    static method 
    (Static method called even with `obj = null`.)

12. Answer: 
    green 
    (Condition `area < 7` sets `color` to "green".)

13. Output: 
    Tesla Model S 
    (Condition `price <= 100000` assigns `model` correctly.)

14. Answer: 
    `report` is the method name 
    (Valid method call syntax.)

15. Output: 
    int version char version 
    (`m(i)` calls `int` version, `m('5')` calls `char` version.)

16. Valid `process` methods: 
    - `private static int[] process(int[] arr, int start, int end)`  
    - `private static String process(int[] arr, int start, int end)`  
    - `private static int process(int[] arr, int start, int end)`  

17. Output: 
    Point(19, 35, -1) Point(19, 40, 0) 
    (Static `x` is shared; last update is `19`.)

18. Output: 
    [5, 10] 
    (Array is modified after initialization.)

19. Answer: 
    Line 8 causes compilation failure 
    (Local `msg` might not be initialized before `System.out.println`.)

20. Modifications to print "Integer version": 
    - Remove `add(int i, int j)` method.  
    - Replace `add(10, 20);` with `add(new Integer(10), new Integer(20));`.  

21. Output: 
    double version: 20.0 
    (Autoboxing prefers `double` over `Double` for `add(10.0, new Integer(10))`.)

22. Output: 
    Double version: 20.0 
    (Exact match for `Double` parameters.)

23. Output: 
    Infinite loop 
    (`x` is passed by value; `checkAndIncrement` always gets `x=1`.)

24. Answer: 
    Compilation error 
    (Invalid constructor chaining: `Student("James", 25);` should be `this("James", 25);`.)

25. Answer: 
    Compilation error 
    (Line n2: Local `str` shadows static `str` and is used before initialization.)

26. Output: 
    5 
    (`sq1.sq` refers to `sq2`, so `sq1.sq.length` is `5`.)

27. Answer: 
    Delete Line n1, Line n2, and Line n3 
    (Removing `speed(Byte)` forces `speed(byte...)` to be called.)

28. Output: 
    VIRUS VIRUS 
    (Method `evaluate` modifies a new `Threat` object, not the original `obj`.)

29. Compilation Errors: 
    - Line n3: Cannot access non-static `i1` from static `change2`.  
    - Line n5: Cannot call non-static `change1` from static `main`.  
    - Line n7: Cannot access non-static `i1` from static `main`.  

30. Output: 
    15:5 
    (Static `ctr` is shared (15), instance `count` is per-object (5).)

31. Output: 
    1333 
    (First call matches `m(int)`, others match `m(char…)`.)

32. Answer: 
    Compilation error in TestBook class 
    (`private` modifier not allowed for local variable `book`.)

---

### Key Takeaways:
- Array Indexing: Beware of off-by-one errors (Q1).  
- Loop Control: `break`/`continue` affects reachability (Q2, Q3).  
- Variable Scope: Shadowing and initialization rules matter (Q19, Q25).  
- Method Overloading: Primitive vs. wrapper precedence (Q15, Q20–22).  
- Static vs. Instance: Shared vs. per-object data (Q17, Q30).  

Let me know if you need further clarification on any answer!
