
Date: 1 August,2025


### 1. অ্যারে ইনডেক্স ম্যানেজমেন্ট (Array Index Management) 
- অ্যারের ইনডেক্স 0 থেকে (length - 1) পর্যন্ত হয়।  - লুপ চালানোর সময় `i < arr.length` ব্যবহার করুন (`i <= arr.length` নয়)। 
- `arr[arr.length]/arr[+1]` বা `arr[-1]` এক্সেস করলে `ArrayIndexOutOfBoundsException` আসবে।
- :for(int i : arr) লুপে i অ্যারের মান নির্দেশ করে, ইনডেক্স নয়। যদি আপনি arr[i] ব্যবহার করেন, তাহলে ArrayIndexOutOfBoundsException ঘটার সম্ভাবনা থাকে।


### 2. লুপ এবং  লুপ কন্ট্রোল (Loop Control)
- `break` → লুপ থামিয়ে দেয়।  
- `continue` → লুপের মধ্যে নির্দিষ্ট কিছু শর্তের উপর ভিত্তি করে কিছু কোড ব্লক এড়িয়ে যাওয়ার জন্য ব্যবহৃত হয়, যাতে লুপটি তার পরবর্তী ইটারেশনে যেতে পারে। 

- লেবেল সহ লুপ (Labeled Loops): একটি লুপকে লেবেল দিয়ে চিহ্নিত করে `break` বা `continue` ব্যবহার করলে নির্দিষ্ট লেবেলের লুপটি নিয়ন্ত্রণ করা যায়। 
         যেমন, `break A;` `A` নামক লেবেলযুক্ত লুপ থেকে বের করে দেয় । 
- for(int i : arr)` সিনট্যাক্সটি `arr` অ্যারের প্রতিটি উপাদানকে একে একে `i` ভ্যারিয়েবলের মধ্যে রাখে। 
- পরীক্ষার টিপ: `break` বা `continue` এর পরের কোড চেক করুন (Unreachable হতে পারে)।  


### 3. ভ্যারিয়েবল এবং শ্যাডোইং ভেরিয়েবল (Variable Shadowing), স্ট্যাটিক vs ইনস্ট্যান্স ভেরিয়েবল (Static vs Instance Variables)  
boolean flag = false;
      do {
         if(flag = !flag) {   //variable can be assigned like this?
         System.out.print(1);
         continue;            //what is the role of continue here?
         }
         System.out.print(2);
      } while(flag);
  
* do{ if(flag = !flag) } এর ভেতরে flag ভ্যারিয়েবলের মান পরিবর্তন(will compile?) কি শুধু ওই do{} ব্লকের মধ্যে সীমাবদ্ধ থাকবে নাকি পুরো ক্লাস/while লুপকে প্রভাবিত করবে? 
     Yes, পুরো ক্লাস প্রভাবিত করবে? now while(true)
* assigning value in if(flag = true), is OK and compile


- লোকাল ভেরিয়েবল ক্লাস ভেরিয়েবলকে শ্যাডো করতে পারে।  But অ্যাক্সেস মডিফায়ার (Access Modifiers) can not be used in Local Variable.
- লোকাল ভ্যারিয়েবল (Local Variables): মেথড{} বা ব্লকের{} মধ্যে ঘোষিত ভ্যারিয়েবলগুলো লোকাল ভ্যারিয়েবল। এগুলো ব্যবহার করার আগে অবশ্যই ইনিশিয়ালাইজ করতে হয়, অন্যথায় কম্পাইলেশন ত্রুটি হয় ।
- শ্যাডোইং (Shadowing): যখন একটি লোকাল ভ্যারিয়েবলের নাম কোনো ইনস্ট্যান্স বা স্ট্যাটিক ভ্যারিয়েবলের নামের সাথে মিলে যায়, তখন লোকাল ভ্যারিয়েবলটি প্রিফারেন্স পায়। 
  মেথডের ভেতরে লোকাল ভ্যারিয়েবলটি ব্যবহার করার আগে ইনিশিয়ালাইজ করতে হবে ।


- স্ট্যাটিক ভেরিয়েবল: সব অবজেক্টে শেয়ার হয়।  
- ইনস্ট্যান্স ভেরিয়েবল: প্রতিটি অবজেক্টের আলাদা কপি থাকে।  
- পরীক্ষার টিপ: `static` ভেরিয়েবলের মান শেষ অ্যাসাইনমেন্ট অনুযায়ী পরিবর্তিত হয়।  


### 4. কনস্ট্রাক্টর (Constructors) ও কনস্ট্রাক্টর চেইনিং (Constructor Chaining)
`this()` ব্যবহার: `this()` কীওয়ার্ড ব্যবহার করে একই ক্লাসের অন্য কনস্ট্রাক্টরকে কল করা যায়। এটি কনস্ট্রাক্টর চেইনিং (constructor chaining) এর জন্য ব্যবহৃত হয়। 
     `this()` কলটি অবশ্যই কনস্ট্রাক্টরের প্রথম স্টেটমেন্ট হতে হবে।
* ভ্যারিয়েবল ইনিশিয়ালাইজেশন: কনস্ট্রাক্টরের প্যারামিটার এবং ইনস্ট্যান্স ভ্যারিয়েবলের নাম একই হলে, `this.variableName` ব্যবহার করে ইনস্ট্যান্স ভ্যারিয়েবলকে অ্যাক্সেস করতে হয়। 
  শুধু `variableName` ব্যবহার করলে প্যারামিটার ভ্যারিয়েবলকেই বোঝানো হয়, ফলে ইনস্ট্যান্স ভ্যারিয়েবলটি ইনিশিয়ালাইজড হয় না  


### 5. মেথড এবং রেফারেন্স (Methods and References) পাস-বাই-ভ্যালু (Pass-by-Value)
public class Test {
      public static void change(Message m) {  //
      m = new Message();
      m.msg = "Happy Holidays!"; //This value is unchangle for parameter  reference varible.?
   }
- পাস-বাই-ভ্যালু (Pass-by-Value): জাভাতে সবসময়ই আর্গুমেন্টগুলো পাস-বাই-ভ্যালু হিসেবে কাজ করে। অবজেক্টের ক্ষেত্রে, অবজেক্ট রেফারেন্সের একটি কপি পাস হয়। 
  *** মেথডের মধ্যে রেফারেন্সটিকে একটি নতুন অবজেক্টের দিকে নির্দেশ করা হলেও মূল রেফারেন্সটি অপরিবর্তিত থাকে ।
    * তবে, মেথডের মধ্যে যদি অবজেক্টের কোনো প্রপার্টি পরিবর্তন করা হয়, তবে তা মূল অবজেক্টের প্রপার্টিকেই পরিবর্তন করে ।
- অ্যাক্সেস মডিফায়ার (Access Modifiers): একটি মেথডের রিটার্ন টাইপ এবং প্যারামিটারের সংখ্যা ও ধরন (`method signature`) এর অংশ। মেথড কল করার সময় এটি কম্পাইল-টাইমে পরীক্ষা করা হয়। 
   সঠিক মেথড ডেফিনিশন না থাকলে কম্পাইলেশন ত্রুটি হয় ।
- ভেরিয়েবল আর্গুমেন্ট (Varargs): একটি মেথড প্যারামিটারে `...` ব্যবহার করে ভ্যারিয়েবল আর্গুমেন্ট গ্রহণ করতে পারে। এটি মেথড ওভারলোডিংয়ের ক্ষেত্রে কম প্রাধান্য পায়। 
  যদি এর চেয়ে বেশি নির্দিষ্ট প্যারামিটার তালিকাযুক্ত মেথড থাকে (যেমন `(char)` বা `(char, char)`), তাহলে সেগুলিই আগে কল হবে।

 
### 6. ডেটা টাইপ এবং টাইপ কাস্টিং, Wrapper ক্লাস ও NullPointerException
- প্রিমিটিভ টাইপ এবং রেপার ক্লাস (Primitive vs. Wrapper Classes): মেথড ওভারলোডিংয়ের ক্ষেত্রে, জাভা প্রথমে সঠিক ম্যাচ খোঁজে। যদি একটি প্রিমিটিভ টাইপ আর্গুমেন্ট দেওয়া হয়,
   তবে এটি `varargs` এর চেয়ে একটি উপযুক্ত প্রিমিটিভ টাইপ বা তার রেপার ক্লাসকে বেশি প্রাধান্য দেবে। যেমন, `byte` কে প্রথমে `Byte` বা `int` টাইপের প্যারামিটারে কনভার্ট করার চেষ্টা করা হবে ।
- ডুপ্লিকেট ভ্যারিয়েবল: একই স্কোপে একই নামের দুটি ভ্যারিয়েবল ঘোষণা করা যায় না। `main` মেথডের প্যারামিটার `String[] args` একটি ভ্যারিয়েবল হিসেবে কাজ করে, 
  তাই একই নামের আরেকটি ভ্যারিয়েবল (`short[] args`) ঘোষণা করলে কম্পাইলেশন ত্রুটি হবে ।

- `Boolean.valueOf("TrUe")` → `true` (কেস-ইনসেনসিটিভ)।  
- `Boolean[] arr` → ডিফল্ট মান `null`।  
- পরীক্ষার টিপ: `null` রেফারেন্সে মেথড কল করলে `NullPointerException`।  


### 7. ফর-লুপের বিহেভিয়ার (For-Loop Behavior) 
- `for(initialization; condition; increment)` এর সব অংশ অপশনাল।  
- পরীক্ষার টিপ: ইনিশিয়ালাইজেশনে and Increment-শনে `System.out.print` ব্যবহার করা যায়!  

উদাহরণ:  
for (int i = 0; i < 3; i++): 
int i = 0; এই অংশটি একবারই চলে, লুপ শুরু হওয়ার আগে।
 i++ = লুপের প্রতিটি রাউন্ডের শেষে i এর মান ১ করে বাড়ানো হবে।
      
 --only 1st time ---> . <---the rest---
 for (int i = 0;    i < 3;     i++):
                      |  
     System.out.print(i);

--------------------------------------------------------
| ধাপ | i এর মান    | Condition (i < 3) | কাজ         |
| --- | -------------| ----------------- | ------------ |
| 1   | (int i=0) 0  | true              | `i = 0` প্রিন্ট |
| 2   | (i++)     1  | true              | `i = 1` প্রিন্ট |
| 3   | (i++)     2  | true              | `i = 2` প্রিন্ট |
| 4   | (i++)     3  | false             | লুপ শেষ      |
--------------------------------------------------------

#### 9.0  int i = 0;
            for(System.out.print(i++); i < 2; System.out.print(i++)) {
               System.out.print(i); 
            }       
               Loop-টির অন্য কোনো অংশ কাজ করার আগেই 0 প্রিন্ট হয়ে যায়। 
               তারপর initialize-increment(i++)=1  এবং  condition চেক করে: 1<2 (i < 2)
               লুপের 1st রাউন্ডের শেষে, increment কাজ করার আগেই 1 প্রিন্ট হয়ে যায়(As increment part also contain System.out.print() like initialization part) 
               তারপর i এর মান increment(i++) = 2 হবে। 
               This precess continues until i<2=false.

               Final Output: 011

#### 9.1  int i = 5;
            for(System.out.print(i++); i < 2; System.out.print(i++)) {
               System.out.print(i);
            }
            Loop-টি এক্সিকিউট করলে ফলাফল হবে: 5
            এর কারণ হলো: লুপের অন্য কোনো অংশ কাজ করার আগেই 5 প্রিন্ট হয়ে যায়।  তারপর increment(i++), তারপর condition চেক করে: i < 2

#### 9.2  int i = 5;
            for(i++; i < 2; System.out.print(i++)) {
               System.out.print(i);
            }
            Loop-টি এক্সিকিউট করলে কোনো আউটপুট প্রিন্ট হবে না।
                  এর কারণ হলো:  এখন `i` এর মান `6| লুপের কন্ডিশন `6 < 2` পরীক্ষা করা হয়। এই কন্ডিশনটি -মিথ্যা (`false`)।
                     যেহেতু লুপের শুরুতেই কন্ডিশন মিথ্যা হয়ে গেছে, তাই লুপের বডি (`System.out.print(i);`) এবং লুপের ইনক্রিমেন্ট পার্ট (`System.out.print(i++);`) 
                     কোনটির  প্রিন্ট স্টেটমেন্ট চলতেই পারেনি, তাই কোনো আউটপুটও আসে না।


#### 9.3  int i = 0; //যদি আপনি লুপের বাইরে ভেরিয়েবলটি ঘোষণা করতে চান|
           for(i; i < 2; System.out.print(i++)): //for(i; ...) অংশে, i একা কোনো বৈধ স্টেটমেন্ট বা এক্সপ্রেশন নয় যা ইনিশিয়ালাইজেশন পার্টে ব্যবহার করা যায়। compile-time error|
           for(; i < 2; System.out.print(i++)):  //for(; ...)  বৈধ। লুপের প্রথম অংশটি খালি রাখতে পারেন, শুধুমাত্র একটি সেমিকোলন ব্যবহার করে। 
            for(i = 0; i < 2; System.out.print(i++)) // বৈধ।
             Last two loop's Output: 0
                                    01
                                    1

#### 10  Extended/foreach loop
String [][] arr= {{"A", "B"},{"C","D","E"}}
            for(String [] str : arr) {  //স্ট্রিং অ্যারেগুলোর (rows)  পুনরাবৃত্তি করছে
               for(String s : str) {  // প্রতিটি ভিতরের অ্যারের(column) স্ট্রিংগুলোর মধ্য দিয়ে পুনরাবৃত্তি করছে
             System.out.println(s);
               }
            }

#### 11 Calling Static method
 Test obj = null;
 obj.print(); //Does it compile? If print() is static Will print the output.





------------







1. What will be the result of compiling and executing Test class?
   public class Test {
   public static void main(String[] args) {
   int [] arr = {3, 2, 1};
   for(int i : arr) {
   System.out.println(arr[i]);
   }}}










1. Answer: 
   `int[] arr = {3, 2, 1};` উপাদানগুলি হলো 3, 2, 1। 
     `arr[0]` হলো 3   * `arr[1]` হলো 2   * `arr[2]` হলো 1            
     প্রথম পুনরাবৃত্তিতে, `i` এর মান হবে অ্যারের প্রথম উপাদান, যা 3। এরপর `System.out.println(arr[i]);` অর্থাৎ `System.out.println(arr[3]);` কার্যকর করার চেষ্টা করা হবে।
    যেহেতু অ্যারের বৈধ ইনডেক্সগুলি 0, 1, 2 পর্যন্ত, এবং 3 একটি অবৈধ ইনডেক্স, 
    তাই জাভা ভার্চুয়াল মেশিন (`JVM`) একটি `ArrayIndexOutOfBoundsException` নিক্ষেপ করবে এবং প্রোগ্রামটি বন্ধ হয়ে যাবে।

----------

2. Consider below code of Test.java file:
   public class Test {
   public static void main(String[] args) {
   int elements = 0;
   Object [] arr = {"A", "E", "I", new Object(), "O", "U"}; //Line n1
   for(Object obj : arr) { //Line n2
      if(obj instanceof String) {
      continue;
      } else {
      break;
      }
   elements++; //Line n3
   }
   System.out.println(elements); //Line n4
   }}

   What will be the result of compiling and executing Test class?
    Compilation error at Line n1
    Compilation error at Line n2
    Compilation error at Line n3
    Compilation error at Line n4











2.Answer: 
   সঠিক উত্তর: Line n3 তে একটি কম্পাইলেশন ত্রুটি হবে, কারণ elements++; লাইনটি Unreachable statement।
   যেহেতু elements++ লাইনটি কোনো অবস্থাতেই কার্যকর করা সম্ভব নয় (কারণ এর ঠিক উপরে continue অথবা break সর্বদা কার্যকর হবে), তাই জাভা কম্পাইলার এটিকে একটি "unreachable statement" ত্রুটি হিসেবে ধরবে।
   চতুর্থ পুনরাবৃত্তি: obj এর মান new Object()।
   new Object() একটি String নয়।
   if(obj instanceof String) শর্তটি মিথ্যা হয়।
   else ব্লক কার্যকর হয় এবং break স্টেটমেন্টটি লুপটিকে সম্পূর্ণরূপে বন্ধ করে দেয়।

----------

3. Consider below code of Test.java file:
  public class Test {
   public static void main(String[] args) {
   String [][] arr = { {"%", "$$"}, {"*", "@@@@", "#####"}};
    for(String [] str : arr) {
            for(String s : str) {
                System.out.println(s);
                if(s.length() == 4) //Line n1
                break; //Line n2
            }
    break; //Line n3
  }}}
   What will be the result of compiling and executing Test class?
    %
    % $$
    % $$ *
    % $$ * @@@@
    % $$ * @@@@ #####










3. Answer: 
      ভিতরের লুপ(2 columns print) শেষ হওয়ার পরে, `Line n3` এ থাকা (আউটার লুপ)`break` স্টেটমেন্টটি কার্যকর হয়। এটি বাইরের লুপটিকে ভেঙে দেয় এবং প্রোগ্রামটি শেষ হয়ে যায়। 
      এই কারণে, শুধুমাত্র `"%"` এবং `"$$"` প্রিন্ট হবে।     


----------


4. public class Test {
       public static void main(String[] args) {
           String [][] arr = { {"%", ""}, {"", "@@@@", "#####"}};
           for(String [] str : arr) { // Outer loop
               for(String s : str) { // Inner loop
                   System.out.println(s);
                   if(s.length() == 4) { // Line n1
                       break; // Line n2: Breaks out of the INNER loop
                   }
               }
            break; // Line n3: Breaks out of the OUTER loop
           }
       }
   }












4. Answer: 
   আউটপুট হবে: %
   যেহেতু আউটার লুপটি শুধুমাত্র প্রথম ভেতরের অ্যারে (`{"%", ""}`) প্রসেস করার পরেই `break` হয়ে যাচ্ছে, তাই দ্বিতীয় ভেতরের অ্যারে (`{"", "@@@@", "#####"}`) কখনোই প্রসেস হবে না।



5. public class Test {
   public static void main(String[] args) {
   int i = 1;
   int j = 5;
   int k = 0;
   A: while(true) { i++;
   B: while(true) { j--;
   C: while(true) {
       k += i + j;
       if(i == j) break A;
       else if (i > j) continue A;
       else continue B;
      }}}
       System.out.println(k);
      }}  

   What will be the result of compiling and executing Test class?   
    Compilation error
    Program never terminates as above code causes infinite loop
    6
    11
    15











5. Answer: 
### ফলাফল:  লুপ থেকে বেরিয়ে আসার পর, `System.out.println(k);` কার্যকর হয়। `k` এর চূড়ান্ত মান হলো 15।
 আমরা `i`, `j`, এবং `k` এর মানগুলো ট্র্যাক করব, এবং দেখব প্রোগ্রাম ফ্লো কিভাবে পরিবর্তিত হয়।
      প্রাথমিক মান:  * `i = 1`  * `j = 5`  * `k = 0`
      ১ম পুনরাবৃত্তি (আউটার লুপ A):
      1.  `i++` হয়, তাই `i` এর মান হয় 2।
      2.  ১ম পুনরাবৃত্তি (মাঝের লুপ B):
            * `j--` হয়, তাই `j` এর মান হয় 4।
            * ১ম পুনরাবৃত্তি (ইনার লুপ C):
                * `k += i + j` মানে `k = k + (2 + 4) = 0 + 6 = 6`। এখন `k` এর মান 6।
                * `if(i == j)` (2 == 4)? `false`।
                * `else if (i > j)` (2 \> 4)? `false`।
                * `else` ব্লকে প্রবেশ করে (`i < j` সত্য)। `continue B;` কার্যকর হয়।
                * এটি প্রোগ্রামকে সরাসরি মাঝের লুপ (B) এর পরবর্তী পুনরাবৃত্তিতে নিয়ে যায়।
      -----      
      ২য় পুনরাবৃত্তি (মাঝের লুপ B):
      1.  `j--` হয়, তাই `j` এর মান হয় 3। (`i` এর মান 2 ই থাকে)
      2.  ১ম পুনরাবৃত্তি (ইনার লুপ C):
            * `k += i + j` মানে `k = k + (2 + 3) = 6 + 5 = 11`। এখন `k` এর মান 11।
            * `if(i == j)` (2 == 3)? `false`।
            * `else if (i > j)` (2 \> 3)? `false`।
            * `else` ব্লকে প্রবেশ করে (`i < j` সত্য)। `continue B;` কার্যকর হয়।
            * এটি প্রোগ্রামকে সরাসরি মাঝের লুপ (B) এর পরবর্তী পুনরাবৃত্তিতে নিয়ে যায়।
      -----
      ৩য় পুনরাবৃত্তি (মাঝের লুপ B):
      1.  `j--` হয়, তাই `j` এর মান হয় 2। (`i` এর মান 2 ই থাকে)
      2.  ১ম পুনরাবৃত্তি (ইনার লুপ C):
            * `k += i + j` মানে `k = k + (2 + 2) = 11 + 4 = 15`। এখন `k` এর মান 15।
            * `if(i == j)` (2 == 2)? হ্যাঁ, সত্য\!
            * `break A;` কার্যকর হয়।
            * এই `break` স্টেটমেন্টটি লেবেল `A` দ্বারা চিহ্নিত আউটার `while(true)` লুপ থেকে সম্পূর্ণভাবে প্রোগ্রামকে বের করে দেয়।      

-------------
6.   int i = 0;
      for(System.out.print(i++); i < 2; System.out.print(i++)) {
      System.out.print(i);
   }
   What will be the result of compiling and executing the Test class?















6. Answer: 
সব মিলিয়ে আউটপুট হবে `011`।
    তুমি যে for লুপটা দিয়েছো, সেটা একটু অস্বাভাবিকভাবে লেখা হয়েছে।
    লুপটি structure-এর দিক থেকে বৈচিত্র্যময়, for লুপের initialization এবং update অংশেও কাজ (প্রিন্ট) করানো হয়েছে। এটি কোড execution flow বুঝতে এবং ইন্টারভিউতে চমক দেওয়ার জন্য ব্যবহৃত হয়।
এই লুপে:
লুপের অন্য কোনো অংশ কাজ করার আগেই 0 প্রিন্ট হয়ে যায়। 
তারপর initialize-increment(i++)  এবং  condition চেক করে: i < 2
লুপের ভিতরে System.out.print(i) → আবার প্রিন্ট
লুপের শেষে System.out.print(i++) → update-এর সময়েও প্রিন্ট করে
অর্থাৎ:
প্রতি রাউন্ডে ২ বার প্রিন্ট হচ্ছে: একবার লুপ বডিতে, আরেকবার update অংশে।
-------------------------------------------------------------------------------------
| Step | Code                    | i এর মান | প্রিন্ট | মন্তব্য                  |
| ---- | ----------------------- | -------- | ------- | ------------------------ |
| 1    | `i = 0`                 | 0        |         | ভেরিয়েবল initialize      |
| 2    | `System.out.print(i++)` | 0 → 1    | 0       | initialization অংশ      |
| 3    | `i < 2`                 | 1        |         | condition true           |
| 4    | `System.out.print(i)`   | 1        | 1       | লুপ বডিতে i প্রিন্ট         |
| 5    | `System.out.print(i++)` | 1 → 2    | 1       | update অংশে আবার প্রিন্ট  |
| 6    | `i < 2`                 | 2        |         | false → লুপ শেষ          |
--------------------------------------------------------------------------------------




-----------
7. public class Test {
   public static void main(String[] args) {
      boolean flag = false;
      do {
         if(flag = !flag) { //Line n1     
         System.out.print(1); //Line n2
         continue; //Line n3
         }
         System.out.print(2); //Line n4
      } while(flag); //Line n5
   }}   
   What will be the result of compiling and executing Test class?   
    1
    2
    12
    21
    212
    121

* do{ if(flag = !flag) } এর ভেতরে flag ভ্যারিয়েবলের মান পরিবর্তন কি শুধু ওই do{} ব্লকের মধ্যে সীমাবদ্ধ থাকবে নাকি পুরো ক্লাস/while লুপকে প্রভাবিত করবে?






















7. Answer: Output:  12
         -flag এর মান পরিবর্তন তার স্কোপের মধ্যে যেখানেই ঘটুক না কেন, সেটি সেই একই ভ্যারিয়েবলের মানকে আপডেট করে, যার ফলে এর উপর নির্ভরশীল যেকোনো অংশের (যেমন while লুপের শর্ত) আচরণ পরিবর্তিত হয়।
         -continue এর মানে হলো "এই ইটারেশনের বাকিটা বাদ দাও এবং পরের ইটারেশনে যাও।"

      -প্রথম ইটারেশনে:
         * `if(flag = !flag)` শর্তটি `true` হয়।
         * `System.out.print(1);` (Line n2) কার্যকর হয়।
         * এরপর যখন `continue;` (Line n3) কার্যকর হয়, তখন এটি নির্দেশ দেয় যে এই ইটারেশনের আর কোনো কোড (অর্থাৎ `System.out.print(2);` - Line n4) চালানোর দরকার নেই।
         * প্রোগ্রাম নিয়ন্ত্রণ সরাসরি `while(flag);` (Line n5) অংশে চলে যায় শর্ত পরীক্ষা করার জন্য, এবং পরের ইটারেশনের জন্য প্রস্তুতি নেয়।
            যদি `continue` না থাকত:
                  * যদি `continue` না থাকত, তাহলে প্রথম ইটারেশনে `System.out.print(1);` এর পর `System.out.print(2);` লাইনটিও কার্যকর হতো। 
                    ফলে আউটপুট ভিন্ন হতো (`12` এর বদলে `122` আসত, যদি লুপ দ্বিতীয়বার চলত)।
            
            `continue` স্টেটমেন্টটি মূলত লুপের মধ্যে নির্দিষ্ট কিছু শর্তের উপর ভিত্তি করে কিছু কোড ব্লক এড়িয়ে যাওয়ার জন্য ব্যবহৃত হয়, যাতে লুপটি তার পরবর্তী ইটারেশনে যেতে পারে। 
            এটি `break` স্টেটমেন্টের থেকে ভিন্ন, কারণ `break` পুরো লুপটিকেই থামিয়ে দেয়, কিন্তু `continue` শুধু বর্তমান ইটারেশনকে থামিয়ে পরের ইটারেশনে যায়।
         * দ্বিতীয় লুপের ইটারেশন, do লুপে আবার প্রবেশ করে। এবার if ব্লক এড়িয়ে যাওয়া হয়(কারণ, এখন flag এর মান false(flag= !true)) ।

---
8.public class Greetings {
   String msg = null;
      public Greetings() {
      this("Good Morning!");
      }
      public Greetings(String str) {
      msg = str;
      }   
      public void display() {
        System.out.println(msg);
      }

      public static void main(String [] args) {
      Greetings g1 = new Greetings();
      Greetings g2 = new Greetings("Good Evening!");
      g1.display();
      g2.display();
      }}
   
    -null Good Evening!
    -Good Morning! Good Evening!
    -Good Morning! null
    -null null




















8. Output: Good Morning! Good Evening! 
   (Constructor chaining sets `msg` correctly.)

-----
9. Test.java
  class Message {
   String msg = "Happy New Year!";
   public void print() {
      System.out.println(msg);
   }}
   
   public class Test {
   public static void change(Message m) {
      m.msg = "Happy Holidays!";
   }
   
   public static void main(String[] args) {
      Message obj = new Message();
      obj.print();
      change(obj);
      obj.print();
   }}
   
    -null Happy Holidays!
    -Happy Holidays! Happy Holidays!
    -null null
    -Happy New Year! Happy Holidays!

















9. Output: 
   Happy New Year! Happy Holidays! 
   কারণ অবজেক্ট obj-র রেফারেন্স change() মেথডে পাঠানো হয়, তাই মূল msg মান বদলে যায়।


---
*
10. Test.java 
   class Message {
      String msg = "Happy New Year!";   
      public void print() {
      System.out.println(msg);
    }}
   
   public class Test {
      public static void change(Message m) {
      m = new Message();
      m.msg = "Happy Holidays!";
   }
   
   public static void main(String[] args) {
      Message obj = new Message();
      obj.print();
      change(obj);
      obj.print();
   }}
   
    Happy New Year! Happy Holidays!
    Happy Holidays! Happy Holidays!
    Happy New Year! Happy New Year!
    null Happy New Year!
















10. Answer:
-প্রথম obj.print() কল: এটি "Happy New Year!" প্রিন্ট করে।
-change(obj) মেথড কল: obj এর রেফারেন্সের একটি কপি m ভেরিয়েবলে পাস করা হয়।
-change মেথডের ভেতরে: m = new Message(); লাইনটি একটি নতুন Message অবজেক্ট তৈরি করে। এখন m ভেরিয়েবলটি এই নতুন অবজেক্টের দিকে নির্দেশ করছে। কিন্তু main মেথডে থাকা obj ভেরিয়েবলটি -এখনও সেই পুরোনো অবজেক্টটিকেই নির্দেশ করছে। মূল রেফারেন্সের কোনো পরিবর্তন হয়নি।
-m.msg = "Happy Holidays!"; লাইনটি শুধুমাত্র নতুন তৈরি হওয়া অবজেক্টটির msg পরিবর্তন করে।
-দ্বিতীয় obj.print() কল: obj এখনও পুরোনো অবজেক্টটিকেই নির্দেশ করছে, যার msg এর মান অপরিবর্তিত আছে। তাই, এটি আবার "Happy New Year!" প্রিন্ট করে।
Output:  Happy New Year! Happy New Year! 

---------

11.public class Test {
public static void print() {
System.out.println("static method");
}

public static void main(String[] args) {
Test obj = null;
obj.print();
}
}


















11. Output: 
    static method 
    (Static method called even with `obj = null`.)

-------

12. public class Wall {
      public static void main(String args[]) {
      double area = 5.7;
      String color;
      if (area < 7) color = "green"; 
         System.out.println(color); 
     } }
      
       green
       NullPointerException
       Compilation error










12. Answer:
      if (area < 7) // এই শর্তটি (5.7 < 7) সত্য।
       color = "green"; // তাই color এর মান "green" হবে।
        System.out.println(color); // এখানে color ভ্যারিয়েবলটি ব্যবহার করার চেষ্টা করা হচ্ছে। কিন্তু জাভা কম্পাইলার নিশ্চিত নয় যে, সব পরিস্থিতিতে color এর একটি মান থাকবে।
  যদি আপনি String color = null; ব্যবহার করেন, তাহলে আউটপুট হবে green। আর যদি String color; রেখেই কম্পাইল করতে চান, তাহলে Compilation error পাবেন।
-------

13. public class Test {
      public static void main(String[] args) {
      double price = 90000;
      String model;
         if(price > 100000) {  model = "Tesla Model X";
         }else if(price <= 100000) { model = "Tesla Model S"; } 
      System.out.println(model); 
      } }
      
       Tesla Model X
       Tesla Model S
       Compilation Error
















13. Output: 
Tesla Model S 
যদি এমন পরিস্থিতি থাকে, যেখানে  if-else if চেইন সব সম্ভাব্য শর্তকে কভার করছে না। এই পরিস্থিতিতে, জাভা কম্পাইলার একটি কম্পাইল-টাইম এরর দেবে।

-------------
14. Following statement in a Java program compiles successfully:
student.report(course); 
What can you say for sure?

 student is the reference variable name
 student is the class name
 report is the method name
 course must be of String type











14. Answer: 
    `report` is the method name 
    (Valid method call syntax.)

-------
15.public class Test {
private static void m(int x) {
System.out.println("int version");
}

private static void m(char x) {
System.out.println("char version");
}

public static void main(String [] args) {
int i = '5';
m(i);
m('5');
}
}

 int version int version
 char version char version
 int version char version
 char version int version
 Compilation error


















15. Output: 
    int version char version 
    (`m(i)` calls `int` version, `m('5')` calls `char` version.)
    int i = '5';: এখানে `'5'` একটি ক্যারেক্টার লিটারাল। জাভাতে, ক্যারেক্টারগুলো তাদের অ্যাসকি (ASCII) বা ইউনিকোড (Unicode) মান দ্বারাও প্রকাশ করা যেতে পারে। ক্যারেক্টার `'5'` এর অ্যাসকি মান হলো `53`।
    * আপনি যখন একটি `char` টাইপের মানকে একটি `int` টাইপের ভ্যারিয়েবলে অ্যাসাইন করেন (`int i = '5';`), তখন সেই ক্যারেক্টারের অ্যাসকি মানটি `i` ভ্যারিয়েবলে সংরক্ষণ করা হয়। সুতরাং, `i` এর মান এখন `53`।
--------



16.public class Test {
public static void main(String [] args) {
int [] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
System.out.println(process(arr, 3, 8)); //Line 5
}
/*INSERT*/
}
Line 5 causes compilation error as process method is not found. 
Which of the following method definitions, if used to replace /*INSERT*/, will resolve the compilation error?

Select ALL that apply:-
a. private static int[] process(int [] arr, int start, int end) { return null; }
b. private static String process(int [] arr, int start, int end) { return null; }
c. private static int process(int [] arr, int start, int end) { return null; }
d. private static String[] process(int [] arr, int start, int end) { return null; }









16.Answer:
Array-ও একটি অবজেক্ট, তাই null রিটার্ন করে বোঝানো হয় যে মেথডটি কোনো অ্যারে অবজেক্ট তৈরি বা খুঁজে পায়নি।
int[] a; লিখলে a এর ডিফল্ট মান null থাকে, কারণ এটি একটি রেফারেন্স টাইপ। 
একটি মেথড যা একটি অ্যারে (int[]) রিটার্ন করার কথা, তা null রিটার্ন করতে পারে। null মানে হলো কোনো অবজেক্টের রেফারেন্স নেই। 

------------

17.class Point {
   static int x;
   int y, z;

   public String toString() { return "Point(" + x + ", " + y + ", " + z + ")"; }
   }
   
   public class Test {
   public static void main(String[] args) {
   Point p1 = new Point();
   p1.x = 17;  p1.y = 35;  p1.z = -1;
   
   Point p2 = new Point();
   p2.x = 19;  p2.y = 40;  p2.z = 0;
   
   System.out.println(p1); //Line n1
   System.out.println(p2); //Line n2
   }
   }   
    Point(17, 35, -1) Point(19, 40, 0)
    Point(19, 35, -1) Point(19, 40, 0)
    Point(17, 35, -1) Point(17, 40, 0)
    Point(19, 40, 0) Point(19, 40, 0)













Ans: Point(19, 35, -1) Point(19, 40, 0)
static value effect last assigned one.


----
18.public class Test {
   public static void main(String[] args) {
   short [] args = new short[]{50, 50};
   args[0] = 5;
   args[1] = 10;
   System.out.println("[" + args[0] + ", " + args[1] + "]");
   }
   }
   
    Compilation error
    An exception is thrown at runtime
    [50, 50]
    [5, 10]












Ans: 
Compilation error for duplicate args from psvm(argument)


---
19.public class Test {
   static String msg; //Line 2
   public static void main(String[] args) {
   String msg; //Line 4
   if(args.length > 0) {
   msg = args[0]; //Line 6
   }
   System.out.println(msg); //Line 8
   }
   }
   
    Line 2 causes compilation failure
    Line 4 causes compilation failure
    An exception is thrown at runtime by Line 6
    Line 8 causes compilation failure












Ans:
    Line 4 causes compilation failur, LOCAL variable must initialize while declare.

---
20. public class Test {
   private static void add(int i, int j) {
   System.out.println("int version");
   }
   
   private static void add(Integer i, Integer j) {
   System.out.println("Integer version");
   }
   
   public static void main(String[] args) {
   add(10, 20);
   }
   
   }
   Which modifications, done independently, print "Integer version" on to the console? Select ALL that apply.   
    Remove add(int i, int j)  method declaration and definition.
    Replace add(10, 20);  by add(new Integer(10), new Integer(20)); 
    Replace add(10, 20);  by add(10.0, 20.0); 
    Replace add(10, 20);  by add(null, null); 














Ans:
যে পরিবর্তনগুলো "Integer version" প্রিন্ট করবে তা হলো:
  1. Remove add(int i, int j) method declaration and definition. (add(int i, int j) মেথড ডিক্লারেশন এবং ডেফিনিশন Delete দিন।)
  2. Replace add(10, 20); by add(new Integer(10), new Integer(20)); (add(10, 20); কে add(new Integer(10), new Integer(20)); দ্বারা প্রতিস্থাপন করুন।)
  3. Replace add(10, 20); by add(null, null); (add(10, 20); কে add(null, null); দ্বারা প্রতিস্থাপন করুন।)

### কারণ:
* প্রথম বিকল্প: যদি `add(int i, int j)` মেথডটি সরিয়ে ফেলা হয়, তাহলে জাভা কম্পাইলারের কাছে শুধুমাত্র `add(Integer i, Integer j)` মেথডটি থাকবে। 
  তখন `add(10, 20)` কলটি অটোবক্সিং (autoboxing) এর মাধ্যমে স্বয়ংক্রিয়ভাবে `add(Integer.valueOf(10), Integer.valueOf(20))` তে রূপান্তরিত হবে এবং "Integer version" প্রিন্ট করবে।


----
21. public class Test {
   private static void add(double d1, double d2) {
   System.out.println("double version: " + (d1 + d2));
   }
   
   private static void add(Double d1, Double d2) {
   System.out.println("Double version: " + (d1 + d2));
   }
   
   public static void main(String[] args) {
   add(10.0, new Integer(10));
   }
   
   }
   
    Compilation error
    double version: 20.0
    Double version: 20.0
    An exception is thrown at runtime











Ans:
সমস্যা হলো, কোনো মেথডই এই দুটি ভিন্ন টাইপের আর্গুমেন্ট (double এবং Integer) সরাসরি গ্রহণ করতে পারে না।
প্রথম মেথড (double, double) এর জন্য, দ্বিতীয় আর্গুমেন্ট Integer থেকে double এ রূপান্তর সম্ভব (আনবক্সিং)।
দ্বিতীয় মেথড (Double, Double) এর জন্য, প্রথম আর্গুমেন্ট double থেকে Double এ রূপান্তর সম্ভব (অটোবক্সিং)।

যেহেতু উভয় মেথডের প্যারামিটারেই একটি রূপান্তরের (conversion) প্রয়োজন হয় এবং কম্পাইলার এই ক্ষেত্রে কোন রূপান্তরটি অগ্রাধিকার দেবে তা নির্ধারণ করতে পারে না, 
তাই এটি একটি অস্পষ্ট কল (ambiguous call) হিসেবে ধরা পড়ে। এর ফলে কম্পাইলেশন ত্রুটি দেখা দেয়।


22.public class Test {
   private static void add(double d1, double d2) {
      System.out.println("double version: " + (d1 + d2));
   }
   
   private static void add(Double d1, Double d2) {
      System.out.println("Double version: " + (d1 + d2));
   }
   
   public static void main(String[] args) {
      add(10.0, new Double(10.0));
   }   
   }
   
    Compilation error
    double version: 20.0
    Double version: 20.0
    An exception is thrown at runtime












Ans:
কম্পাইলার যখন ওভারলোড করা মেথডগুলির মধ্যে একটি বেছে নেয়, তখন এটি সরাসরি মিল (exact match) বা নিকটতম প্রিমিটিভ টাইপকে অগ্রাধিকার দেয়। 
এই ক্ষেত্রে, প্রথম আর্গুমেন্ট double হওয়ায়, কম্পাইলার add(double d1, double d2) মেথডটিকে বেছে নেবে।

--

23. public class Test {
   public static void main(String[] args) {
   int x = 1;
   while(checkAndIncrement(x)) {
      System.out.println(x);
   }}
   
   private static boolean checkAndIncrement(int x) {
      if(x < 5) { x++; return true; } 
      else { return false; } 
   } }
   
    2 3 4 5
    1 2 3 4
    1 2 3 4 5
    Infinite loop













Ans:
এটি পাস-বাই-ভ্যালু (pass-by-value) পদ্ধতির একটি উদাহরণ। checkAndIncrement মেথডের x ভ্যারিয়েবলটি main মেথডে সংজ্ঞায়িত x ভ্যারিয়েবলের একটি কপি ধারণ করে।
সুতরাং, checkAndIncrement মেথডে x এর যে পরিবর্তন করা হয়, তা main মেথডের x ভ্যারিয়েবলে প্রতিফলিত হয় না। 
main এর x এর মান 1-ই থাকে, কারণ main এর ভেতরের কোড এর মান পরিবর্তন করছে না।
প্রতিবার checkAndIncrement মেথডটি 1 আর্গুমেন্ট মান দিয়ে কল করা হয়, তাই সর্বদা true ফেরত আসে এবং ফলস্বরূপ while লুপটি অনির্দিষ্টকালের জন্য কার্যকর হতে থাকে।

--
24.class Student {
   String name;
   int age;
   
   Student() {
   Student("James", 25);
   }
   
   Student(String name, int age) {
   this.name = name;
   this.age = age;
   }
   }
   
   public class Test {
   public static void main(String[] args) {
   Student s = new Student();
   System.out.println(s.name + ":" + s.age);
   }
   }
   What will be the result of compiling and executing Test class?
   
    Compilation error
    null:0
    James:25
    An exception is thrown at runtime














Ans:
-একটি কনস্ট্রাক্টর থেকে অন্য কনস্ট্রাক্টরকে কল করার জন্য আপনাকে অবশ্যই this() কীওয়ার্ড ব্যবহার করতে হবে, যেমন: this("James", 25);।
-এই কোডটি সফলভাবে কম্পাইল হবে না, তাই রানটাইমে কোনো আউটপুট বা ব্যতিক্রম (exception) দেখা যাবে না। এটি সরাসরি কম্পাইলেশন ধাপেই ব্যর্থ হবে।

---
25.public class Test {
   static String str = "KEEP IT "; //Line n1
      public static void main(String[] args) {
         String str = str + "SIMPLE"; //Line n2
         System.out.println(str);
      }
   }
   
   What will be the result of compiling and executing Test class?
   
    KEEP IT
    KEEP IT SIMPLE
    SIMPLE
    Compilation error











Ans:
String str = str + "SIMPLE"; // Line n2: এখানে মূল সমস্যা| 2nd "str" আসলে কোন str কে নির্দেশ করছে তা নিয়ে অস্পষ্টতা দেখা দেয়।
জাভা কম্পাইলার এখানে বিভ্রান্ত হয়ে যায়। Output: Compilation error

26.class Square {
   int length;
   Square sq; //does it allow length for String, but what about sq?
   
   Square(int length) {
   this.length = length;
   }
   
   void setInner(Square sq) {
   this.sq = sq;
   }
   
   int getLength() {
   return this.length;
   }
   }
   
   public class TestSquare {
   public static void main(String[] args) {
   Square sq1 = new Square(10); //Line n1
   Square sq2 = new Square(5); //Line n2
   sq1.setInner(sq2); //Line n3
   System.out.println(sq1.sq.length); //Line n4
   }
   }
   
   What will be the result of compiling and executing TestSquare class?
   
    It prints 0 on to the console
    It prints 5 on to the console
    It prints 10 on to the console
    It prints null on to the console
    Compilation error
    An exception is thrown at runtime













Ans: 
তা কম্পাইল করে চালালে আউটপুট হবে: 5
System.out.println(sq1.sq.length); //Line n4 **Calling reference varible to other reference varible set by sq1.setInner(sq2); //Line n3

----
27. class Car {
    void speed(Byte val) { //Line n1
        System.out.println("DARK"); //Line n2
    } //Line n3
    
    void speed(byte… vals) {
     System.out.println("LIGHT");
    }
    }
    
    public class Test {
    public static void main(String[] args) {
    byte b = 10; //Line n4
    new Car().speed(b); //Line n5
    }
    }
   
   Which of the following needs to be done so that LIGHT is printed on to the console?
   
    No changes are required as given code prints LIGHT on execution
    Delete Line n1, Line n2 and Line n3
    Replace Line n4 with byte... b = 10;
    Replace Line n5 with new Car().speed((byte...)b);













Ans:
"LIGHT" প্রিন্ট করার জন্য void speed(Byte val) মেথডটি (Line n1, Line n2, Line n3) মুছে ফেলতে হবে।
--


28.Consider below code of AvoidThreats.java file:
   public class AvoidThreats {
   public static void evaluate(Threat t) { //Line n5
   t = new Threat(); //Line n6
   t.name = "PHISHING"; //Line n7
   }
   
   public static void main(String[] args) {
   Threat obj = new Threat(); //Line n1
   obj.print(); //Line n2
   evaluate(obj); //Line n3
   obj.print(); //Line n4
   }
   }
   
   class Threat {
   String name = "VIRUS";
   
   public void print() {
   System.out.println(name);
   }
   }

What will be the result of compiling and executing AvoidThreats class?
 VIRUS PHISHING
 PHISHING PHISHING
 VIRUS VIRUS
 null VIRUS
 null null
 None of the other options















Ans: 
-প্রথম obj.print() কল: এটি "VIRUS" প্রিন্ট করে।
-evaluate(obj) মেথড কল: obj এর রেফারেন্সের একটি কপি t ভেরিয়েবলে পাস করা হয়।
-evaluate মেথডের ভেতরে: t = new Threat(); (লাইন n6) একটি নতুন Threat অবজেক্ট তৈরি করে। এখন t নতুন অবজেক্টকে নির্দেশ করে। obj ভেরিয়েবলটি পুরোনো অবজেক্টকেই নির্দেশ করতে থাকে।
-t.name = "PHISHING"; (লাইন n7) শুধুমাত্র নতুন অবজেক্টের name পরিবর্তন করে।

-দ্বিতীয় obj.print() কল: obj এখনও পুরোনো অবজেক্টটিকেই নির্দেশ করছে, যার name এর মান অপরিবর্তিত আছে। তাই, এটি আবার "VIRUS" প্রিন্ট করে।
আউটপুট হবে:
VIRUS
VIRUS


----

29.public class Test {
   int i1 = 10;
   static int i2 = 20;
   
   private void change1(int val) {
   i1 = ++val; //Line n1
   i2 = val++; //Line n2
   }
   
   private static void change2(int val) {
   i1 = –-val; //Line n3
   i2 = val–-; //Line n4
   }
   
   public static void main(String[] args) {
   change1(5); //Line n5
   change2(5); //Line n6
   System.out.println(i1 + i2); //Line n7
   }
   }
   
   Which of the following statements are correct regarding above code?
   Select ALL that apply.
   
    Line n1 causes compilation error
    Line n2 causes compilation error
    Line n3 causes compilation error
    Line n4 causes compilation error
    Line n5 causes compilation error
    Line n7 causes compilation error













Ans:
Line n3 causes compilation error (কারণ static মেথড change2 থেকে ইনস্ট্যান্স ভ্যারিয়েবল i1 অ্যাক্সেস করা হচ্ছে)।
Line n5 causes compilation error (কারণ static মেথড main থেকে নন-স্ট্যাটিক মেথড change1 কে সরাসরি কল করা হচ্ছে)।
Line n7 causes compilation error (কারণ static মেথড main থেকে ইনস্ট্যান্স ভ্যারিয়েবল i1 অ্যাক্সেস করা হচ্ছে)।

--
30. class Counter {
   static int ctr = 0;
   int count = 0;
   }
   
   public class Test {
   public static void main(String[] args) {
   Counter ctr1 = new Counter();
   Counter ctr2 = new Counter();
   Counter ctr3 = new Counter();
   
   for(int i = 1; i <= 5; i++ ) { 
   ctr1.ctr++; ctr1.count++; ctr2.ctr++; ctr2.count++; ctr3.ctr++; ctr3.count++; 
   } 
   System.out.println(ctr3.ctr + ":" + ctr3.count); } 
   } 
   What will be the result of compiling and executing Test class?












Ans:
লুপ এক্সিকিউশন (১ থেকে ৫ পর্যন্ত): লুপটি ৫ বার চলে।
ctr এর জন্য: 
ctr1.ctr++, ctr2.ctr++, এবং ctr3.ctr++ - এই তিনটি লাইন একই স্ট্যাটিক ctr ভেরিয়েবলের মান বাড়ায়। প্রতিটি লুপে ctr এর মান 3 করে বাড়ে।
লুপ শেষে, ctr এর মোট মান হয় 5 (লুপের সংখ্যা) * 3 (প্রতি লুপে বৃদ্ধি) = 15।

count এর জন্য: 
ctr1.count++, ctr2.count++, এবং ctr3.count++ - এই তিনটি লাইন তাদের নিজস্ব ইনস্ট্যান্স ভেরিয়েবলের মান বাড়ায়।
ctr3.count এর মান শুধুমাত্র ctr3.count++ লাইনটি দ্বারা প্রভাবিত হয়। এই লাইনটি ৫ বার এক্সিকিউট হয়।
লুপ শেষে, ctr3.count এর মান হয় 5।

তাই, System.out.println() প্রিন্ট করবে 15:5।


   
31.public class Test {
   private static void m(int i) {
   System.out.print(1);
   }
   
   private static void m(int i1, int i2) {
   System.out.print(2);
   }
   
   private static void m(char… args) {
   System.out.print(3);
   }
   
   public static void main(String… args) {
   m('A');
   m('A', 'B');
   m('A', 'B', 'C');
   m('A', 'B', 'C', 'D');
   }
   }
   
   What will be the result of compiling and executing Test class?
   
    Above code causes compilation error
    It compiles successfully and on execution prints 3333 on to the console
    It compiles successfully and on execution prints 1233 on to the console
    It compiles successfully and on execution prints 1333 on to the console












Ans:
It compiles successfully and on execution prints 1233 on to the console
   
32.class Book {
   private String name;
   private String author;
   
   Book() {}
   
   Book(String name, String author) {
   name = name;
   author = author;
   }
   
   String getName() {
   return name;
   }
   
   String getAuthor() {
   return author;
   }
   }
   
   public class TestBook {
   public static void main(String[] args) {
   private Book book = new Book("Head First Java", "Kathy Sierra");  
   System.out.println(book.getName());
   System.out.println(book.getAuthor());
   }
   }
   
   What will be the result of compiling and executing above code?
   
    Compilation error in Book class
    Compilation error in TestBook class
    null null
    Head First Java Kathy Sierra












Ans: 
Compilation error in TestBook class (`private` modifier not allowed for local variable `book`.)

যদি private শব্দটি সরিয়ে দেন, তাহলে এটি Book book = new Book(...) হয়ে যাবে এবং কম্পাইল হবে। Output: null null





-
