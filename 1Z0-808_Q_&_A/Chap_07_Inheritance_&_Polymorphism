Medium.

*** যদি আমি Inheritance না জানি, তাহলে আমি কী কী সমস্যার সম্মুখীন হব? Inheritance-এর সুবিধা, অসুবিধা কী কী?
*** "is-a" vs "has-a", কম্পোজিশন/অ্যাগ্রিগেশন/লুজ কাপলিং (Composition/Aggregation/loose cupling) কী?
*** পলিউমরফিজম কী এবং ইনহেরিটেন্সের সাথে এর সম্পর্ক কী?
*** Abstract ক্লাস এবং Interface কখন কোনটা ব্যবহার করব?
*** মেথড ওভাররাইডিং (method overriding) এবং মেথড ওভারলোডিং (method overloading) ইনহেরিটেন্সের সাথে কীভাবে সম্পর্কিত এবং ব্যাংকিং অ্যাপ্লিকেশনের ডেভেলপমেন্টে এদের ব্যবহার কী?

 Web: https://github.com/mahadi84/Learning-A-Programming/blob/main/OOP_What_%26_Why_%3F


=============== কিছু বাস্তব জীবনের সাথে সম্পর্কিত প্রশ্ন ========================

১.  একটি  Empoloye Management সিস্টেমে  বিভিন্ন ধরণের কর্মচারী থাকে (যেমন Manager, Engineer, Salesperson)। 
    প্রত্যেকেরই কিছু সাধারণ তথ্য থাকে (যেমন employeeId, name, salary) এবং কিছু বিশেষ কার্যকারিতা থাকে (Manager-এর জন্য manageTeam(); Engineer-এর জন্য writeCode(); Salesperson-এর জন্য makeSale())। 
    কর্মীদের তথ্য সংরক্ষণ এবং তাদের কাজ পরিচালনা করার জন্য আলাদা আলাদা কোড তৈরি করলে কতটা কোড পুনরাবৃত্তি হবে এবং সিস্টেমের নকশা কতটা অগোছালো হবে?

২.  যদি একটি সফটওয়্যার সিস্টেমে ভবিষ্যতে নতুন ধরণের মডিউল বা কম্পোনেন্ট যোগ করার প্রয়োজন হয় যা বিদ্যমান মডিউলগুলির সাথে কিছু কার্যকারিতা শেয়ার করে, 
    তাহলে সেই নতুন কার্যকারিতা যোগ করা কতটা কঠিন হবে বলে আপনি মনে করেন এবং কেন?

৩.  "is-a" vs "has-a" সম্পর্ক বলতে কী বোঝায়? ইনহেরিটেন্স কীভাবে এই সম্পর্ককে কোডে প্রকাশ করতে সাহায্য করে? একটি বাস্তব উদাহরণ দিন যেখানে ইনহেরিটেন্স এই সম্পর্ক স্থাপন করতে পারে।
৪.  পলিউমরফিজম কী এবং ইনহেরিটেন্সের সাথে এর সম্পর্ক কী? ইনহেরিটেন্স ছাড়া পলিউমরফিজম বাস্তবায়ন করা কেন কঠিন?

###  অভিজ্ঞতার আলোকে:
* "ব্যাংকিং সিস্টেমে বিভিন্ন ধরণের অ্যাকাউন্ট (যেমন সঞ্চয়ী, চলতি, ঋণ) বা গ্রাহকদের বিভিন্ন বৈশিষ্ট্য (যেমন সাধারণ, প্রিভিলেজড) মডেল করার ক্ষেত্রে ইনহেরিটেন্স কীভাবে একটি কার্যকর উপায় হতে পারে বলে আপনি মনে করেন? কোনো বাস্তব উদাহরণ দিতে পারবেন?"
* "বড় আকারের ব্যাংকিং অ্যাপ্লিকেশনগুলোতে, যেখানে অনেকগুলো মডিউল এবং কম্পোনেন্ট থাকে, ইনহেরিটেন্স কীভাবে কোডের সংগঠন এবং জটিলতা কমাতে সাহায্য করতে পারে?"

### আরও গভীর এবং কৌশলগত প্রশ্ন:
* "আপনি কি মনে করেন ইনহেরিটেন্স ব্যবহার করে নতুন ফিচার যোগ করা বা বিদ্যমান কোডে পরিবর্তন আনা কতটা সহজ বা কঠিন হতে পারে? এর সুবিধা এবং অসুবিধাগুলো কী কী?"
* "বিভিন্ন ধরণের ইনহেরিটেন্স (যেমন সিঙ্গেল, মাল্টিপল) এবং কম্পোজিশনের (Composition) মধ্যে কখন কোনটি ব্যবহার করা ব্যাংকিং সিস্টেমের জন্য সবচেয়ে উপযুক্ত বলে আপনি মনে করেন?"

============================================================================
This chapter covers essential Java concepts including:
- Class inheritance and polymorphism
- Abstract classes and interfaces
- Method overriding and overloading
- Access modifiers in inheritance
- Constructor chaining
- Casting and reference types

## Key Concepts to Master

### 1. Inheritance Basics
- extends keyword for class inheritance
- Single inheritance limitation (one direct parent class)
- super/this keyword to access parent members
- Constructor chaining rules (super() must be first line)

### 2. Polymorphism
- Reference type vs object type
- Method overriding rules:
  - Same method signature
  - Covariant return types allowed
  - Access modifier must be same or broader
  - Exception restrictions (narrower or same)
- Variable hiding (not polymorphism)


Covariant Return type(কোভেরিয়েন্ট রিটার্ন টাইপ):
যখন একটি সাবক্লাসের একটি মেথড তার প্যারেন্ট ক্লাসের একই নামের মেথডকে ওভাররাইড করে, 
তখন সাবক্লাসের মেথডটি প্যারেন্ট ক্লাসের মেথডের রিটার্ন টাইপের চেয়ে আরও নির্দিষ্ট (সাবটাইপ) রিটার্ন টাইপ দিতে পারে। একেই কোভেরিয়েন্ট রিটার্ন টাইপ বলে।

উদাহরণ:
ধরা যাক, Animal ক্লাসের getAnimal() মেথড Animal রিটার্ন করে। Dog হলো Animal এর সাবক্লাস। Dog ক্লাসে getAnimal() মেথডটিকে ওভাররাইড করে Dog রিটার্ন করতে পারে।
class Animal {
    public Animal getAnimal() {
        return new Animal();
    }
}
class Dog extends Animal {
    @Override
    public Dog getAnimal() { // কোভেরিয়েন্ট রিটার্ন টাইপ: Dog, যা Animal এর সাবটাইপ
        return new Dog();
    }
}
এই উদাহরণে, Dog ক্লাসের getAnimal() মেথড Animal এর পরিবর্তে Dog রিটার্ন করছে, যা একটি কোভেরিয়েন্ট রিটার্ন টাইপের উদাহরণ। 
এর ফলে কোড আরও টাইপ-নিরাপদ হয় এবং অপ্রয়োজনীয় কাস্টিংয়ের প্রয়োজন হয় না।




### 3. Abstract Classes vs Interfaces

ABSTRACT Class:
উদ্দেশ্য (Objectives):সাধারণ বৈশিষ্ট্য শেয়ার করা।
 -এটি মূলত একটি ব্লুপ্রিন্ট বা টেমপ্লেট হিসেবে কাজ করে যা অন্যান্য ক্লাসকে ইনহেরিট (inherit) করার জন্য ডিজাইন করা হয়েছে।
 - Use abstract class for shared implementation
      -যদি বিভিন্ন ক্লাসের মধ্যে কিছু কোড শেয়ার করতে চাই এবং একটি "is-a" সম্পর্ক বিদ্যমান থাকে (যেমন SavingsAccount হল একটি Account), তবে অ্যাবস্ট্রাক্ট ক্লাস ব্যবহার করবো।
         ব্যাংকিং উদাহরণ: ধরুন, Account নামে একটি অ্যাবস্ট্রাক্ট ক্লাস আছে।
              বিভিন্ন ধরনের অ্যাকাউন্ট (যেমন SavingsAccount, CurrentAccount) কিছু সাধারণ বৈশিষ্ট্য শেয়ার করে, যেমন অ্যাকাউন্ট নম্বর, ব্যালেন্স এবং কিছু সাধারণ কাজ, যেমন deposit() এবং withdraw()। 
              deposit() এর মতো সাধারণ কাজের একটি ডিফল্ট ইমপ্লিমেন্টেশন Account ক্লাসে থাকতে পারে, যেখানে calculateInterest() এর মতো কাজ প্রতিটি অ্যাকাউন্টের জন্য আলাদাভাবে হিসাব করা হবে, 
              তাই এটি Account ক্লাসে একটি অ্যাবস্ট্রাক্ট মেথড হিসেবে ঘোষণা করা হতে পারে এবং SavingsAccount ক্লাসে এর নিজস্ব ইমপ্লিমেন্টেশন থাকবে।

INTERFACE:
উদ্দেশ্য (Objectives):চুক্তি তৈরি।
-হলো একটি ব্লুপ্রিন্ট বা নকশা যা একটি ক্লাসের আচরণ নির্ধারণ করে।
 - Use interface for common behavior contracts 
      -যদি বিভিন্ন অ্যাসম্পর্কিত ক্লাসের জন্য কিছু নির্দিষ্ট আচরণ বাস্তবায়নের একটি চুক্তি তৈরি করতে চাই  এবং "can-do" বা "has-a ability to" ধরনের সম্পর্ক বোঝাতে চাই , তবে ইন্টারফেস ব্যবহার করবো।
         ব্যাংকিং উদাহরণ:
         Transferable ইন্টারফেসে transfer(Account recipient, double amount) নামে একটি অ্যাবস্ট্রাক্ট মেথড ঘোষণা করা আছে। 
         SavingsAccount এবং CurrentAccount উভয় ক্লাসকেই এই transfer() মেথডের নিজস্ব বাস্তবায়ন প্রদান করতে পারবো।
         অন্যান্য ক্লাস, যেমন LoanAccount, হয়তো অর্থ স্থানান্তরের ক্ষমতা রাখে না, তাই তারা এই ইন্টারফেসটি ইমপ্লিমেন্ট করবে না।


বৈশিষ্ট্য------------|----------	অ্যাবস্ট্রাক্ট ক্লাস	--------------|------------------ ইন্টারফেস------------------------|
-----------------|--------------------------------------|------------------------------------------------------
ইনস্ট্যানসিয়েট করা--| (ইনস্ট্যানসিয়েট)অবজেক্ট তৈরি করা যায় না | 	(ইনস্ট্যানসিয়েট)অবজেক্ট তৈরি করা যায় না
মেথড	-----------|  কনক্রিট/অ্যাবস্ট্রাক্ট দুটোই থাকতে পারে    | সমস্ত মেথড পাবলিক এবং অ্যাবস্ট্রাক্ট (Java 8 এর আগে)
ভেরিয়েবল---------| যেকোনো অ্যাক্সেস মডিফায়ার থাকতে পারে  | 	অন্তর্নিহিতভাবে public static final
ইনহেরিটেন্স--------|	একটিমাত্র ক্লাস থেকে ইনহেরিট করা যায়   | 	একাধিক ইন্টারফেস ইমপ্লিমেন্ট করা যায়
ডিফল্ট মেথড------|	প্রযোজ্য নয়                           | Java 8 থেকে সমর্থিত
স্ট্যাটিক মেথড----- |	সমর্থিত	                            | Java 8 থেকে সমর্থিত
-------------------------------------------------------------------------------------------------------------|



### 4. Method Design
-ওভারলোডিং: একই নাম, ভিন্ন প্যারামিটার
-ওভাররাইডিং: উত্তরাধিকার সূত্রে প্রাপ্ত মেথডের প্রতিস্থাপন
-হাইডিং: একই সিগনেচারের স্ট্যাটিক মেথড
-ইন্টারফেসে ডিফল্ট মেথড (যদি কোনো দ্বন্দ্ব থাকে তবে অবশ্যই ওভাররাইড করতে হবে)

## Exam Preparation Strategy

1. Inheritance Analysis:
   - Trace constructor execution order
   - Identify valid/invalid method overrides
   - Determine access to inherited members

2. Polymorphism Scenarios:
   - Predict method binding at runtime
   - Understand reference vs object types
   - Recognize invalid casting attempts

3. Abstract/Interface Implementation:
   - Spot missing method implementations
   - Resolve default method conflicts
   - Validate interface method modifiers

4. Common Pitfalls:
   - Forgetting super() in constructors
   - Confusing overriding with overloading
   - Mixing static and instance method hiding
   - Ignoring exception rules in overrides

## Key Differences to Remember

1. Overriding vs Hiding:
   - Overriding: Instance methods, runtime polymorphism
   - Hiding: Static methods, compile-time resolution

2. Variable Access:
   - Variables are never overridden (only hidden)
   - Access determined by reference type

3. Constructor Rules:
   - Implicit super() if no constructor defined
   - Must explicitly call super() if parent has no no-arg constructor






========================Chapter_07(Working with Inheritance) =================


1,9,12,14,17,*18,*19,21,*23,26,27,*29,31,*32,*35,37,*40,*44,46,*48=19


1. How many lines of the following program contain compilation errors?
        package theater;
        class Cinema {
        private String name;
        public Cinema(String name) {this.name = name;}
        }
        public class Movie extends Cinema {
        public Movie(String movie) {}
        public static void main(String[] showing) {
        System.out.print(new Movie("Another Trilogy").name);
        }
        }
        A. None
        B. One
        C. Two
        D. Three

2. Which modifier can be applied to an abstract interface method?
        A. protected
        B. static
        C. final
        D. public

3. What is the output of the following application?
        package radio;
        public class Song {
        public void playMusic() {
        System.out.print("Play!");
        }
        private static int playMusic() {
        System.out.print("Music!");
        }
        public static void main(String[] tracks) {
        new Song().playMusic();
        }
        }
        A. Play!
        B. Music!
        C. The code does not compile.
        D. The code compiles but the answer cannot be determined until runtime.
        

4. Which of the following statements about inheritance is true?
        A. Inheritance allows objects to access commonly used attributes and methods.
        B. Inheritance always leads to simpler code.
        C. All primitives and objects inherit a set of methods.
        D. Inheritance allows you to write methods that reference themselves.

5. Given the class declaration below, which value cannot be inserted into the blank line that
        would allow the code to compile?
        package mammal;
        interface Pet {}
        public class Canine implements Pet {
        public getDoggy() {
        return this;
        }
        }
        A. Class
        B. Pet
        C. Canine
        D. Object

6. Imagine you are working with another team to build an application. You are developing
        code that uses a class that the other team has not finished writing yet. Which element of
        Java would best facilitate this development, allowing easy integration once the other team’s
        code is complete?
        A. An abstract class
        B. An interface
        C. static methods
        D. An access modifier

7. What is the output of the following application?
        package vehicles;
        class Automobile {
        private final String drive() { return "Driving vehicle"; }
        }
        class Car extends Automobile {
        protected String drive() { return "Driving car"; }
        }
        public class ElectricCar extends Car {
        public final String drive() { return "Driving electric car"; }
        public static void main(String[] wheels) {
        final Car car = new ElectricCar();
        
        System.out.print(car.drive());
        }
        }
        A. Driving vehicle
        B. Driving electric car
        C. Driving car
        D. The code does not compile.

8. Which of the following statements about inheritance is correct?
        A. Java does not support multiple inheritance.
        B. Java allows multiple inheritance using abstract classes.
        C. Java allows multiple inheritance using non-abstract classes.
        D. Java allows multiple inheritance using interfaces.

9. How many changes need to be made to the classes below to properly override the watch() method?
        package entertainment;
        class Television {
        protected final void watch() {}
        }
        public class LCD extends Television {
        Object watch() {}
        }
        A. One
        B. Two
        C. Three
        D. None; the code compiles as is.

10. Which of the following statements about overriding a method is incorrect?
        A. The return types must be covariant.
        B. The access modifier of the method in the child class must be the same or broader than
        the method in the superclass.
        C. A checked exception thrown by the method in the parent class must be thrown by the
        method in the child class.
        D. A checked exception thrown by a method in the child class must be the same or
        narrower than the exception thrown by the method in the parent class.
        11. What is the output of the following application?
        package machines;
        class Computer {
        protected final int process() { return 5; }
        
        }
        public class Laptop extends Computer {
        public final int process() { return 3; }
        public static void main(String[] chips) {
        System.out.print(new Laptop().process());
        }
        }
        A. 5
        B. 3
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

12. Given that FileNotFoundException is a subclass of IOException, what is the output of the following application?
        package edu;
        import java.io.*;
        class School {
        public int getNumberOfStudentsPerClassroom(String... students) throws IOException {
        return 3;
        }
        public int getNumberOfStudentsPerClassroom() throws IOException {
        return 9;
        }
        }
        public class HighSchool extends School {
        public int getNumberOfStudentsPerClassroom() throws FileNotFoundException {
        return 2;
        }
        public static void main(String[] students) throws IOException {
        School school = new HighSchool();
        System.out.print(school.getNumberOfStudentsPerClassroom());
        }
        }
        A. 2
        B. 3
        C. 9
        D. The code does not compile.
        

13. Which modifier can be applied to an interface method?
        A. protected
        B. static
        C. private
        D. final

14. What is the output of the following application?
        package track;
        interface Run {
        default void walk() {
        System.out.print("Walking and running!");
        }
        }
        interface Jog {
        default void walk() {
        System.out.print("Walking and jogging!");
        }
        }
        public class Sprint implements Run, Jog {
        public void walk() {
        System.out.print("Sprinting!");
        }
        public static void main() {
        new Sprint().walk();
        }
        }
        A. Walking and running!
        B. Walking and jogging!
        C. Sprinting!
        D. The code does not compile.

15. Which of the following statements about interfaces is not true?
        A. An interface can extend another interface.
        B. An interface can implement another interface.
        C. A class can implement two interfaces.
        D. A class can extend another class.
        

16. What is the output of the following application?
        package transport;
        class Ship {
        protected int weight = 3;
        private int height = 5;
        public int getWeight() { return weight; }
        public int getHeight() { return height; }
        }
        public class Rocket extends Ship {
        public int weight = 2;
        public int height = 4;
        public void printDetails() {
        System.out.print(super.getWeight()+","+super.height);
        }
        public static final void main(String[] fuel) {
        new Rocket().printDetails();
        }
        }
        A. 2,5
        B. 3,4
        C. 3,5
        D. The code does not compile.

17. Fill in the blanks: 
    Excluding default and static methods, a(n)_____ can contain both abstract and concrete methods, while a(n)____ contains only abstract methods.
        A. concrete class, abstract class
        B. concrete class, interface
        C. interface, abstract class
        D. abstract class, interface

18. Which statement about the following class is correct?
        package shapes;
        abstract class Triangle {
        abstract String getDescription();
        }        
        class RightTriangle extends Triangle {
        protected String getDescription() { return "rt"; } // g1
        }
        public abstract class IsoscelesRightTriangle extends RightTriangle { // g2
        public String getDescription() { return "irt"; }
        public static void main(String[] edges) {
        final Triangle shape = new IsoscelesRightTriangle(); // g3
        System.out.print(shape.getDescription());
        }
        }
        A. The code does not compile due to line g1.
        B. The code does not compile due to line g2.
        C. The code does not compile due to line g3.
        D. The code compiles and runs without issue.

19. Given that Short and Integer extend Number, what type can be used to fill in the blank in the class below to allow it to compile?
        package band;
        interface Horn { 
          public Integer play(); 
        }
        abstract class Woodwind { 
          public Short play() {return 3;} 
        }
        public final class Saxophone extends Woodwind implements Horn {
          public __ play() {
              return null;
          }
        }
        A. Integer
        B. Short
        C. Number
        D. None of the above

20. Fill in the blanks: A class an interface, while a class an abstract class.
        A. extends, implements
        B. extends, extends
        C. implements, extends
        D. implements, implements
        

21. What is the output of the following application?
        package paper;
        abstract class Book {
        protected static String material = "papyrus";
        public Book() {}
        public Book(String material) {this.material = material;}
        }
        public class Encyclopedia extends Book {
        public static String material = "cellulose";
        public Encyclopedia() {super();}
        public String getMaterial() {return super.material;}
        public static void main(String[] pages) {
        System.out.print(new Encyclopedia().getMaterial());
        }
        }
        A. papyrus
        B. cellulose
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

22. The following diagram shows two reference variables pointing to the same Bunny object
        in memory. The reference variable myBunny is of type Bunny, while unknownBunny is
        of an unknown data type. Which statement about the reference variables is not true?
        For this question, assume the instance methods and variables shown in the diagram are
        marked public.
        carrots
        hasFurryTail()
        eatDinner()
        myBunny 12
        unknownBunny
        Bunny Object in Memory
        A. If the unknownBunny reference does not have access to the same variables and methods
        that myBunny has access to, it can be explicitly cast to a reference type that does.
        B. The data type of unknownBunny must be Bunny or a subclass of Bunny.
        C. If the data type of unknownBunny is Bunny, it has access to all of the same methods and
        variables as myBunny.
        D. The data type of unknownBunny could be an interface, class, or abstract class.
        

23. Which of the following modifiers can be applied to an abstract method?
        A. final
        B. private
        C. default
        D. protected

24. What is the output of the following application?
        package space;
        interface Sphere {
        default String getName() { return "Unknown"; }
        }
        abstract class Planet {
        abstract String getName();
        }
        public class Mars extends Sphere implements Planet {
        public Mars() {
        super();
        }
        public String getName() { return "Mars"; }
        public static void main(final String[] probe) {
        System.out.print(((Planet)new Mars()).getName());
        }
        }
        A. Mars
        B. Unknown
        C. The code does not compile due to the declaration of Sphere.
        D. The code does not compile for another reason.

25. Which of the following statements is correct?
        A. A reference to a class can be assigned to a subclass reference without an explicit cast.
        B. A reference to a class can be assigned to a superclass reference without an explicit cast.
        C. A reference to an interface can be assigned to a reference of a class that implements the
        interface without an explicit cast.
        D. A reference to a class that implements an interface can be assigned to an interface
        reference only with an explicit cast.

26. Of the following four modifiers, choose the one that is not implicitly applied to all interface variables.
        A. final
        B. abstract
        C. static
        D. public
        

27. What is the output of the following application?
        package race;
        abstract class Car {
        static { System.out.print("1"); }
        public Car(String name) {
        super();
        System.out.print("2");
        }
        { System.out.print("3"); }
        }
        public class BlueCar extends Car {
        { System.out.print("4"); }
        public BlueCar() {
        super("blue");
        System.out.print("5");
        }
        public static void main(String[] gears) {
        new BlueCar();
        }
        }
        A. 23451
        B. 12354
        C. 13245
        D. The code does not compile.

28. Fill in the blank: Overloaded and overridden methods always have .
        A. the same parameter list
        B. different return types
        C. the same method name
        D. covariant return types

29. What is the output of the following application?
        package sports;
        abstract class Ball {
                protected final int size;
                public Ball(int size) {
                this.size = size;
                }
        }
        
        interface Equipment {}

        public class SoccerBall extends Ball implements Equipment {
        public SoccerBall() {
        super(5);
        }
        public Ball get() { return this; }
        public static void main(String[] passes) {
        Equipment equipment = (Equipment)(Ball)new SoccerBall().get();
        System.out.print(((SoccerBall)equipment).size);
        }
        }
        A. 5
        B. The code does not compile due an invalid cast.
        C. The code does not compile for a different reason.
        D. The code compiles but throws a ClassCastException at runtime.

30. Fill in the blanks: A class that defines an instance variable with the same name as a variable
        in the parent class is referred to as a variable, while a class that
        defines a static method with the same signature as a static method in a parent class is
        referred to as a method.
        A. hiding, overriding
        B. overriding, hiding
        C. hiding, hiding
        D. replacing, overriding

31. Which statement about the following class is correct?
        package shapes;
        abstract class Parallelogram {
        private int getEqualSides() {return 0;}
        }
        abstract class Rectangle extends Parallelogram {
        public static int getEqualSides() {return 2;} // x1
        }
        public final class Square extends Rectangle {
        public int getEqualSides() {return 4;} // x2
        public static void main(String[] corners) {
        final Square myFigure = new Square(); // x3
        System.out.print(myFigure.getEqualSides());
        }
        }
        
        A. The code does not compile due to line x1.
        B. The code does not compile due to line x2.
        C. The code does not compile due to line x3.
        D. The code compiles and runs without issue.

32. What is the output of the following application?
        package flying;
        class Rotorcraft {
        protected final int height = 5;
        abstract int fly();
        }
        public class Helicopter extends Rotorcraft {
        private int height = 10;
        protected int fly() {
        return super.height;
        }
        public static void main(String[] unused) {
        Helicopter h = (Helicopter)new Rotorcraft();
        System.out.print(h.fly());
        }
        }
        A. 5
        B. 10
        C. The code does not compile.
        D. The code compiles but produces a ClassCastException at runtime.

33. Fill in the blanks: A class may be assigned to a(n) reference variable
        automatically but requires an explicit cast when assigned to a(n)
        reference variable.
        A. subclass, outer class
        B. superclass, subclass
        C. subclass, superclass
        D. abstract class, concrete class

34. Fill in the blank: A(n) is the first non-abstract subclass that is
        required to implement all of the inherited abstract methods.
        A. abstract class
        B. abstraction
        C. concrete class
        D. interface
        
35. How many compiler errors does the following code contain?
        package animal;
        interface CanFly {
        public void fly() {}
        }
        final class Bird {
        public int fly(int speed) {}
        }
        public class Eagle extends Bird implements CanFly {
        public void fly() {}
        }
        A. None
        B. One
        C. Two
        D. Three

36. Which of the following is not an attribute common to both abstract classes and interfaces?
        A. They both can contain static variables.
        B. They both can contain default methods.
        C. They both can contain static methods.
        D. They both can contain abstract methods.

37. What is the output of the following application?
        package musical;
        interface SpeakDialogue { 
                default int talk() { 
                return 7; 
                } 
        }
        interface SingMonologue { 
                default int talk() { 
                return 5; 
                } 
        }
        
        public class Performance implements SpeakDialogue, SingMonologue {
                public int talk(String... x) {
                return x.length;
                }
                public static void main(String[] notes) {
                System.out.print(new Performance().talk(notes));
                }
        }
        A. 7
        B. 5
        C. The code does not compile.
        D. The code compiles without issue, but the output cannot be determined until runtime.
        

38. Which of the following is a virtual method?
        A. protected instance methods
        B. static methods
        C. private instance methods
        D. final instance methods

39. Fill in the blanks: An interface __ another interface, while a class __ another class.
        A. implements, extends
        B. extends, extends
        C. implements, implements
        D. extends, implements

40. What is the output of the following application?
        class Math {
        public final double secret = 2;
        }
        class ComplexMath extends Math {
        public final double secret = 4;
        }

        public class InfiniteMath extends ComplexMath {
        public final double secret = 8;
        public static void main(String[] numbers) {
        Math math = new InfiniteMath();
        System.out.print(math.secret);
        }
        }
        A. 2
        B. 4
        C. 8
        D. The code does not compile.

41. Given the following method and the fact that FileNotFoundException is a subclass of
        IOException, which of the following method signatures is a valid override by a subclass?
        protected void dance() throws FileNotFoundException {}
        A. void dance() throws IOException
        B. public void dance() throws IOException
        C. private void dance() throws FileNotFoundException
        D. public final void dance()
        

42. Given the class definitions below, which value, when inserted into the blank line, does not
        allow the class to compile?
        public class Canine {}
        public class Dog extends Canine {}
        public class Wolf extends Canine {}
        public final class Husky extends Dog {}
        public class Zoologist {
        Canine animal;
        public final void setAnimal(Dog animal) { this.animal = animal; }
        public static void main(String[] furryFriends) {
        new Zoologist().setAnimal( );
        }
        }
        A. new Husky()
        B. new Dog()
        C. new Wolf()
        D. null

43. Which of the following modifiers cannot be applied to an interface method?
        A. final
        B. default
        C. static
        D. abstract

44. Which statement about the following application is true?
        package party;
        abstract class House {
        protected abstract Object getSpace();
        }
        abstract class Room extends House {
        abstract Object getSpace(Object list);
        }
        abstract public class Ballroom extends House {
        protected abstract Object getSpace();
        public static void main(String[] squareFootage) {
        System.out.print("Let's start the party!");
        }
        }
        
        A. It compiles and at runtime prints Let's start the party!
        B. It does not compile for one reason.
        C. It does not compile for two reasons.
        D. It does not compile for three reasons.

45. Fill in the blanks: __ methods must have a different list of parameters, while __ methods must have the exact same return type.
        A. Overloaded, overridden
        B. Inherited, overridden
        C. Overridden, overloaded
        D. None of the above

46. Which of the following statements about no-argument constructors is correct?
        A. If a parent class does not include a no-argument constructor, a child class cannot declare one.
        B. If a parent class does not include a no-argument constructor (nor a default one inserted by the compiler),
           a child class must contain at least one constructor definition.
        C. If a parent class contains a no-argument constructor, a child class must contain a no-argument constructor.
        D. If a parent class contains a no-argument constructor, a child class must contain at least one constructor.

47. Fill in the blanks: __ The determines which attributes exist in  memory, while __ the determines which attributes are accessible by the caller.
        A. reference type, signature
        B. object type, superclass
        C. reference type, object type
        D. object type, reference type

48. Given that Integer and Long are subclasses of Number, what type can be used to fill in  the blank in the class below to allow it to compile?
        package orchestra;
        interface MusicCreator { public Number play(); }
        abstract class StringInstrument { public Long play() {return 3L;} }
        public class Violin extends StringInstrument implements MusicCreator {
        public __ play() {
        return 12;
        }
        }
        A. Long
        B. Integer
        C. Long or Integer
        D. Long or Number

49. Which of the following is the best reason for creating a default interface method?
        A. Allow interface methods to be inherited.
        B. Add backward compatibility to existing interfaces.
        C. Give an interface the ability to create concrete methods.
        D. Allow an interface to define a method at the class level.

50. Given that EOFException is a subclass of IOException, what is the output of the following application?
        package ai;
        import java.io.*;
        class Machine {
        public boolean turnOn() throws EOFException {return true;}
        }
        public class Robot extends Machine {
        public boolean turnOn() throws IOException {return false;}
        public static void main(String[] doesNotCompute) throws Exception {
        Machine m = new Robot();
        System.out.print(m.turnOn());
        }
        }
        A. true
        B. false
        C. The code does not compile.
        D. The code compiles but produces an exception at runtime.

        
=================================================== Answers=============================================================

1. C. The code does not compile, so Option A is incorrect. This code does not compile for two reasons. First, the name variable is marked private in the Cinema class, which means
it cannot be accessed directly in the Movie class. Next, the Movie class defines a constructor that is missing an explicit super() statement. Since Cinema does not include a no-argument
constructor, the no-argument super() cannot be inserted automatically by the compiler without a compilation error. For these two reasons, the code does not compile, and Option
C is the correct answer.
2. D. All abstract interface methods are implicitly public, making Option D the correct answer. Option A is incorrect because protected conflicts with the implicit public modifier. 
Since static methods must have a body and abstract methods cannot have a body, Option B is incorrect. Finally, Option C is incorrect. 
A method, whether it be in an interface or a class, cannot be declared both final and abstract, as doing so would prevent it from ever being implemented.
3. C. A class cannot contain two methods with the same method signature, even if one is static and the other is not. 
Therefore, the code does not compile because the two declarations of playMusic() conflict with one another, making Option C the correct answer.
4. A. Inheritance is often about improving code reusability, by allowing subclasses to inherit commonly used attributes and methods from parent classes, making Option A the correct
answer. Option B is incorrect. Inheritance can lead to either simpler or more complex code, depending on how well it is structured. Option C is also incorrect. While all objects inherit
methods from java.lang.Object, this does not apply to primitives. Finally, Option D is incorrect because methods that reference themselves are not a facet of inheritance.
5. A. Recall that this refers to an instance of the current class. Therefore, any superclass of Canine can be used as a return type of the method, including Canine itself, making Option C
an incorrect answer. Option B is also incorrect because Canine implements the Pet interface. An instance of a class can be assigned to any interface reference that it inherits. Option D is
incorrect because Object is the superclass of instances in Java. Finally, Option A is the correct answer. Canine cannot be returned as an instance of Class because it does not inherit Class.

6. B. The key here is understanding which of these features of Java allow one developer to build their application around another developer’s code, even if that code is not ready yet. For this
problem, an interface is the best choice. If the two teams agree on a common interface, one developer can write code that uses the interface, while another developer writes code that
implements the interface. Assuming neither team changes the interface, the code can be easily integrated once both teams are done. For these reasons, Option B is the correct answer.
7. B. The drive() method in the Car class does not override the version in the Automobile class since the method is not visible to the Car class. Therefore, the final attribute in the
Automobile class does not prevent the Car class from implementing a method with the same signature. The drive() method in the ElectricCar class is a valid override of the
method in the Car class, with the access modifier expanding in the subclass. For these reasons, the code compiles, and Option D is incorrect. In the main() method, the object
created is an ElectricCar, even if it is assigned to a Car reference. Due to polymorphism, the method from the ElectricCar will be invoked, making Option B the correct answer.
8. D. While Java does not allow a class to extend more than one class, it does allow a class to implement any number of interfaces. Multiple inheritance is, therefore, only allowed via
interfaces, making Option D the correct answer.
9. C. There are three problems with this method override. First, the watch() method is marked final in the Television class. The final modifier would have to be removed from the
method definition in the Television class in order for the method to compile in the LCD class. Second, the return types void and Object are not covariant. One of them would have to be
changed for the override to be compatible. Finally, the access modifier in the child class must be the same or broader than in the parent class. Since package-private is narrower than
protected, the code will not compile. For these reasons, Option C is the correct answer.
10. C. First off, the return types of an overridden method must be covariant. Next, it is true that the access modifier must be the same or broader in the child method. Using a narrower access
modifier in the child class would not allow the code to compile. Overridden methods must not throw any new or broader checked exceptions than the method in the superclass. For these
reasons, Options A, B, and D are true statements. Option C is the false statement. An overridden method is not required to throw a checked exception defined in the parent class.


11. C. The process() method is declared final in the Computer class. The Laptop class then attempts to override this method, resulting in a compilation error, making Option C the correct answer.
12. A. The code compiles without issue, so Option D is incorrect. The rule for overriding a method with exceptions is that the subclass cannot throw any new or broader checked
exceptions. Since FileNotFoundException is a subclass of IOException, it is considered a narrower exception, and therefore the overridden method is allowed. 
Due to polymorphism, the overridden version of the method in HighSchool is used, regardless of the reference type, and 2 is printed, making Option A the correct answer. Note that the version of
the method that takes the varargs is not used in this application.
13. B. Interface methods are implicitly public, making Option A and C incorrect. Interface methods can also not be declared final, whether they are static, default, or abstract
methods, making Option D incorrect. Option B is the correct answer because an interface method can be declared static.
14. C. Having one class implement two interfaces that both define the same default method signature leads to a compiler error, unless the class overrides the default method. In this
case, the Sprint class does override the walk() method correctly, therefore the code compiles without issue, and Option C is correct.
15. B. Interfaces can extend other interfaces, making Option A incorrect. On the other hand, an interface cannot implement another interface, making Option B the correct answer. A
class can implement any number of interfaces, making Option C incorrect. Finally, a class can extend another class, making Option D incorrect.

16. D. The code does not compile because super.height is not visible in the Rocket class, making Option D the correct answer. Even though the Rocket class defines a height value,
the super keyword looks for an inherited version. Since there are none, the code does not compile. Note that super.getWeight() returns 3 from the variable in the parent class, as
polymorphism and overriding does not apply to instance variables.
17. D. An abstract class can contain both abstract and concrete methods, while an interface can only contain abstract methods. With Java 8, interfaces can now have static and
default methods, but the question specifically excludes them, making Option D the correct answer. Note that concrete classes cannot contain any abstract methods.
18. C. The code does not compile, so Option D is incorrect. The IsoscelesRightTriangle class is abstract; therefore, it cannot be instantiated on line g3. Only concrete classes can be
instantiated, so the code does not compile, and Option C is the correct answer. The rest of the lines of code compile without issue. A concrete class can extend an abstract class, and an
abstract class can extend a concrete class. Also, note that the override of getDescription() has a widening access modifier, which is fine per the rules of overriding methods.
19. D. The play() method is overridden in Saxophone for both Horn and Woodwind, so the return type must be covariant with both. Unfortunately, the inherited methods must also be
compatible with each other. Since Integer is not a subclass of Short, and vice versa, there is no subclass that can be used to fill in the blank that would allow the code to compile.
In other words, the Saxophone class cannot compile regardless of its implementation of play(), making Option D the correct answer.
20. C. A class can implement an interface, not extend it. Alternatively, a class extends an abstract class. Therefore, Option C is the correct answer.


21. A. The code compiles and runs without issue, making Options C and D incorrect. Although super.material and this.material are poor choices in accessing static variables, they are permitted. 
Since super is used to access the variable in getMaterial(), the value papyrus is returned, making Option A the correct answer. Also, note that the constructor Book(String) is not used in the Encyclopedia class.
22. B. Options A and C are both true statements. Either the unknownBunny reference variable is the same as the object type or it can be explicitly cast to the Bunny object type, therefore
giving it access to all its members. This is the key distinction between reference types and object types. Assigning a new reference does not change the underlying object. Option D
is also a true statement since any superclass that Bunny extends or interface it implements could be used as the data type for unknownBunny. Option B is the false statement and the
correct answer. An object can be assigned to a reference variable type that it inherits, such as Object unknownBunny = new Bunny().
23. D. An abstract method cannot include the final or private method. If a class contained either of these modifiers, then no concrete subclass would ever be able to override them
with an implementation. For these reasons, Options A and B are incorrect. Option C is also incorrect because the default keyword applies to concrete interface methods, not abstract
methods. Finally, Option D is correct. The protected, package-private, and public access modifiers can each be applied to abstract methods.
24. D. The declaration of Sphere compiles without issue, so Option C is incorrect. The Mars class declaration is invalid because Mars cannot extend Sphere, an interface, nor can Mars
implement Planet, a class. In other words, they are reversed. Since the code does not compile, Option D is the correct answer. Note that if Sphere and Planet were swapped in
the Mars class definition, the code would compile and the output would be Mars, making Option A the correct answer.
25. B. A reference to a class can be implicitly assigned to a superclass reference without an explicit class, making Option B the correct answer. Assigning a reference to a subclass,
though, requires an explicit cast, making Option A incorrect. Option C is also incorrect because an interface does not inherit from a class. A reference to an interface requires an
explicit cast to be assigned to a reference of any class, even one that implements the interface. An interface reference requires an explicit cast to be assigned to a class reference.
Finally, Option D is incorrect. An explicit cast is not required to assign a reference to a class that implements an interface to a reference of the interface.

26. B. Interface variables are implicitly public, static, and final. Variables cannot be declared as abstract in interfaces, nor in classes.
27. C. The class is loaded first, with the static initialization block called and 1 is outputted first. When the BlueCar is created in the main() method, the superclass initialization
happens first. The instance initialization blocks are executed before the constructor, so 32 is outputted next. Finally, the class is loaded with the instance initialization blocks again
being called before the constructor, outputting 45. The result is that 13245 is printed, making Option C the correct answer.
28. C. Overloaded methods share the same name but a different list of parameters and an optionally different return type, while overridden methods share the exact same name, list
of parameters, and return type. For both of these, the one commonality is that they share the same method name, making Option C the correct answer.
29. A. Although the casting is a bit much, the object in question is a SoccerBall. Since SoccerBall extends Ball and implements Equipment, it can be explicitly cast to any of
those types, so no compilation error occurs. At runtime, the object is passed around and, due to polymorphism, can be read using any of those references since the underlying object
is a SoccerBall. In other words, casting it to a different reference variable does not modify the object or cause it to lose its underlying SoccerBall information. Therefore, the code
compiles without issue, and Option A is correct.
30. C. Both of these descriptions refer to variable and static method hiding, respectively, making Option C correct. Only instance methods can be overridden, making Options
A and B incorrect. Option D is also incorrect because replacing is not a real term in this context.


31. B. The code does not compile, so Option D is incorrect. The issue here is that the override of getEqualSides() in Square is invalid. A static method cannot override a non-static
method and vice versa. For this reason, Option B is the correct answer.
32. C. The application does not compile, but not for any reason having to do with the cast in the main() method. The Rotorcraft class includes an abstract method, but the class
itself is not marked abstract. Only interfaces and abstract classes can include abstract methods. Since the code does not compile, Option C is the correct answer.
33. B. A class can trivially be assigned to a superclass reference variable but requires an explicit cast to be assigned to a subclass reference variable. For these reasons, Option B is correct.
34. C. A concrete class is the first non-abstract subclass that extends an abstract class and implements any inherited interfaces. 
It is required to implement all inherited abstract methods, making Option C the correct answer.
35. D. First of all, interfaces can only contain abstract, final, and default methods. The method fly() defined in CanFly is not marked static or default and defines an implementation, an empty {}, 
meaning it cannot be assumed to be abstract; therefore, the code does not compile. Next, the implementation of fly(int speed) in the Bird class also does not compile, but not because of the signature. 
The method body fails to return an int value. Since it is an overloaded method, if it returned a value it would compile without issue. 
Finally, the Eagle class does not compile because it extends the Bird class, which is marked final and therefore, cannot be extended. For these three reasons, Option D is the correct answer.

36. B. Abstract classes and interfaces can both contain static and abstract methods as well as static variables, but only an interface can contain default methods. Therefore, Option B is correct.
37. C. Java does not allow multiple inheritance, so having one class extend two interfaces that both define the same default method signature leads to a compiler error, unless the class
overrides the method. In this case, though, the talk(String...) method defined in the Performance class is not an overridden version of method defined in the interfaces because
the signatures do not match. Therefore, the Performance class does not compile since the class inherits two default methods with the same signature and no overridden version,
making Option C the correct answer.
38. A. In Java, only non-static, non-final, and non-private methods are considered virtual and capable of being overridden in a subclass. For this reason, Option A is the correct answer.
39. B. An interface can only extend another interface, while a class can only extend another class. A class can also implement an interface, although that comparison is not part of the
question text. Therefore, Option B is the correct answer.
40. A. The code compiles without issue, so Option D is incorrect. Java allows methods to be overridden, but not variables. Therefore, marking them final does not prevent them from
being reimplemented in a subclass. Furthermore, polymorphism does not apply in the same way it would to methods as it does to variables. In particular, the reference type determines
the version of the secret variable that is selected, making the output 2 and Option A the correct answer.


41. D. Options A and C are incorrect because an overridden method cannot reduce the visibility of the inherited method. Option B is incorrect because an overridden method
cannot declare a broader checked exception than the inherited method. Finally, Option D is the correct answer. The removal of the checked exception, the application of a
broader access modifier, and the addition of the final attribute are allowed for overridden methods.
42. C. The setAnimal() method requires an object that is Dog or a subclass of Dog. Since Husky extends Dog, Options A and B both allow the code to compile. Option D is also valid
because a null value does not have a type and can be assigned to any reference variable. Option C is the only value that prevents the code from compiling because Wolf is not a subclass of Dog. 
Even though Wolf can be assigned to the instance Canine variable, the setter requires a compatible parameter.
43. A. An interface method can be abstract and not have a body, or it can be default or static and have a body. An interface method cannot be final though, making Option A the correct answer.
44. A. It looks like getSpace() in the Room class is an invalid override of the version in the House class since package-private is a more restrictive access modifier than protected,
but the parameter list changes; therefore, this is an overloaded method, not an overridden one. Furthermore, the Ballroom class is abstract so no object is instantiated, but there is
no requirement that an abstract class cannot contain a runnable main() method. For these reasons, the code compiles and runs without issue, making Option A correct.
45. D. Trick question! Option A seems like the correct answer, but the second part of the sentence is false, regardless of whether you insert overloaded or overridden. 
Overridden methods must have covariant return types, which may not be exactly the same as the type in the parent class. Therefore, Option D is the correct answer.

46. B. If a parent class does not include a no-argument constructor, a child class can still explicitly declare one; it just has to call an appropriate parent constructor with super(),
making Option A incorrect. If a parent class does not include a no-argument constructor, the child class must explicitly declare a constructor, since the compiler will not be able to
insert the default no-argument constructor, making Option B correct. Option C is incorrect because a parent class can have a no-argument constructor, while its subclasses do not. If
Option C was true, then all classes would be required to have no-argument constructors since they all extend java.lang.Object, which has a no-argument constructor.
Option D is also incorrect. The default no-argument constructor can be inserted into any class that directly extends a class that has a no-argument constructor. 
Therefore, no constructors in the subclass are required.
47. D. The object type relates to the attributes of the object that exist in memory, while the reference type dictates how the object is able to be used by the caller. For these reasons,Option D is correct.
48. A. The play() method is overridden in Violin for both MusicCreator and StringInstrument, so the return type must be covariant with both. Long is a subclass of
Number, and therefore, it is covariant with the version in MusicCreator. Since it matches the type in StringInstrument, it can be inserted into the blank and the code would compile.
While Integer is a subclass of Number, meaning the override for MusicCreator is valid, it is not a subclass of Long used in StringInstrument. Therefore, using Integer
would cause the code to not compile. Finally, Number is compatible with the version of the method in MusicCreator but not with the version in StringInstrument, because Number
is a superclass of Long, not a subclass. For these reasons, Long is the only class that allows the code to compile, making Option A the correct answer.
49. B. The primary motivation for adding default interface methods to Java was for backward compatibility. These methods allow developers to update older classes with a newer
version of an interface without breaking functionality in the existing classes, making Option B the correct answer. Option is A is nonsensical and not the correct answer.
Options C and D sound plausible, but both could be accomplished with static interface methods alone.
50. C. The rule for overriding a method with exceptions is that the subclass cannot throw any new or broader checked exceptions. Since IOException is a superclass of EOFException,
from the question description, we see that this is a broader exception and therefore not compatible. For this reason, the code does not compile, and Option C is the correct answer.








-
