Very Easy.
Check hot topics bottom of the page.

*** যদি আমি API-এর মৌলিক বিষয়গুলো না জানি, তাহলে আমি কী কী সমস্যার সম্মুখীন হব?


========================== প্রশ্ন ========================================
   - জাভা এপিআই-এর মূল উদ্দেশ্য কী: String, StringBuilder,  ArrayList, List, asList(), toArray(), toString(), Predicate, LocalDate, LocalTime, LocalDateTime, Period, DateTimeFormatter


এপিআই ছাড়া কঠিন হবে-
১.  মাল্টি-থ্রেডিং এবং কনকারেন্সি ম্যানেজমেন্ট: একটি ব্যাংকিং সার্ভার একই সময়ে বহু গ্রাহকের অনুরোধ পরিচালনা করে। java.util.concurrent) এই কাজগুলির জন্য শক্তিশালী সরঞ্জাম সরবরাহ করে। 
২.  ডেটাবেস অ্যাক্সেস: ব্যাংকিং অ্যাপ্লিকেশনগুলির ডেটা ডেটাবেসে সংরক্ষণ করা হয়। JDBC - Java Database Connectivity) জাভা প্রোগ্রামকে বিভিন্ন ডেটাবেসের সাথে সংযোগ স্থাপন এবং ডেটা ম্যানিপুলেট করার জন্য একটি স্ট্যান্ডার্ড ইন্টারফেস সরবরাহ করে। 
৩.  বিভিন্ন ব্যাংকিং পরিষেবা ইন্টিগ্রেট করা:  যেমন অনলাইন ব্যাংকিং, মোবাইল ব্যাংকিং, এটিএম পরিষেবা ইত্যাদি। এপিআই (যেমন নেটওয়ার্কিং এর জন্য java.net বা ডেটা পার্সিং এর জন্য javax.json) 
৪.  নিরাপত্তা প্রোটোকল বাস্তবায়ন: javax.crypto, javax.net.ssl)এই প্রোটোকলগুলির জন্য বিল্ট-ইন সাপোর্ট সরবরাহ করে। 
৫.  লেনদেনের লগিং ও নিরীক্ষণ: java.util.logging) লগিংয়ের জন্য স্ট্যান্ডার্ড সরঞ্জাম সরবরাহ করে। 
৬.  বহিরাগত সিস্টেমের সাথে যোগাযোগ: যেমন পেমেন্ট গেটওয়ে, ক্রেডিট ব্যুরো ইত্যাদি। জাভা এপিআই (যেমন HTTP সংযোগের জন্য java.net) এই প্রক্রিয়াটিকে সহজ করে তোলে। 
৭.  গ্রাহকের তথ্য সংরক্ষণ ও পুনরুদ্ধার:  java.util প্যাকেজের কালেকশন এপিআই (Collections API) এই কাজটিকে অনেক সহজ করে তোলে।


================================================================================================================
  Certainly, এখানে নতুন জাভা প্রশ্নগুলোর উপর ভিত্তি করে সাধারণ ভুলগুলো (pitfalls) সংক্ষেপে এবং সহজে পড়ার মতো করে সাজিয়ে দেওয়া হলো:

---

## জাভার সাধারণ কিছু ভুল (Pitfalls) যা মনে রাখা দরকার (২য় পর্ব)

### ১. `String` বনাম `StringBuilder`/`StringBuffer`
* `String` এর অপরিবর্তনশীলতা (Immutability): `String` অবজেক্টগুলো অপরিবর্তনশীল। `concat()`, `substring()`, `replace()` এর মতো মেথডগুলো মূল `String` অবজেক্টকে পরিবর্তন করে না; বরং পরিবর্তিত মান সহ একটি নতুন `String` অবজেক্ট ফিরিয়ে দেয়। যদি আপনি ফলাফলটি আবার অ্যাসাইন না করেন, তবে মূল স্ট্রিং অপরিবর্তিত থাকে।
    * ভুল: ধারণা করা যে `String` মেথডগুলো স্ট্রিংকে সরাসরি পরিবর্তন করে।
    * নিয়ম: `String` ম্যানিপুলেশন মেথডগুলোর ফলাফল সবসময় আবার অ্যাসাইন করুন (যেমন: `s = s.concat("new_part");`)।
* `StringBuilder` এর পরিবর্তনশীলতা (Mutability): `StringBuilder` অবজেক্টগুলো পরিবর্তনশীল। `append()`, `insert()`, `delete()`, `reverse()` এর মতো মেথডগুলো `StringBuilder` অবজেক্টকে সরাসরি পরিবর্তন করে এবং একই অবজেক্টের একটি রেফারেন্স ফিরিয়ে দেয়।
    * ভুল: মনে করা যে `StringBuilder` প্রতিটি পরিবর্তনের জন্য নতুন অবজেক্ট তৈরি করে।
    * নিয়ম: ঘন ঘন স্ট্রিং পরিবর্তনের জন্য `StringBuilder` ব্যবহার করা কার্যকর, কারণ এটি একই অবজেক্টকে পুনরায় ব্যবহার করে এবং মেমরি বাঁচায়।
* তুলনা (`==` বনাম `equals()`):
    * `==`: অবজেক্ট রেফারেন্স তুলনা করে (তারা মেমরিতে একই অবজেক্টকে নির্দেশ করছে কিনা)।
    * `equals()`: `String` অবজেক্টের বিষয়বস্তু তুলনা করে। `StringBuilder` এর ক্ষেত্রে, `Object` থেকে উত্তরাধিকারসূত্রে প্রাপ্ত `equals()` মেথডটিও রেফারেন্স তুলনা করবে, যদি না এটি বিষয়বস্তুর সমানতার জন্য ওভাররাইড করা হয় (যা `StringBuilder` করে না)।
    * ভুল: `String` বা `StringBuilder` অবজেক্টের বিষয়বস্তু তুলনা করতে `==` ব্যবহার করা।
* `StringBuilder` এর কনস্ট্রাক্টর: বিভিন্ন কনস্ট্রাক্টর (খালি, `String` থেকে) সম্পর্কে সচেতন থাকুন। `append()` এবং `insert()` মেথডগুলো বিষয়বস্তু তৈরি করে।
* `String` পুল: `String` লিটারেলগুলো প্রায়শই JVM দ্বারা অপ্টিমাইজ করা হয় এবং পুনঃব্যবহারের জন্য স্ট্রিং পুলে সংরক্ষণ করা হয়।
* `String` ক্লাসের `final` কিওয়ার্ড: `String` ক্লাস নিজেই `final`, যার অর্থ এটি সাবক্লাস করা যাবে না। এটি এর অপরিবর্তনশীলতায় অবদান রাখে।
* পারফরম্যান্সের জন্য `StringBuilder` বনাম `String`: ডাইনামিক স্ট্রিং তৈরির জন্য `StringBuilder` পছন্দ করা হয়, বিশেষ করে একক-থ্রেডেড পরিবেশে।
* `StringBuilder.toString()`: `StringBuilder` এর বিষয়বস্তুকে একটি `String` অবজেক্টে রূপান্তর করে।
* `String` বনাম `StringBuilder` মেথডের সহজলভ্যতা: `String` এর `startsWith()`, `contains()`, `length()`, `charAt()`, `substring()`, `trim()`, `replace()` মেথড আছে। `StringBuilder` এর `length()`, `charAt()`, `append()`, `insert()`, `delete()`, `deleteCharAt()`, `reverse()` ইত্যাদি আছে। `StringBuilder` এর `startsWith()` বা `contains()` নেই।
* ভুল: একটি `String` এর উপর `reverse()` কল করার চেষ্টা করা (এটির এই মেথড নেই)।
* (প্রশ্ন ১, ২, ৩, ৪, ৭, ৯, ১১, ১৫, ১৮, ২০, ২৪, ২৭, ৩০, ৩৩, ৩৯, ৪১, ৪৩, ৪৬, ৪৯ এর সাথে সম্পর্কিত)

### ২. কালেকশনস (Lists, ArrayList)
* ইন্টারফেস বনাম ইমপ্লিমেন্টেশন: `List` একটি ইন্টারফেস; `ArrayList` হলো `List` ইন্টারফেস ইমপ্লিমেন্টকারী একটি কংক্রিট ক্লাস। আপনি ইন্টারফেস টাইপ দিয়ে ঘোষণা করেন কিন্তু কংক্রিট ক্লাস দিয়ে ইনস্ট্যান্স তৈরি করেন: `List<Type> list = new ArrayList<>();`। আপনি সরাসরি একটি ইন্টারফেস ইনস্ট্যান্স তৈরি করতে পারবেন না (`new List()`)।
* ডায়মন্ড অপারেটর (`<>`): জাভা ৭ এ প্রবর্তিত, এটি `new` এক্সপ্রেশনের ডানদিকে জেনেরিক টাইপ আর্গুমেন্ট বাদ দিতে দেয় যদি এটি বাম দিক থেকে অনুমান করা যায়।
* ইনডেক্সিং (Indexing): `ArrayList` (এবং সাধারণভাবে `List`) `get()`, `remove(index)`, `set()` এর জন্য জিরো-ভিত্তিক ইনডেক্সিং ব্যবহার করে।
* `add()`: তালিকার শেষে একটি উপাদান যোগ করে।
* `remove(index)`: নির্দিষ্ট ইনডেক্সের উপাদানটি সরিয়ে দেয়।
* `remove(Object)`: নির্দিষ্ট অবজেক্টের প্রথম occurrences সরিয়ে দেয়।
* `set(index, element)`: নির্দিষ্ট ইনডেক্সের উপাদানটিকে নতুন উপাদান দিয়ে প্রতিস্থাপন করে।
* `clear()`: তালিকা থেকে সমস্ত উপাদান সরিয়ে দেয়।
* `size()`: তালিকার উপাদানের সংখ্যা ফিরিয়ে দেয়।
* `contains()`: তালিকায় একটি উপাদান উপস্থিত আছে কিনা তা পরীক্ষা করে।
* `Arrays.asList()`: মূল অ্যারে দ্বারা সমর্থিত একটি নির্দিষ্ট আকারের `List` তৈরি করে। তালিকার পরিবর্তন (যেমন `set()`) অ্যারেতে প্রভাব ফেলবে, তবে কাঠামোগত পরিবর্তন (যেমন `add()`, `remove()`) সমর্থিত নয় এবং `UnsupportedOperationException` ছুড়ে দেবে।
* ভুল: `Arrays.asList()` দিয়ে তৈরি একটি তালিকা থেকে উপাদান `add()` বা `remove()` করার চেষ্টা করা।
* `ArrayList` ক্ষমতা (capacity): প্রাথমিক ক্ষমতা (যেমন `new ArrayList<>(1)`) কেবল একটি ইঙ্গিত; এটি আপনি কতগুলি উপাদান যোগ করতে পারবেন তার সীমাবদ্ধতা নয়।
* (`length()` for List): `List` এর `length()` মেথড নেই। এটির `size()` মেথড আছে। `length` অ্যারের জন্য।
* ভুল: `List` এর জন্য `size()` এর পরিবর্তে `length()` ব্যবহার করা।
* (প্রশ্ন ৫, ৬, ৮, ১৪, ২১, ২৩, ২৫, ৪২, ৪৮ এর সাথে সম্পর্কিত)

### ৩. ডেট এবং টাইম API (`java.time`)
* অপরিবর্তনশীলতা (Immutability): `LocalDate`, `LocalTime`, `LocalDateTime`, `Period`, `Duration` এর মতো ক্লাসগুলো অপরিবর্তনশীল। `plusDays()`, `minusYears()`, `setYear()` (যদি এটি বিদ্যমান থাকে) এর মতো মেথডগুলো মূল অবজেক্টকে পরিবর্তন করে না। তারা পরিবর্তিত মান সহ একটি নতুন অবজেক্ট ফিরিয়ে দেয়।
    * ভুল: ডেট/টাইম মেথডগুলো মূল অবজেক্টকে পরিবর্তন করে বলে ধরে নেওয়া।
    * নিয়ম: ফলাফলটি সবসময় আবার অ্যাসাইন করুন (যেমন: `xmas = xmas.plusDays(-1);`)।
* `LocalDate`: একটি তারিখ (বছর, মাস, দিন) প্রতিনিধিত্ব করে। কোনো সময় উপাদান নেই।
* `LocalTime`: একটি সময় (ঘণ্টা, মিনিট, সেকেন্ড, ন্যানোসেকেন্ড) প্রতিনিধিত্ব করে। কোনো তারিখ উপাদান নেই। সর্বনিম্ন একক হলো ন্যানোসেকেন্ড।
* `LocalDateTime`: তারিখ এবং সময় উভয়ই প্রতিনিধিত্ব করে।
* `Period`: বছর, মাস এবং দিনের পরিমাণে সময়কাল প্রতিনিধিত্ব করে। এটি অপরিবর্তনশীল। `ofWeeks()` এবং `ofDays()` কলগুলো চেইন করা হয়, তবে একটি `Period` এ `ofXXX()` মেথডগুলোর পরবর্তী কলগুলো যদি ভিন্ন ইউনিটের হয় তবে পূর্ববর্তী অংশগুলোকে ওভাররাইট করে। উদাহরণস্বরূপ, `Period.ofWeeks(1).ofDays(3)` এর ফলাফল হবে `Period.ofDays(3)`। একত্রিত করতে, আপনাকে `plus()` বা `with...()` (যদি উপলব্ধ থাকে) ব্যবহার করতে হবে, অথবা `Period.ofDays(7).plusDays(3)`।
* `DateTimeFormatter`: `java.time` অবজেক্টগুলোকে স্ট্রিংয়ে ফরম্যাট করতে ব্যবহৃত হয়। প্যাটার্ন অক্ষরগুলির কেস সেন্সিটিভিটির দিকে মনোযোগ দিন (যেমন: মাসের জন্য `MM`, মিনিটের জন্য `mm`)।
* মাস নম্বর (Month numbering): `LocalDate.of(year, month, day)` মাসগুলোর জন্য ১-ভিত্তিক ইনডেক্সিং ব্যবহার করে (জানুয়ারীর জন্য ১, ডিসেম্বরের জন্য ১২)।
* (প্রশ্ন ১৯, ২৯, ৩২, ৩৫, ৩৭, ৩৮, ৪০, ৪৪, ৪৫, ৫০ এর সাথে সম্পর্কিত)

### ৪. ল্যাম্বডা এবং ফাংশনাল ইন্টারফেস (Lambdas and Functional Interfaces)
* ফাংশনাল ইন্টারফেস: একটি ইন্টারফেস যার শুধুমাত্র একটি অ্যাবস্ট্রাক্ট মেথড আছে। `Predicate` একটি ফাংশনাল ইন্টারফেস।
* `Predicate`: একটি একক আর্গুমেন্টের বুলিয়ান-মূল্যের ফাংশন প্রতিনিধিত্ব করে। এর অ্যাবস্ট্রাক্ট মেথড হলো `boolean test(T t)`।
* ল্যাম্বডা সিনট্যাক্স:
    * `parameter -> expression` (একক প্যারামিটার, একক এক্সপ্রেশন, অন্তর্নিহিত রিটার্ন)
    * `(parameter1, parameter2) -> expression` (একাধিক প্যারামিটার)
    * `(parameter) -> { statements; return value; }` (একক প্যারামিটার, স্টেটমেন্টের ব্লক, প্রয়োজনে সুস্পষ্ট রিটার্ন)
    * `(Type parameter) -> expression` (প্যারামিটারের জন্য সুস্পষ্ট টাইপ)
* টাইপ ইনফারেন্স (Type Inference): জাভা প্রায়শই ল্যাম্বডা প্যারামিটারের টাইপ অনুমান করতে পারে যদি ফাংশনাল ইন্টারফেসটি জেনেরিক হয় এবং এর টাইপ জানা থাকে। সুতরাং `s -> false` `Predicate<String>` এর জন্য বৈধ।
* ভুল: ভুল ল্যাম্বডা সিনট্যাক্স (যেমন: প্যারামিটার টাইপ সুস্পষ্ট হলে একক প্যারামিটারের জন্য বন্ধনী বাদ দেওয়া বা বন্ধনী ছাড়া `String s ->` ব্যবহার করা)।
* বিলম্বিত এক্সিকিউশন (Deferred Execution): ল্যাম্বডার একটি মূল সুবিধা হলো আচরণ (কোড) একটি আর্গুমেন্ট হিসেবে পাস করা, যা পরবর্তীতে কার্যকর করার অনুমতি দেয়।
* `startsWith()` মেথড: একটি স্ট্রিং নির্দিষ্ট প্রিফিক্স দিয়ে শুরু হয়েছে কিনা তা পরীক্ষা করে। বিশেষ অক্ষর বা বিভিন্ন ইউনিকোড উপস্থাপনা নিয়ে সতর্ক থাকুন।
* `equals()` বনাম `==` (String এর জন্য): স্ট্রিং বিষয়বস্তু তুলনা করতে `equals()` ব্যবহার করুন।
* প্যারামিটার টাইপ অমিল (Parameter type mismatch): একটি ল্যাম্বডাকে আর্গুমেন্ট হিসেবে পাস করার সময়, ল্যাম্বডার প্যারামিটার টাইপ ফাংশনাল ইন্টারফেসের অ্যাবস্ট্রাক্ট মেথডের প্যারামিটার টাইপের সাথে সামঞ্জস্যপূর্ণ হতে হবে।
* (প্রশ্ন ১০, ১৩, ১৬, ১৭, ২৬, ২৮, ৩১, ৩৪, ৪৭ এর সাথে সম্পর্কিত)

### ৫. স্ট্রিং মেথডের আচরণ (String Method Behaviors)
* `substring(index)`: `index` থেকে শেষ পর্যন্ত একটি নতুন স্ট্রিং ফিরিয়ে দেয়।
* `charAt(index)`: নির্দিষ্ট ইনডেক্সের অক্ষরটি ফিরিয়ে দেয়।
* `trim()`: নতুন একটি স্ট্রিং ফিরিয়ে দেয় যেখানে শুরুর এবং শেষের হোয়াইটস্পেস মুছে ফেলা হয়েছে।
* `replace(char oldChar, char newChar)` বা `replace(CharSequence target, CharSequence replacement)`: সমস্ত `oldChar`/`target` এর occurrences প্রতিস্থাপন করে একটি নতুন স্ট্রিং ফিরিয়ে দেয়। `char` বা `String` (যা একটি `CharSequence`) নিতে পারে।
* `contains()` বনাম `startsWith()` বনাম `equals()`:
    * `s.equals("abc")`: `s` ঠিক "abc" কিনা তা পরীক্ষা করে।
    * `s.startsWith("abc")`: `s` "abc" দিয়ে শুরু হয়েছে কিনা তা পরীক্ষা করে।
    * `s.contains("abc")`: `s` এর মধ্যে "abc" কোথাও আছে কিনা তা পরীক্ষা করে।
    * ভুল: এই মেথডগুলোকে গুলিয়ে ফেলা বা একটি অন্যটিকে বোঝায় বলে ধরে নেওয়া যখন তা হয় না। (যেমন: `startsWith` `contains` বোঝায়, কিন্তু `contains` `startsWith` বা `equals` বোঝায় না)।
* (প্রশ্ন ২২, ৩০, ৩৯, ৪৬ এর সাথে সম্পর্কিত)

---

সাধারণ অধ্যয়নের টিপস:

* অপরিবর্তনশীলতার অনুশীলন: সর্বদা বিবেচনা করুন যে একটি মেথড একটি নতুন অবজেক্ট ফিরিয়ে দেয় নাকি বিদ্যমান অবজেক্টটি পরিবর্তন করে, বিশেষ করে `String` এবং `java.time` ক্লাসগুলির জন্য।
* ডকুমেন্টেশন পড়ুন: অনিশ্চিত হলে, মেথড সিগনেচার এবং আচরণের জন্য অফিসিয়াল জাভা ডকুমেন্টেশন দেখুন।
* কোড ট্রেস করুন: আউটপুট প্রশ্নগুলির জন্য, ম্যানুয়ালি ভেরিয়েবলের মান লাইন বাই লাইন ট্রেস করুন।
* ত্রুটিগুলো বুঝুন: যদি একটি কম্পাইলেশন এরর বা রানটাইম এক্সেপশন ঘটে, তবে এর কারণ বুঝুন (যেমন: স্ট্যাটিক একটি ইনস্ট্যান্স অ্যাক্সেস করার চেষ্টা করছে, ভুল মেথড সিগনেচার, আউট অফ বাউন্ডস, আনসাপোর্টেড অপারেশন)।

---

              

===============================================================================================================  
                        # Chapter Summary: Java Strings, Collections, and Functional Programming 
=============================================================================================================== 

This chapter covers essential Java concepts, including:
1. - String manipulation and immutability
2. - StringBuilder vs String
3. - Java Collections Framework
4. - Lambda expressions and functional interfaces
5. - Java Date/Time API

## Key Concepts to Master

### 1. String Fundamentals
 String Operations:
   - Predict output of string manipulations 
   - Understand immutability consequences
   - Know when to use StringBuilder

- Immutability: Strings cannot be changed after creation
- String Pool: Reuses string literals to save memory
- Key Methods: CL_SISTER_C
  - `length()`, `charAt()`, `substring()`
  - `indexOf()`, `startsWith()`, `endsWith()`
  - `replace()`, `trim()`, `concat()`
   Example:
         String a = "";  a += 2;  a += 'c'; a += false; Result: 2cfalse
         String string = "animals";
         System.out.println(string.substring(3)); // mals
         System.out.println(string.substring(3, 4)); // m

### 2. StringBuilder
- Mutable alternative to String
- Key Methods: -CL_SIR_AID_R
  - `length()`, `charAt()`, `substring()`
  - `indexOf()`, +
  - `append()`, `insert()`, `delete()`
  - `reverse()`, `replace()`
- More efficient for multiple modifications

####String vs StringBuilder:
   - String: Immutable, thread-safe, better for constants
   - StringBuilder: Mutable, better for modifications

### 3. Collections Framework (Like:ArrayList )
Collection Usage:
   - Proper initialization and modification
   - Common method behaviors
   - Capacity vs size differences

- List: Ordered collection (ArrayList, LinkedList)
- Set: Unique elements (HashSet, TreeSet)
- Map: Key-value pairs (HashMap, TreeMap)
- Common Operations: -GRASS_ICC
  - `add()`, `remove()`, `get()`, `contains()`
  - `size()`, set(1, 'c') `isEmpty()`, `clear()`

ArrayList Capacity:
   - Initial capacity is optimization hint
   - Size is actual element count


### 4. Functional Programming
            ## ফাংশনাল ইন্টারফেস কী? (What is a Functional Interface?)
               -জাভাতে ফাংশনাল ইন্টারফেস হলো এমন একটি ইন্টারফেস যাতে শুধুমাত্র একটি অ্যাবস্ট্রাক্ট মেথড (abstract method) থাকে। it must have exactly one abstract method.
               -একমাত্র অ্যাবস্ট্রাক্ট মেথডটি ছাড়াও ডিফল্ট (default) বা স্ট্যাটিক (static) মেথড থাকতে পারে (অসীম সংখ্যক)।
               -`java.lang.Object` ক্লাসের পাবলিক মেথড (যেমন `toString()`, `equals()`) থাকলে তা অ্যাবস্ট্রাক্ট মেথড হিসেবে গণ্য হয় না।           
               -**এটি ল্যামডা এক্সপ্রেশন (Lambda Expression) ব্যবহারের ভিত্তি হিসেবে কাজ করে।
            
            ## ১. ফাংশনাল ইন্টারফেস তৈরি:
                  @FunctionalInterface //অ্যানোটেশন ব্যবহার-ঐচ্ছিক, কিন্তু সুপারিশকৃত
                  interface Calculator {
                      int calculate(int a, int b); // একমাত্র অ্যাবস্ট্রাক্ট মেথড
                       default void defaultMethod() {   System.out.println("এটি ফাংশনাল ইন্টারফেসের একটি ডিফল্ট মেথড।"); }            
                       static void staticMethod() { System.out.println("এটি ফাংশনাল ইন্টারফেসের একটি স্ট্যাটিক মেথড।"); }            
                        @Override
                        String toString(); // এটি Object থেকে উত্তরাধিকারসূত্রে প্রাপ্ত একটি অ্যাবস্ট্রাক্ট মেথড, কিন্তু এটি একক অ্যাবস্ট্রাক্ট মেথডের নিয়মের বিরুদ্ধে যায় না
                  }
            
            ## ২. ল্যামডা এক্সপ্রেশন ব্যবহার করে ইমপ্লিমেন্টেশন:
                  public class Main { //**can be implemented the interface in a class without "implemens" keyword
                      public static void main(String[] args) {
                          *Calculator add = **(x, y) -> x + y;   // যোগ (+)    //* interface as reference type  "add" is ref-type-variable **lambda expression
                          add.defaultMethod();   // ডিফল্ট মেথড কল করে
                          Calculator divide = (x, y) -> y != 0 ? x / y : 0;    // ভাগ (/)            
                          // রেজাল্ট প্রিন্ট
                          System.out.println("10 + 5 = " + add.calculate(10, 5));   // আউটপুট:15// ইমপ্লিমেন্ট করা অ্যাবস্ট্রাক্ট মেথড কল করে
                          System.out.println("10 / 5 = " + divide.calculate(10, 5));   // আউটপুট:2 // ইমপ্লিমেন্ট করা অ্যাবস্ট্রাক্ট মেথড কল করে
                      }
                  } 
            ## ব্যাখ্যা:
                  1. `Calculator` ইন্টারফেসে শুধু `calculate()` মেথডটি অ্যাবস্ট্রাক্ট।
                  2. ল্যামডা এক্সপ্রেশন `(x, y) -> x + y` দ্বারা `calculate()` মেথড ইমপ্লিমেন্ট করা হয়েছে।
                  3. প্রতিটি অপারেশন (+, /) আলাদা ল্যামডা এক্সপ্রেশন দ্বারা সংজ্ঞায়িত।
            
            ## জাভার বিল্ট-ইন ফাংশনাল ইন্টারফেস:
               জাভা ৮-এর `java.util.function` প্যাকেজে পূর্বনির্ধারিত ফাংশনাল ইন্টারফেস আছে:
               - `Function<T,R>`: ইনপুট `T`, আউটপুট `R`
               - `Predicate<T>`: শর্ত চেক করে `boolean` রিটার্ন করে
               - `Consumer<T>`: ইনপুট নেয়, কিছু রিটার্ন করে না
               - `Supplier<T>`: আউটপুট দেয়, ইনপুট নেয় না
            
            ## উদাহরণ: `Predicate`
               import java.util.function.Predicate;            
               public class Main {
                   public static void main(String[] args) {
                       Predicate<Integer> isEven = num -> num % 2 == 0;
                       System.out.println("১০ জোড়? " + isEven.test(10)); // true
                       System.out.println("১৫ জোড়? " + isEven.test(15)); // false
                   }
                }
            
            ## কেন ফাংশনাল ইন্টারফেস গুরুত্বপূর্ণ?
               - ল্যামডা এক্সপ্রেশন ব্যবহার সহজ করে।
               - কোড সংক্ষিপ্ত ও পঠনযোগ্য করে।
               - ফাংশনাল প্রোগ্রামিং স্টাইল (যেমন: স্ট্রীম API) চালু করে।

Lambda Expressions:
   - Valid syntax forms       
   - Method reference conversions
       Remember: Interface with SAM=Single Abstract Method, buit-in test() function, Boolean Return type
- Lambda Expressions: `(parameters) -> expression`
Lambda Syntax:
      List<String> fruits = new ArrayList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        System.out.println("Original List: " + fruits);              
           System.out.println("\n--- Iterating with forEach (Lambda) ---");  // This is a common way to loop through elements without a traditional for-loop.
           fruits.forEach(fruit -> System.out.println("Fruit: " + fruit));   // The lambda `fruit -> System.out.println("Fruit: " + fruit)`
   - Parentheses optional for single parameter
             Predicate<String> pred1= (String s) -> System.out.println(s);    // With parentheses (always works)
             Predicate<String> pred2= String s -> System.out.println(s);      // Without parentheses ( does not works)
             Predicate<String> pred3= s -> System.out.println(s);             // Without parentheses (valid for a single parameter if type is inferred)
             Predicate<String> pred3= (s) -> System.out.println(s);             // With parentheses (valid for a single parameter if type is inferred)
   - Braces and return required for multiple statements 
        BOTH Predicate<Integer> ip = i -> i != 0; 
        IS i -> { return i != 0; } CORRECT
       - Type inference available


### 5. Date/Time API (java.time)

Date/Time Classes:
   - LocalDate: year/month/day
   - LocalTime: hour/minute/second/nano
   - LocalDateTime: combines date and time

Date/Time API:
   - Immutability patterns
   - Period calculations
   - DateTimeFormatter usage

- LocalDate: Date without time - LocalTime: Time without date
- LocalDateTime: Date and time - Period: Date-based amount of time
- Immutable and thread-safe

LocalDateTime বর্তমান_সময় = LocalDateTime.now();
LocalDate আজ = LocalDate.now(); // আজকের তারিখ
LocalDateTime এখন = LocalDateTime.now(); // বর্তমান তারিখ ও সময়
 LocalDate তারিখ১ = LocalDate.of(2024, 1, 1);
 DateTimeFormatter ফরমেটার = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");

Period period = Period.ofDays(1);
DateTimeFormatter format = DateTimeFormatter.ofPattern("MM-dd-yyyy");
System.out.print(format.format(newYears.minus(period)));


*** Period" সরাসরি Java-এর java.time.Period ক্লাসে মিনিটের সাথে কাজ করে না। 
    Period ক্লাসটি বছর, মাস এবং দিনের মতো সময়কাল উপস্থাপন করে। 
    মিনিটের মতো ছোট এককগুলি পরিচালনা করার জন্য java.time.Duration ক্লাসটি ব্যবহার করা হয়।


##### Common Pitfalls:
   - String vs StringBuilder
   - Collection index boundaries -ArrayList() vs array() vs List()
   - CL_SISTER_C, CL_SIR_AID_R, GRASS_ICC
   - Lambda syntax errors -why lambda?
   - subString(4) vs delete(4), subString(4,5) vs delete(4,5)
   - length vs length()
   - parameter as char, String, and StringBuilder()
   - java.util.function -import java.util.function.Predicate; 
   - What is a Functional Interface? How to create, Instantiate, and call it?
   - Function<T,R> Vs Predicate<T> Vs Consumer<T> Vs Supplier<T>
   - Predicate p = test(); p.equal();
   - Predicate<String> pred1= String s -> System.out.println(s);    // Without parentheses like this ( does not works)
   - Predicate<String> pred2= (s) -> System.out.println(s);          // With parentheses (valid for a single parameter)
   - Predicate<String> pred3= s -> { return s != 0; };          // With parentheses (valid for a single parameter)
   - 7th position is l count like array: new StringBuilder("radical ").insert(7, "robots")
   - add robots after radical's free space : new StringBuilder("radical ").insert(sb.length(), "robots")
   - StringBuilder line = new StringBuilder("-");
      StringBuilder anotherLine = line.append("-"); // `StringBuilder`মেথডগুলো একই অবজেক্টের একটি রেফারেন্স ফেরত দেয় যাতে আপনি মেথড কলগুলো চেইন করতে পারেন। 
         System.out.print(line == anotherLine); //`line` এবং `anotherLine` একই অবজেক্টকে নির্দেশ করে।

    - String line = new String("-");
       String anotherLine = line.concat("-");
         System.out.print(line == anotherLine);//  `line` এবং `anotherLine` একই অবজেক্টকে নির্দেশ করে না, নতুন অবজেক্ট তৈরি করে।
    
   - compile can catch this type of error:
            -startWith()function does not work with Arraylist() ex: Predicate dash = c -> c.startsWith("-"); 
            -data type error string vs Integer
               ex:list.add("5");
                    print(list, e -> e < 0);
                    }
                    public static void print(List<String> list, Predicate<Integer> p) {
                    for (String num : list)
                    if (p.test(num))  //comparing two different data(String and Integer) types will throw a compilation error.
                    System.out.println(num);
                    }
   - static void prepare(double angle, Target t) {
           boolean ready = t.needToAim(angle);
           System.out.println(ready);
        }
        public static void main(String[] args) { 
            prepare(45, d -> d > 5 || d < -5); 
        }

   - Date/Time immutability. Period does not support method chaining.
   - .now(); .of(); .ofPattern(); .ofDays(); ofWeeks(); minus(); plus()
   -  StringBuilder sb = new StringBuilder("radical").insert(sb.length(), "robots");
   - StringBuilder b = new StringBuilder("12");
        b = b.append("3");
        b.reverse();
        System.out.println(b.toString()); //what is the result


=====================Chapter 9(Selected Java API) =========================================

2,5,7,9,11,12,13,14,16,17,19,20,26,27,28,30,31,33,34,36,37,38,40,41,43,46,47,48=28


3,5,7,11,12,15,16,*19,21,25,26,27,*28,
33,*34,36,37,40,43,44,47,48, 49,50 = 24.


1. What is the best reason for using StringBuilder instead of String?
        A. StringBuilder adds support for multiple threads.
        B. StringBuilder can use == to compare values. **
        C. StringBuilder saves memory by reducing the number of objects created.
        D. StringBuilder supports different languages and encodings.
        
2. What is not true about a String?
        A. It can be created without coding a call to a constructor.
        B. It can be reused via the string pool. **
        C. It is final.
        D. It is mutable.

3. Which of the following creates a StringBuilder with a different value than the other options?
        A. new StringBuilder().append("clown")
        B. new StringBuilder("clown")
        C. new StringBuilder("cl").insert(2, "own")
        D. All of them create the same value.

4. What is the output of the following?
        StringBuilder teams = new StringBuilder("333");
        teams.append(" 806");
        teams.append(" 1601");
        System.out.print(teams);
        A. 333
        B. 333 806 1601
        C. The code compiles but outputs something else.
        D. The code does not compile.

5. How many of the types ArrayList, List, and Object can fill in the blank to produce code that compiles?
        List frisbees = new __();
        A. None
        B. One
        C. Two
        D. Three
        
6. What is the output of the following?
        List<String> tools = new ArrayList<>();
        tools.add("hammer");
        tools.add("nail");
        tools.add("hex key");
        System.out.println(tools.get(1));
        A. hammer
        B. hex key
        C. nail
        D. None of the above

7. What is the result of the following code?
        StringBuilder sb = new StringBuilder("radical").insert(sb.length(), "robots");
        System.out.println(sb);
        A. radicarobots
        B. radicalrobots
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

8. What is the output of the following?
        List<String> museums = new ArrayList<>(1);
        museums.add("Natural History");
        museums.add("Science");
        museums.add("Art");
        museums.remove(2);
        System.out.println(museums);
        A. [Natural History, Science]
        B. [Natural History, Art, Science]
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

9. What is the output of the following?
        12: StringBuilder b = new StringBuilder("12");
        13: b = b.append("3");
        14: b.reverse();
        15: System.out.println(b.toString());
        A. 12
        B. 123
        C. 321
        D. The code does not compile.

10. What is the main benefit of a lambda expression?
        A. It allows you to convert a primitive to a wrapper class.
        B. It allows you to change the bytecode while the application is running.
        C. It allows you to inherit from multiple classes.
        D. It allows you to write code that has the execution deferred(বিলম্বিত).

11. What is the output of the following?
        5: StringBuilder line = new StringBuilder("-");
        6: StringBuilder anotherLine = line.append("-");
        7: System.out.print(line == anotherLine);
        8: System.out.print(" ");
        9: System.out.print(line.length());
        A. false 1
        B. false 2
        C. true 1
        D. true 2

12. The author of this method forgot to include the data type. Which of the following reference types can fill in the blank to complete this method?
        public static void secret(__ mystery) {
        mystery.add("metal");
        String str = mystery.get(0);
        int num = mystery.length();
        }
        A. ArrayList
        B. ArrayList<String>
        C. StringBuilder
        D. None of the above

13. Which portion of code can be removed so that this line of code continues to compile?
        Predicate<StringBuilder> p = (StringBuilder b) -> {return true;};
        A. Remove StringBuilder b
        B. Remove ->
        C. Remove { and ;}
        D. Remove { return and ;}

14. What is the output of the following?
        20: List<Character> chars = new ArrayList<>();
        21: chars.add('a');
        22: chars.add('b');
        23: chars.set(1, 'c');
        24: chars.remove(0);
        25: System.out.print(chars.size() + " " + chars.contains('b'));
        A. 1 false
        B. 1 true
        C. 2 false
        D. 2 true

15. What is the output of the following?
        12: String b = "12";
        13: b += "3";
        14: b.reverse();
        15: System.out.println(b.toString());
        A. 12
        B. 123
        C. 321
        D. The code does not compile.

16. How many of these lines fail to compile?
        Predicate<String> pred1 = s -> false;
        Predicate<String> pred2 = (s) -> false;
        Predicate<String> pred3 = String s -> false;
        Predicate<String> pred4 = (String s) -> false;
        A. One
        B. Two
        C. Three
        D. Four

17. What does the following do?
        public class Shoot {
        interface Target {
        boolean needToAim(double angle);
        }
        static void prepare(double angle, Target t) {
        boolean ready = t.needToAim(angle); // k1
        System.out.println(ready);
        }
        public static void main(String[] args) {
        prepare(45, d -> d > 5 || d < -5); // k2
        }
        }
        A. It prints true.
        B. It prints false.
        C. It doesn’t compile due to line k1.
        D. It doesn’t compile due to line k2.

18. What is the output of the following?
        String teams = new String("694");
        teams.concat(" 1155");
        teams.concat(" 2265");
        teams.concat(" 2869");
        System.out.println(teams);
        A. 694
        B. 694 1155 2265 2869
        C. The code compiles but outputs something else.
        D. The code does not compile.

19. Which of these classes are in the java.util package?
        I. ArrayList
        II. LocalDate
        III. String
        A. I only
        B. II only
        C. I and II
        D. I, II, and III

20. Which of the answer choices results in a different value being output than the other three choices?
        StringBuilder sb = new StringBuilder("radical ");
        sb = ;
        System.out.print(sb);
        A. new StringBuilder("radical ").append("robots")
        B. new StringBuilder("radical ").delete(1, 100).append("obots").insert(1, "adical r")
        C. new StringBuilder("radical ").insert(7, "robots")
        D. new StringBuilder("radical ").insert(sb.length(), "robots")

21. What is the output of the following?
        String[] array = {"Natural History", "Science"};
        List<String> museums = Arrays.asList(array);
        museums.set(0, "Art");
        System.out.println(museums.contains("Art"));
        A. true
        B. false
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

22. Which is a true statement?
        A. If s.contains("abc") is true, then s.equals("abc") is also true.
        B. If s.contains("abc") is true, then s.startsWith("abc") is also true.
        C. If s.startsWith("abc") is true, then s.equals("abc") is also true.
        D. If s.startsWith("abc") is true, then s.contains("abc") is also true.

23. What is the output of the following?
        20: List<Character> chars = new ArrayList<>();
        21: chars.add('a');
        22: chars.add('b');
        23: chars.set(1, 'c');
        24: chars.remove(0);
        25: System.out.print(chars.length());
        A. 0
        B. 1
        C. 2
        D. None of the above

24. The author of this method forgot to include the data type. Which of the following reference types can fill in the blank to complete this method?
        public static void secret(__ mystery) {
        mystery = mystery.replace("1", "8");
        mystery.startsWith("paper");
        String s = mystery.toString();
        }
        A. ArrayList
        B. String
        C. StringBuilder
        D. None of the above

25. Which statement is true about the following figure while ensuring the code continues to compile?
        List P  balloons = new ArrayList Q ();
        A. <> can be inserted at position P without making any other changes.
        B. <> can be inserted at position Q without making any other changes.
        C. <> can be inserted at both positions P and Q.
        D. None of the above

26. Which of the following can fill in the blank to make the code compile?
        import java.util.function.*;
        public class Card {
        public static void main(String[] s) {
        Predicate<String> pred = __ -> true;
        }
        }
        A. (Integer i)
        B. (Object o)
        C. (String s)
        D. None of the above

27. What is the output of the following?
        5: String line = new String("-");
        6: String anotherLine = line.concat("-");
        7: System.out.print(line == anotherLine);
        8: System.out.print(" ");
        9: System.out.print(line.length());
        A. false 1
        B. false 2
        C. true 1
        D. true 2

28. What does the following output?
        Predicate dash = c -> c.startsWith("-");
        System.out.println(dash.test("–"));
        A. true
        B. false
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

29. Of the classes LocalDate, LocalDateTime, LocalTime, and LocalTimeStamp, how many include hours, minutes, and seconds?
        A. One
        B. Two
        C. Three
        D. Four

30. What is the output of the following class?
        1: package rocket;
        2: public class Countdown {
        3: public static void main(String[] args) {
        4: String builder = "54321";
        5: builder = builder.substring(4);
        6: System.out.println(builder.charAt(2));
        7: }
        8: }
        A. 2
        B. 3
        C. 4
        D. None of the above

31. Which equivalent code can replace i -> i != 0 in the following line?
        Predicate<Integer> ip = i -> i != 0;
        A. i -> { i != 0 }
        B. i -> { i != 0; }
        C. i -> { return i != 0 }
        D. i -> { return i != 0; }

32. What is the output of the following?
        LocalDate xmas = LocalDate.of(2016, 12, 25);
        xmas.plusDays(-1);
        System.out.println(xmas.getDayOfMonth());
        A. 24
        B. 25
        C. 26
        D. None of the above

33. What is the output of the following?
        1: public class Legos {
        2: public static void main(String[] args) {
        3: StringBuilder sb = new StringBuilder();
        4: sb.append("red");
        5: sb.deleteCharAt(0);
        6: sb.delete(1, 2);
        7: System.out.println(sb);
        8: }
        9: }
        A. e
        B. d
        C. ed
        D. None of the above

34. What does the following output?
        Predicate clear = c -> c.equals("clear");
        System.out.println(clear.test("pink"));
        A. true
        B. false
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

35. Which starts counting from one rather than zero?
        A. Array indexes
        B. The index used by charAt in a String
        C. The months in a LocalDateTime
        D. The months in a LocalTime

36. Which statement is not true of Predicate?
        A. A boolean is returned from the method it declares.
        B. It is an interface.
        C. The method it declares accepts two parameters.
        D. The method it declares is named test.

37. Which of these periods represents a larger amount of time?
        Period period1 = Period.ofWeeks(1).ofDays(3);
        Period period2 = Period.ofDays(10);
        A. period1
        B. period2
        C. They represent the same length of time.
        D. None of the above. This code does not compile.

38. What is the result of the following?
        import java.time.*;
        import java.time.format.*;
        public class HowLong {
        public static void main(String[] args) {
        LocalDate newYears = LocalDate.of(2017, 1, 1);
        Period period = Period.ofDays(1);
        DateTimeFormatter format = DateTimeFormatter.ofPattern("MM-dd-yyyy");
        System.out.print(format.format(newYears.minus(period)));
        }
        }
        A. 01-01-2017
        B. 12-31-2016
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

39. Which of the following can fill in the blank so the following code prints true?
        String happy = " :) - (: ";
        String really = happy.trim();
        String question = __ ;
        System.out.println(really.equals(question));
        A. happy.substring(0, happy.length() - 1)
        B. happy.substring(0, happy.length())
        C. happy.substring(1, happy.length() - 1)
        D. happy.substring(1, happy.length())

40. Which is not a true statement about the Period class?
        A. A Period is immutable.
        B. A Period is typically used for adding or subtracting time from dates.
        C. You can create a Period representing 2 minutes.
        D. You can create a Period representing 5 years.

41. What is the output of the following class?
        1: package rocket;
        2: public class Countdown {
        3: public static void main(String[] args) {
        4: StringBuilder builder = new StringBuilder("54321");
        5: builder.substring(2);
        6: System.out.println(builder.charAt(1));
        7: }
        8: }
        A. 1
        B. 2
        C. 3
        D. 4

42. What does the following output?
        List<Integer> pennies = new ArrayList<>();
        pennies.add(3);
        pennies.add(2);
        pennies.add(1);
        pennies.remove(2);
        System.out.println(pennies);
        A. [3, 1]
        B. [3, 2]
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

43. The author of this method forgot to include the data type. Which of the following reference types can best fill in the blank to complete this method?
        public static void secret(__ mystery) {
        char ch = mystery.charAt(3);
        mystery = mystery.insert(1, "more");
        int num = mystery.length();
        }
        A. ArrayList
        B. String
        C. StringBuilder
        D. None of the above

44. What is the smallest unit you can add to a LocalTime object?
        A. Second
        B. Millisecond
        C. Nanosecond
        D. Picosecond

45. What is the result of the following?
        import java.time.*;
        import java.time.format.*;
        public class HowLong {
        public static void main(String[] args) {
        LocalDate newYears = LocalDate.of(2017, 1, 1);
        Period period = Period.ofDays(1);
        DateTimeFormatter format = DateTimeFormatter.ofPattern("mm-dd-yyyy");
        System.out.print(format.format(newYears.minus(period)));
        }
        }
        A. 01-01-2017
        B. 12-31-2016
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

46. Which of the following types can you pass as a parameter to the replace() method on the String class?
        I. char
        II. String
        III. StringBuilder
        A. I
        B. I and II
        C. II and III
        D. I, II, and III

47. How many lines does this code output?
        import java.util.*;
        import java.util.function.*;
        public class PrintNegative {
        public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("-5");
        list.add("0");
        list.add("5");
        print(list, e -> e < 0);
        }
        public static void print(List<String> list, Predicate<Integer> p) {
        for (String num : list)
        if (p.test(num))
        System.out.println(num);
        }
        }
        A. One
        B. Two
        C. None. The code does not compile.
        D. None. The code throws an exception at runtime.

48. What is the output of the following?
        12: List<String> magazines = new ArrayList();
        13: magazines.add("Readers Digest");
        14: magazines.add("People");
        15: magazines.clear();
        16: magazines.add("The Economist");
        17: magazines.remove(1);
        18: System.out.println(magazines.size());
        A. 0
        B. 1
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

49. What is the output of the following?
        public class Costume {
        public static void main(String[] black) {
        String witch = 'b';
        String tail = "lack";
        witch = witch.concat(tail);
        System.out.println(witch);
        }
        }
        A. b
        B. black
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

50. What is the result of the following?
        LocalDate xmas = LocalDate.of(2016, 12, 25);
        xmas.setYear(2017);
        System.out.println(xmas.getYear());
        A. 2016
        B. 2017
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.
        


================================ Answers =============================
2-D,5-B,7-C,9-C,11-D,12-D,13-D,14-A,16-A,17-A,19-A,20-C,
26-D,27-A,28-C,30-D,31-D,33-A,34-B,36-C,37-B,38-B,40-C,
41-D,43-C,46-D,47-C,48-D



1. C, 2.D, 3.D, 4.B, 5.B,      6.C, 7.C, 8.A, 9.C, 10.D,
11.D, 12.D, 13.D, 14.A, 15.D,  16.A, 17.A, 18.A, 19.A, 20.C,
21.A, 22.D, 23.D, 24.B, 25.B,  26.D, 27.A, 28.C, 29.B, 30.D,
31.D, 32.B, 33.A, 34.B, 5.C,   36.C, 37.B, 38.B, 39.C, 40.C,
41.D, 42.B, 43.C, 44.C, 45.D,  46.D, 47.C, 48.D, 49.C, 50.C

১. গ. বিকল্প ক ভুল কারণ `StringBuilder` একাধিক থ্রেড সমর্থন করে না। আসলে, থ্রেডগুলো OCA-তে অন্তর্ভুক্তও নয়, যা আপনার জন্য একটি সূত্র হওয়া উচিত যে এই উত্তরটি ভুল! পরীক্ষার জন্য আপনার এটি জানার দরকার নেই, তবে `StringBuffer` একাধিক থ্রেড সমর্থন করে। বিকল্প খ ভুল কারণ `==` রেফারেন্স তুলনা করে, মান নয়। বিকল্প ঘ ভুল কারণ `String` এবং `StringBuilder` উভয়ই ভাষা এবং এনকোডিং সমর্থন করে। বিকল্প গ সঠিক এবং `StringBuilder` ব্যবহারের প্রধান কারণ। `String` প্রায়শই কিছু নির্দিষ্ট মেথড যেমন `concat()` কল করার সময় একটি নতুন অবজেক্ট তৈরি করে। `StringBuilder` `append()` এর মতো অপারেশনগুলোকে অপ্টিমাইজ করে কারণ এটি পরিবর্তনযোগ্য।
২. ঘ. একটি `String` সরাসরি কনস্ট্রাক্টর কল না করে একটি লিটারাল ব্যবহার করে তৈরি করা যেতে পারে, যা বিকল্প ক-কে ভুল করে। `String` পুনঃব্যবহারের জন্য একটি স্ট্রিং পুল বিদ্যমান, যা বিকল্প খ-কে ভুল করে। একটি `String` `final` এবং `immutable`, যা বিকল্প গ-কে ভুল এবং বিকল্প ঘ-কে সঠিক করে।
৩. ঘ. এই প্রশ্নটি পরীক্ষা করছে যে আপনি মেথড চেইনিং কীভাবে কাজ করে তা বোঝেন কিনা। বিকল্প ক একটি খালি `StringBuilder` তৈরি করে এবং তারপর `clown`-এর পাঁচটি অক্ষর এতে যোগ করে। বিকল্প খ কেবল কনস্ট্রাক্টর কল করার সময় `clown` তৈরি করে। অবশেষে, বিকল্প গ একই মান তৈরি করে, কেবল দুটি অংশে। অতএব, বিকল্প ঘ সঠিক।
৪. খ. যেহেতু `StringBuilder` পরিবর্তনযোগ্য, `append()` এর প্রতিটি কল মানটিতে যোগ করে। `print()` কল করার সময়, `toString()` স্বয়ংক্রিয়ভাবে কল হয় এবং 333 806 1601 আউটপুট হয়। অতএব, বিকল্প খ সঠিক।

৫. খ. `List` একটি ইন্টারফেস, ক্লাস নয়। এটি ইনস্ট্যানশিয়েট করা যায় না। যদিও `Object` একটি কংক্রিট ক্লাস, এটি `List` ইন্টারফেস প্রয়োগ করে না তাই এটি `frisbees`-এ অ্যাসাইন করা যায় না। 
       উল্লেখ্য যে, আপনি যদি একটি সুস্পষ্ট কাস্ট যোগ করেন, তবে এটি কম্পাইল হবে এবং রানটাইমে একটি ব্যতিক্রম ছুঁড়ে দেবে। তিনটি বিকল্পের মধ্যে, কেবল `ArrayList`-ই ফাঁকা স্থান পূরণ করতে পারে, তাই বিকল্প খ সঠিক।
৬. গ. একটি `ArrayList` স্বয়ংক্রিয়ভাবে উপাদানগুলোকে সাজায় না। এটি কেবল সেগুলোকে ক্রমানুসারে মনে রাখে। যেহেতু জাভা শূন্য-ভিত্তিক সূচক ব্যবহার করে, বিকল্প গ সঠিক।
৭. গ. কনস্ট্রাক্টর কল করা এবং তারপর `insert()` মেথড চেইনিং-এর একটি উদাহরণ। তবে, `sb.length()` কলটি একটি সমস্যা।
       `sb` রেফারেন্সটি চেইন্ড কলগুলো সম্পূর্ণ না হওয়া পর্যন্ত বিদ্যমান থাকে না। 
       এটি একটি আলাদা লাইনে আছে বলেই রেফারেন্সটি কখন তৈরি হয় তা পরিবর্তন হয় না। যেহেতু কোডটি কম্পাইল করে না, বিকল্প গ সঠিক।
৮. ক. যদিও `ArrayList` একটি উপাদানের প্রাথমিক ক্ষমতা দিয়ে ঘোষণা করা হয়, তবে আরও উপাদান যোগ করার সাথে সাথে এটি প্রসারিত হতে পারে। `add()` মেথডের তিনটি কলই `ArrayList`-এর শেষে একটি উপাদান যোগ করে। `remove()` মেথড কলটি সূচক ২-এর উপাদানটিকে মুছে দেয়, যা Art। অতএব, বিকল্প ক সঠিক।
৯. গ. লাইন ১২-তে, `StringBuilder`-এর মান ১২। লাইন ১৩-তে, এটি ১২৩ হয়। 
       যেহেতু `StringBuilder` পরিবর্তনযোগ্য, একই রেফারেন্সে ফলাফল সংরক্ষণ করা "অপ্রয়োজনীয়"। 
       তারপর লাইন ১৪-তে, মানটি উল্টানো হয়, যা আমাদের ৩২১ দেয় এবং বিকল্প গ-কে সঠিক করে।
১০. ঘ. বিকল্প ক ভুল কারণ এটি অটোবক্সিং বর্ণনা করে। বিকল্প খ এবং গ জাভাতে সম্ভব নয়। বিকল্প ঘ সঠিক কারণ এটি ল্যাম্বডা বর্ণনা করে। ল্যাম্বডাগুলো স্থগিত এক্সিকিউশন ব্যবহার করে এবং কোডবেসের অন্য কোথাও চালানো যেতে পারে।

১১. ঘ. একটি `StringBuilder` পরিবর্তনযোগ্য, তাই লাইন ৬ সম্পূর্ণ হওয়ার পরে দৈর্ঘ্য দুই হয়। `StringBuilder` মেথডগুলো একই অবজেক্টের একটি রেফারেন্স ফেরত দেয় যাতে আপনি মেথড কলগুলো চেইন করতে পারেন। 
     অতএব, `line` এবং `anotherLine` একই অবজেক্টকে নির্দেশ করে। এর মানে হল লাইন ৭ `true` প্রিন্ট করে। 
      তারপর লাইন ৯-তে, উভয় রেফারেন্স দৈর্ঘ্য ২-এর একই অবজেক্টকে নির্দেশ করে এবং বিকল্প ঘ সঠিক।
১২. ঘ. `add()` এবং `get()` মেথডগুলো `ArrayList`-এ উপলব্ধ। তবে, `ArrayList` উপাদানগুলোর সংখ্যা পেতে `length` এর পরিবর্তে `size` ব্যবহার করে। অতএব, বিকল্প ঘ সঠিক। যদি `length`-কে `size`-এ পরিবর্তন করা হতো, তাহলে ফাঁকা স্থানে রাখলে বিকল্প খ কম্পাইল হতো। বিকল্প ক ফাঁকা স্থানে এখনও কম্পাইল হতো না কারণ মানটিকে `str`-এ সংরক্ষণ করার জন্য একটি কাস্ট প্রয়োজন হতো।
১৩. ঘ. বিকল্প ক চতুর, কিন্তু ভুল। যদিও একটি ল্যাম্বডার শূন্য প্যারামিটার থাকতে পারে, একটি `Predicate`-এর থাকতে পারে না। 
       একটি `Predicate`-কে একটি `boolean`-এ ম্যাপ করা একটি টাইপ হিসাবে সংজ্ঞায়িত করা হয়। বিকল্প খ স্পষ্টতই ভুল কারণ `->` একটি ল্যাম্বডার অংশগুলোকে আলাদা করে। বিকল্প গ এবং ঘ একই রকম।
       বিকল্প গ ভুল কারণ `return` কেবল তখন অনুমতিপ্রাপ্ত যখন বন্ধনীগুলো উপস্থিত থাকে। বিকল্প ঘ সঠিক।
১৪. ক. লাইন ২০-২২ দুটি উপাদান সহ একটি `ArrayList` তৈরি করে। লাইন ২৩ দ্বিতীয়টিকে একটি নতুন মান দিয়ে প্রতিস্থাপন করে। এখন `chars` হল `[a, c]`। 
       তারপর লাইন ২৪ প্রথম উপাদানটিকে সরিয়ে দেয়, যা কেবল `[c]` তৈরি করে।  বিকল্প ক সঠিক কারণ কেবল একটি উপাদান আছে, তবে এটি `b` মান নয়।

১৫. ঘ. ধূর্ত প্রশ্ন। `String` ক্লাসে কোনো `reverse` মেথড নেই। `StringBuilder` ক্লাসে একটি আছে। অতএব, কোডটি কম্পাইল করে না এবং বিকল্প ঘ সঠিক।
১৬. ক. কেবলমাত্র একটি প্যারামিটার দিয়ে একটি ল্যাম্বডা তৈরি করার সময়, কয়েকটি ভিন্নতা রয়েছে। 
        `pred1` পদ্ধতিটি সবচেয়ে সংক্ষিপ্ত উপায় দেখায়, যেখানে টাইপ বাদ দেওয়া হয় এবং বন্ধনী বাদ দেওয়া হয়।
        `pred2` পদ্ধতিটি অনুরূপ, তবে এতে বন্ধনী অন্তর্ভুক্ত থাকে।  উভয়ই বৈধ।
        `pred4` পদ্ধতিটি বন্ধনী এবং টাইপ উভয়ই নির্দিষ্ট করে দীর্ঘ উপায়। 
        যে একটি কম্পাইল করে না তা হল `pred3`। টাইপ অন্তর্ভুক্ত করা হলে বন্ধনীগুলো আবশ্যক।
১৭. ক. এটি একটি ল্যাম্বডা ব্যবহার করে কোডের একটি সঠিক উদাহরণ। ইন্টারফেসটিতে একটি একক অ্যাবস্ট্রাক্ট মেথড রয়েছে। ল্যাম্বডাটি সঠিকভাবে একটি `double` প্যারামিটার গ্রহণ করে এবং একটি `boolean` ফেরত দেয়। 
       এটি ইন্টারফেসের সাথে মিলে যায়। ল্যাম্বডা সিনট্যাক্স সঠিক। যেহেতু ৪৫ ৫ এর চেয়ে বড়, বিকল্প ক সঠিক।
১৮. ক. যেহেতু `String` অপরিবর্তনীয়, `concat()` এর প্রতিটি কল একটি নতুন অবজেক্টকে নতুন মান দিয়ে ফেরত দেয়। তবে, সেই ফেরত মানটি উপেক্ষা করা হয় এবং `teams` ভেরিয়েবলের মান কখনও পরিবর্তিত হয় না। অতএব এটি ৬৯৪ থাকে এবং বিকল্প ক সঠিক।
১৯. ক. `ArrayList` ক্লাসটি `java.util` প্যাকেজে রয়েছে, যা I-কে সঠিক করে। `LocalDate` ক্লাসটি `java.time` প্যাকেজে রয়েছে, যা II-কে ভুল করে। `String` ক্লাসটি `java.lang` প্যাকেজে রয়েছে, যার অর্থ আপনি কোনো `import` টাইপ না করেই এটি ব্যবহার করতে পারেন, যা III-কে ভুল করে। অতএব, বিকল্প ক সঠিক।
২০. গ. বিকল্প ক সহজ এবং `radical robots` আউটপুট দেয়। বিকল্প খ একটি জটিল পদ্ধতিতে একই কাজ করে। প্রথমে বিকল্প খ প্রথম অক্ষরের পরে সমস্ত অক্ষর মুছে ফেলে। আসলে ১০০ অক্ষর মুছে ফেলার মতো নেই তা কোনো ব্যাপার না। 
        তারপর এটি `obots` যোগ করে শেষে, যা বিল্ডারটিকে `robots` ধারণ করে। অবশেষে, এটি স্ট্রিংয়ের অবশিষ্ট অংশটি প্রথম সূচকের ঠিক পরে সন্নিবেশ করায়। এটি কল্পনা করা কঠিন হলে প্রবাহটি আঁকার চেষ্টা করুন। 
        বিকল্প ঘ `StringBuilder`-এর শেষের ঠিক পরে `robots` সন্নিবেশ করে একই মান তৈরি করে। বিকল্প গ কাছাকাছি, তবে এতে একটি অফ-বাই-ওয়ান ত্রুটি রয়েছে। এটি স্পেসের পরে না হয়ে `l` অক্ষরের পরে `robots` সন্নিবেশ করায়। এর ফলে `radicalrobots` এর পরে একটি স্পেস থাকে। বিকল্প গ অন্যদের থেকে ভিন্ন এবং সঠিক উত্তর।

২১. ক. যেহেতু আমরা একটি অ্যারে থেকে তালিকা তৈরি করছি, এটি একটি নির্দিষ্ট আকারের। আমরা উপাদান পরিবর্তন করার অনুমতিপ্রাপ্ত। এই কোডের শেষে, `museums` হল `[Art, Science]`। অতএব, এটি Art ধারণ করে এবং বিকল্প ক সঠিক।
২২. ঘ. যদি `String` "deabc" হয় তবে বিকল্প ক এবং খ সত্য নয়। যদি `String` "abcde" হয় তবে বিকল্প গ সত্য নয়। বিকল্প ঘ সকল ক্ষেত্রে সত্য।
২৩. ঘ. লাইন ২৫ কম্পাইল করে না। একটি `ArrayList`-এ, উপাদানগুলোর সংখ্যা পেতে `size` মেথড ব্যবহার করা হয়। `length()` মেথড একটি `String` বা `StringBuilder`-এর জন্য ব্যবহৃত হয়।
২৪. খ. `toString()` মেথড কলটি জিনিসগুলোকে সংকুচিত করতে সাহায্য করে না কারণ সমস্ত জাভা অবজেক্টে সেই মেথড উপলব্ধ। অন্য দুটি মেথড বেশি সহায়ক। `String` এই তিনটির মধ্যে একমাত্র টাইপ যার `startsWith()` মেথড রয়েছে, যা বিকল্প খ-কে সঠিক করে। `String`-এর এখানে ঘোষিত `replace()` মেথডটিও রয়েছে। আপনি যদি পুরো API মুখস্ত করে থাকেন, তাহলে আপনি হয়তো জানবেন যে `StringBuilder`-এরও একটি `replace()` মেথড আছে, তবে এতে দুটি প্যারামিটারের পরিবর্তে তিনটি প্যারামিটার প্রয়োজন। অনুগ্রহ করে সেই স্তরের বিস্তারিতভাবে API মুখস্ত করবেন না। আমরা আমাদের অধ্যয়ন নির্দেশিকাতে আপনার যা জানা দরকার তা অন্তর্ভুক্ত করেছি। আপনার যদি এই বাইরের জ্ঞান থাকে, তবে প্রশ্নগুলোতে অতিরিক্ত পড়ার বিষয়ে সতর্ক থাকুন!
২৫. খ. `<>` কে ডায়মন্ড অপারেটর বলা হয়। এখানে, এটি একই ঘোষণার জন্য জেনেরিক টাইপ দুবার পুনরাবৃত্তি এড়াতে একটি শর্টকাট হিসাবে কাজ করে। এক্সপ্রেশনের ডানদিকে, এটি একটি সুবিধাজনক শর্টকাট। জাভার এখনও বাম দিকে টাইপ প্রয়োজন যাতে কিছু অনুমান করার থাকে। চিত্রে, P অবস্থানটি বাম দিক এবং Q অবস্থানটি ডান দিক। অতএব, বিকল্প খ সঠিক।

২৬. ঘ. ল্যাম্বডার টাইপ `Predicate`-এ ঘোষিত জেনেরিকের সাথে মিলতে হবে। এই ক্ষেত্রে, এটি `String`। অতএব, বিকল্প ক এবং খ ভুল। যদিও বিকল্প গ সঠিক টাইপের, এটি `s` ভেরিয়েবলটি ব্যবহার করে, যা `main()` মেথড প্যারামিটার থেকে ইতিমধ্যেই ব্যবহৃত হচ্ছে। অতএব, এর কোনটিই সঠিক নয় এবং বিকল্প ঘ হল উত্তর।
২৭. ক. লাইন ৫: String line = new String("-");
        একটি নতুন String অবজেক্ট তৈরি করা হয় যার মান "-"। এই অবজেক্টটি মেমরি হিপে (heap) তৈরি হবে। line ভেরিয়েবলটি এই অবজেক্টকে রেফারেন্স করবে।
        লাইন ৬: String anotherLine = line.concat("-");  line স্ট্রিং-এর উপর concat() মেথড কল করা হয়েছে। concat() মেথড একটি নতুন String অবজেক্ট তৈরি করে যেখানে দুটি স্ট্রিং যোগ করা হয়।
        যেহেতু line এবং anotherLine দুটি ভিন্ন মেমরি লোকেশনে দুটি ভিন্ন String অবজেক্টকে রেফার করছে, তাই এই তুলনা false হবে।
২৮. গ. যদিও একটি `Predicate`-এর একটি জেনেরিক টাইপ থাকা সাধারণ, তবে এটি প্রয়োজন হয় না। যখন জেনেরিকটি বাদ দেওয়া হয়, তখন এটিকে `Object` টাইপের একটি `Predicate` হিসাবে বিবেচনা করা হয়। যেহেতু `startsWith()` `Object`-এ বিদ্যমান নেই, প্রথম লাইনটি কম্পাইল করে না এবং বিকল্প গ সঠিক।
২৯. খ. `LocalDate` কেবল তারিখ অংশ অন্তর্ভুক্ত করে, সময় অংশ নয়। `LocalTimeStamp` নামে কোনো ক্লাস নেই। অন্য দুটি, `LocalDateTime` এবং `LocalTime`, উভয়ই সময় উপাদান অন্তর্ভুক্ত করে, যা বিকল্প খ-কে সঠিক করে।
৩০. ঘ. লাইন ৪ দৈর্ঘ্য ৫-এর একটি `String` তৈরি করে। যেহেতু `String` অপরিবর্তনীয়, লাইন ৫ মান ১ সহ একটি নতুন `String` তৈরি করে এবং এটি `builder`-এ অ্যাসাইন করে। মনে রাখবেন যে জাভাতে সূচকগুলো ০ থেকে শুরু হয়, তাই `substring()` মেথডটি পঞ্চম উপাদান থেকে শেষ পর্যন্ত মানগুলো নিচ্ছে। যেহেতু প্রথম উপাদানটি শেষ উপাদান, সেখানে কেবল একটি অক্ষর রয়েছে। তারপর লাইন ৬ দ্বিতীয় সূচকযুক্ত উপাদানটি পুনরুদ্ধার করার চেষ্টা করে। যেহেতু কেবল একটি উপাদান রয়েছে, এটি একটি `StringIndexOutOfBoundsException` দেয় এবং বিকল্প ঘ সঠিক।

৩১. ঘ. আপনি যখন বন্ধনী ব্যবহার করেন, তখন ল্যাম্বডা কম্পাইল হওয়ার জন্য `return` কীওয়ার্ড এবং সেমিকোলন উভয়ই প্রয়োজন, যা বিকল্প ঘ-কে সঠিক করে।
৩২. খ. জাভা ৮ তারিখ এবং সময় ক্লাসগুলো অপরিবর্তনীয়। `plusDays` মেথডটি ক্রিসমাস ইভ (২৪শে ডিসেম্বর) উপস্থাপনকারী একটি `LocalDate` অবজেক্ট ফেরত দেয়। তবে, এই ফেরত মানটি উপেক্ষা করা হয়। `xmas` ভেরিয়েবলটি এখনও আসল মানটি উপস্থাপন করে, তাই বিকল্প খ সঠিক।
৩৩. ক. লাইন ৩ একটি খালি `StringBuilder` তৈরি করে। লাইন ৪ এতে তিনটি অক্ষর যোগ করে। লাইন ৫ প্রথম অক্ষরটি মুছে ফেলে, যার ফলে `ed` হয়। লাইন ৬ পজিশন ১ থেকে শুরু করে পজিশন ২ এর ঠিক আগে অক্ষরগুলো মুছে ফেলে, যা সূচক ১-এর অক্ষরটি মুছে দেয়, যা `d`। একমাত্র অক্ষর বাকি থাকে `e`, তাই বিকল্প ক সঠিক।
৩৪. খ. যদিও একটি `Predicate`-এর একটি জেনেরিক টাইপ থাকা সাধারণ, তবে এটি প্রয়োজন হয় না। যখন জেনেরিকটি বাদ দেওয়া হয়, তখন এটিকে `Object` টাইপের একটি `Predicate` হিসাবে বিবেচনা করা হয়। যেহেতু `equals()` মেথডটি `Object`-এ বিদ্যমান, এটি ঠিক আছে। বিকল্প খ সঠিক কারণ `Predicate` `false` হিসাবে পরীক্ষা করে।

৩৫. গ. জাভাতে, বেশিরভাগ জিনিস শূন্য-ভিত্তিক সূচক ব্যবহার করে, যার মধ্যে অ্যারে এবং একটি `String` অন্তর্ভুক্ত। জাভা ৮ থেকে মাসগুলো এই প্রথার ব্যতিক্রম। এটি উত্তরকে বিকল্প গ বা ঘ করে তোলে। তবে, `LocalTime`-এ তারিখ ক্ষেত্র থাকে না, তাই এটি অবশ্যই বিকল্প গ হতে হবে।
৩৬. গ. `Predicate` একটি ইন্টারফেস যার একটি মেথড আছে। মেথডের স্বাক্ষর হল `boolean test(T t)`। বিকল্প গ হল উত্তর কারণ মেথডটি দুটি প্যারামিটারের পরিবর্তে একটি প্যারামিটার গ্রহণ করে।
৩৭. খ. এখানে সতর্ক থাকুন। `Period` ক্লাসটি `period` ফেরত দিতে একটি স্ট্যাটিক হেল্পার মেথড ব্যবহার করে। এটি মেথড কলগুলো চেইন করে না, তাই `period1` কেবল তিন দিন উপস্থাপন করে। যেহেতু তিন দিন ১০ দিনের চেয়ে কম, `period2` বড় এবং বিকল্প খ সঠিক।
৩৮. খ. কোডটি ১লা জানুয়ারি ২০১৭ তারিখ এবং এক দিনের একটি সময়কাল সঠিকভাবে তৈরি করে শুরু হয়। তারপর এটি স্পষ্টভাবে মাস, তারপর দিন, তারপর বছর হিসাবে বিন্যাস সংজ্ঞায়িত করে। অবশেষে, কোডটি এক দিন বিয়োগ করে, যা আমাদের ৩১শে ডিসেম্বর ২০১৬-এর বিন্যাসিত সংস্করণ দেয়।
৩৯. গ. `trim()` মেথডটি সমস্ত অগ্রণী এবং অনুসারী সাদা স্থান সরানো সহ একটি `String` ফেরত দেয়। এই প্রশ্নে, এটি সাত-অক্ষরের `String`: ":) - (:"। বিকল্প ক এবং খ ভুল কারণ তারা `happy`-তে প্রথম ফাঁকা স্থানটি সরায় না। বিকল্প ঘ ভুল কারণ এটি `happy`-তে শেষ অক্ষরটি সরায় না। অতএব, বিকল্প গ সঠিক।
৪০. গ. `Period` ক্লাসটি অপরিবর্তনীয় অবজেক্ট তৈরি করে এবং সাধারণত `LocalDate` বা `LocalDateTime` অবজেক্ট থেকে যোগ/বিয়োগ করতে ব্যবহৃত হয়। এটি দিন, সপ্তাহ, মাস বা বছরের সময়কাল তৈরি করতে দেয়। যেহেতু এটি সময়ের জন্য ব্যবহার করা যায় না, বিকল্প গ হল উত্তর।

৪১. ঘ. লাইন ৪ দৈর্ঘ্য ৫-এর একটি `StringBuilder` তৈরি করে। `substring()` মেথড `StringBuilder`-এর দিকে মনোযোগ দিন। এটি `321` মান সহ একটি `String` ফেরত দেয়। এটি `StringBuilder` নিজেই পরিবর্তন করে না। তারপর লাইন ৬ সেই অপরিবর্তিত মান থেকে দ্বিতীয় সূচকযুক্ত উপাদানটি পুনরুদ্ধার করছে, যা `4`। অতএব, বিকল্প ঘ সঠিক।
৪২. খ. এটি চতুর। `ArrayList`-এ দুটি `remove()` মেথড উপলব্ধ। একটি সূচক দ্বারা একটি উপাদান সরায় এবং একটি `int` প্যারামিটার নেয়। অন্যটি মান দ্বারা একটি উপাদান সরায়। জেনেরিকগুলোর কারণে, এই উদাহরণে এটি একটি `Integer` প্যারামিটার নেয়। যেহেতু `int` প্রিমিটিভটি একটি ভাল মিল, সূচক ২-এর উপাদানটি সরানো হয়, যা ১-এর মান। অতএব, বিকল্প খ সঠিক।
৪৩. গ. `ArrayList`-এর একটি `size()` মেথড আছে `length()` মেথড না হয়ে, যা বিকল্প ক-কে ভুল করে। `charAt()` এবং `length()` মেথডগুলো `String` এবং `StringBuilder` উভয় ক্ষেত্রেই ঘোষিত। তবে, `insert()` মেথডটি কেবল একটি `StringBuilder`-এ ঘোষিত এবং একটি `String`-এ নয়। অতএব, বিকল্প গ সঠিক।
৪৪. গ. `minusNanos` এবং `plusNanos` হল উপলব্ধ ক্ষুদ্রতম একক, যা বিকল্প গ-কে সঠিক করে। বিকল্প ঘ ভুল কারণ `LocalTime` এত সূক্ষ্ম নয়। উল্লেখ্য যে আপনি অনেক ন্যানোসেকেন্ড যোগ করে মিলিসেকেন্ড যোগ করতে পারলেও, এর জন্য কোনো মেথড নেই। একটি মিলিসেকেন্ডও একটি ন্যানোসেকেন্ডের চেয়ে বড়। অবশেষে, `LocalTime` অপরিবর্তনীয় এই তথ্য দ্বারা বিভ্রান্ত হবেন না। আপনি এখনও সময় যোগ করতে পারেন; এটি কেবল একটি ভিন্ন অবজেক্ট হিসাবে ফেরত আসে।

৪৫. ঘ. একটি ফরম্যাটার অবজেক্ট তৈরি করার সময়, মনে রাখবেন যে `MM` মাসকে বোঝায় যখন `mm` মিনিটকে বোঝায়। যেহেতু একটি `LocalDate` অবজেক্টে কোনো মিনিট সংজ্ঞায়িত করা হয় না, কোডটি একটি `UnsupportedTemporalTypeException` ছুঁড়ে দেয়। আপনার ব্যতিক্রমের নামটি জানার প্রয়োজন নেই, তবে একটি ব্যতিক্রম ছুঁড়ে দেওয়া হয় তা আপনার জানা দরকার।
৪৬. ঘ. `replace()` মেথডের দুটি স্বাক্ষর রয়েছে। একটি দুটি `char` প্যারামিটার নেয়। অন্য স্বাক্ষরটি একটি `CharSequence` নেয়। `String` এবং `StringBuilder` উভয়ই এই ইন্টারফেসটি প্রয়োগ করে। এটি তিনটি বিকল্পকে সঠিক করে এবং বিকল্প ঘ সঠিক।
৪৭. গ. ডেটা টাইপগুলোতে মনোযোগ দিন। `print()` মেথডটি `String` অবজেক্টের একটি তালিকা ধরে লুপ করছে। তবে, `Predicate` একটি `Integer` আশা করে। যেহেতু এগুলো মেলে না, `if` স্টেটমেন্টটি কম্পাইল করে না।
৪৮. ঘ. লাইন ১২ একটি খালি `ArrayList` তৈরি করে। যদিও অ্যাসাইনমেন্ট অপারেটরের কেবল বাম দিকে জেনেরিক ব্যবহার করার সুপারিশ করা হয় না, তবে এটি অনুমোদিত। এটি কেবল একটি সতর্কতা দেয়। লাইন ১৩ এবং ১৪ দুটি উপাদান যোগ করে। লাইন ১৫ একটি খালি `ArrayList`-এ রিসেট করে। লাইন ১৬ একটি উপাদান যোগ করে, তাই এখন আমাদের দৈর্ঘ্য ১-এর একটি `ArrayList` আছে। লাইন ১৭ সূচক ১-এর উপাদানটি সরানোর চেষ্টা করে। যেহেতু জাভা শূন্য-ভিত্তিক সূচক ব্যবহার করে, সেখানে কোনো উপাদান নেই এবং কোডটি একটি `IndexOutOfBoundsException` ছুঁড়ে দেয়।
৪৯. গ. `witch`-এর ঘোষণা ভুল। এটি একটি `char`-কে একটি `String` ভেরিয়েবল রেফারেন্সে সংরক্ষণ করার চেষ্টা করে। এটি কম্পাইল করে না, যা বিকল্প গ-কে সঠিক করে। যদি এটি ঠিক করা হতো, তবে উত্তরটি বিকল্প খ হতো।
৫০. গ. জাভা ৮ তারিখ এবং সময় ক্লাসগুলো অপরিবর্তনীয়। এর অর্থ হল সেগুলোতে সেটার মেথড থাকে না এবং কোডটি কম্পাইল করে না।"













1. C. Option A is incorrect because StringBuilder does not support multiple threads. In fact, threads aren’t even covered on the OCA, which should be your clue that this answer
is wrong! You don’t need to know this for the exam, but StringBuffer supports multiple threads. Option B is incorrect because == compares references, not values. Option D is
incorrect because both String and StringBuilder support languages and encodings. Option C is correct and the primary reason to use StringBuilder. String often creates a
new object each time you call certain methods on the object like concat(). StringBuilder optimizes operations like append() because it is mutable.
2. D. A String can be created using a literal rather than calling a constructor directly, making Option A incorrect. A string pool exists for String reuse, making Option B incorrect.
A String is final and immutable, making Option C incorrect and Option D correct.
3. D. This question is testing whether you understand how method chaining works. Option A creates an empty StringBuilder and then adds the five characters in clown to it. Option B
simply creates the clown when calling the constructor. Finally, Option C creates the same value, just in two parts. Therefore, Option D is correct.
4. B. Since StringBuilder is mutable, each call to append adds to the value. When calling print, toString() is automatically called and 333 806 1601 is output. 
Therefore, Option B is correct.

5. B. List is an interface and not a class. It cannot be instantiated. While Object is a concrete class, it does not implement the List interface so it cannot be assigned to frisbees.
Note that if you were to add an explicit cast, it would compile and throw an exception at runtime. Of the three options, only ArrayList can fill in the blank, so Option B is correct.
6. C. An ArrayList does not automatically sort the elements. It simply remembers them in order. Since Java uses zero-based indexes, Option C is correct.
7. C. Calling the constructor and then insert() is an example of method chaining. However, the sb.length() call is a problem. The sb reference doesn’t exist until after the chained
calls complete. Just because it happens to be on a separate line doesn’t change when the reference is created. Since the code does not compile, Option C is correct.
8. A. While the ArrayList is declared with an initial capacity of one element, it is free to expand as more elements are added. Each of the three calls to the add() method adds an
element to the end of the ArrayList. The remove() method call deletes the element at index 2, which is Art. Therefore, Option A is correct.
9. C. On line 12, the value of the StringBuilder is 12. On line 13, it becomes 123. Since StringBuilder is mutable, storing the result in the same reference is redundant. Then on
line 14, the value is reversed, giving us 321 and making Option C correct.
10. D. Option A is incorrect as it describes autoboxing. Options B and C are not possible in Java. Option D is correct as it describes lambdas. Lambdas use deferred execution and can
be run elsewhere in the codebase.

11. D. A StringBuilder is mutable, so the length is two after line 6 completes. The StringBuilder methods return a reference to the same object so you can chain method
calls. Therefore, line and anotherLine refer to the same object. This means that line 7 prints true. Then on line 9, both references point to the same object of length 2, and Option D is correct.
12. D. The add() and get() methods are available on ArrayList. However, ArrayList uses size rather than length to get the number of elements. Therefore, Option D is
correct. If length was changed to size, Option B would compile if put in the blank. Option A still wouldn’t compile in the blank because a cast would be needed to store the value in str.
13. D. Option A is tricky, but incorrect. While a lambda can have zero parameters, a Predicate cannot. A Predicate is defined as a type mapping to a boolean. Option B is
clearly incorrect as -> separates the parts of a lambda. Options C and D are similar. Option C is incorrect because return is only allowed when the brackets are present. Option D is
correct.
14. A. Lines 20–22 create an ArrayList with two elements. Line 23 replaces the second one with a new value. Now chars is [a, c]. Then line 24 removes the first element, making it
just [c]. Option A is correct because there is only one element, but it is not the value b.

15. D. Trick question. There is no reverse method on the String class. There is one on the StringBuilder class. Therefore, the code does not compile, and Option D is correct.
16. A. When creating a lambda with only one parameter, there are a few variants. The pred1
approach shows the shortest way, where the type is omitted and the parentheses are omitted. The pred2 approach is similar except it includes the parentheses. Both are legal. The
pred4 approach is the long way with both the parentheses and type specified. The only one that doesn’t compile is pred3. The parentheses are required if including the type.
17. A. This is a correct example of code that uses a lambda. The interface has a single abstract method. The lambda correctly takes one double parameter and returns a boolean. This
matches the interface. The lambda syntax is correct. Since 45 is greater than 5, Option A is correct.
18. A. Since String is immutable, each call to concat() returns a new object with the new value. However, that return value is ignored and the teams variable never changes in value.
Therefore it stays as 694, and Option A is correct.
19. A. The ArrayList class is in the java.util package, making I correct. The LocalDate class is in the java.time package, making II incorrect. The String class is in the
java.lang package, which means you can use it without typing an import, making III incorrect. Therefore, Option A is correct.
20. C. Option A is straightforward and outputs radical robots. Option B does the same in a convoluted manner. First Option B removes all the characters after the first one. It
doesn’t matter that there aren’t actually 100 characters to delete. Then it appends obots to the end, making the builder contain robots. Finally, it inserts the remainder of the
string immediately after the first index. Try drawing the flow if this is hard to envision. Option D also creates the same value by inserting robots immediately after the end of
the StringBuilder. Option C is close, but it has an off-by-one error. It inserts robots after the letter l rather than after the space. This results in the value radicalrobots
followed by a space. Option C is different than the others and the correct answer.

21. A. Since we are creating the list from an array, it is a fixed size. We are allowed to change elements. At the end of this code, museums is [Art, Science]. Therefore, it contains Art,
and Option A is correct.
22. D. Options A and B are not true if the String is "deabc". Option C is not true if the String is "abcde". Option D is true in all cases.
23. D. Line 25 does not compile. On an ArrayList, the method to get the number of elements is size. The length() method is used for a String or StringBuilder.
24. B. The toString() method call doesn’t help in narrowing things down as all Java objects have that method available. The other two methods are more helpful. String is the only
type of these three to have a startsWith() method, making Option B correct. String also has the replace() method declared here. If you memorized the whole API, you might
know that StringBuilder also has a replace() method, but it requires three parameters instead of two. Please don’t memorize the API in that level of detail. We included what you
need to know in our study guide. If you do have this outside knowledge, be careful not to read into the questions!
25. B. The <> is known as the diamond operator. Here, it works as a shortcut to avoid repeating the generic type twice for the same declaration. On the right side of the expression, this
is a handy shortcut. Java still needs the type on the left side so there is something to infer. In the figure, position P is the left side and position Q is the right side. 
Therefore, Option B is correct.

26. D. The type in the lambda must match the generic declared on the Predicate. In this case, that is String. Therefore, Options A and B are incorrect. While Option C is of the correct
type, it uses the variable s, which is already in use from the main() method parameter. Therefore, none of these are correct, and Option D is the answer.
27. A. A String is immutable so a different object is returned on line 6. The object anotherLine points to is of length 2 after line 6 completes. However, the original line
reference still points to an object of length 1. Therefore, Option A is correct.
28. C. While it is common for a Predicate to have a generic type, it is not required. However, it is treated like a Predicate of type Object if the generic type is missing. Since
startsWith() does not exist on Object, the first line does not compile, and Option C is correct.
29. B. LocalDate only includes the date portion and not the time portion. There is no class named LocalTimeStamp. The other two, LocalDateTime and LocalTime, both include the
time elements, making Option B correct.
30. D. Line 4 creates a String of length 5. Since String is immutable, line 5 creates a new String with the value 1 and assigns it to builder. Remember that indexes in Java begin
with 0, so the substring() method is taking the values from the fifth element through the end. Since the first element is the last element, there’s only one character in there. Then line
6 tries to retrieve the second indexed element. Since there is only one element, this gives a StringIndexOutOfBoundsException, and Option D is correct.

31. D. When you’re using brackets, both the return keyword and semicolon are needed for the lambda to compile, making Option D correct.
32. B. Java 8 date and time classes are immutable. The plusDays method returns a LocalDate object presenting Christmas Eve (December 24th). However, this return value is ignored.
The xmas variable still represents the original value, so Option B is correct.
33. A. Line 3 creates an empty StringBuilder. Line 4 adds three characters to it. Line 5 removes the first character, resulting in ed. Line 6 deletes the characters starting at position
1 and ending right before position 2, which removes the character at index 1, which is d. The only character left is e, so Option A is correct.
34. B. While it is common for a Predicate to have a generic type, it is not required. When the generic is omitted, it is treated like a Predicate of type Object. Since the equals()
method exists on Object, this is fine. Option B is correct because the Predicate tests as false.

35. C. In Java, most things use zero-based indexes, including arrays and a String. Months are an exception to this convention starting Java 8. This makes the answer either Option C or
D. However, LocalTime does not contain date fields, so it has to be Option C.
36. C. Predicate is an interface with one method. The method signature is boolean test(T t). Option C is the answer because the method accepts one parameter rather than two.
37. B. Be careful here. The Period class uses a static helper method to return the period. It does not chain method calls, so period1 only represents three days. Since three days is less
than 10 days, period2 is larger, and Option B is correct.
38. B. The code starts by correctly creating a date representing January 1, 2017, and a period representing one day. It then explicitly defines the format as month followed by day
followed by year. Finally, the code subtracts a day, giving us the formatted version of December 31, 2016.
39. C. The trim() method returns a String with all leading and trailing white space removed. In this question, that’s the seven-character String: ":) - (:". Options A and B are
incorrect because they do not remove the first blank space in happy. Option D is incorrect because it does not remove the last character in happy. Therefore, Option C is correct.
40. C. The Period class creates immutable objects and is usually used to add/subtract from a LocalDate or LocalDateTime object. It allows creating date, week, month, or year periods.
Since it cannot be used for time, Option C is the answer.

41. D. Line 4 creates a StringBuilder of length 5. Pay attention to the substring() method StringBuilder. It returns a String with the value 321. It does not change the
StringBuilder itself. Then line 6 is retrieving the second indexed element from that unchanged value, which is 4. Therefore, Option D is correct.
42. B. This one is tricky. There are two remove() methods available on ArrayList. One removes an element by index and takes an int parameter. The other removes an element
by value. Due to the generics, it takes an Integer parameter in this example. Since the int primitive is a better match, the element with index 2 is removed, which is the value of 1.
Therefore, Option B is correct.
43. C. ArrayList has a size() method rather than a length() method, making Option A incorrect. The charAt() and length() methods are declared on both String and
StringBuilder. However, the insert() method is only declared on a StringBuilder and not a String. Therefore, Option C is correct.
44. C. The minusNanos and plusNanos are the smallest units available, making Option C correct. Option D is incorrect because LocalTime is not that granular. Note that while you can
add milliseconds by adding many nanoseconds, there isn’t a method for it. A millisecond is also larger than a nanosecond. Finally, don’t be tricked by the fact that LocalTime is immutable.
You can still add time; it just gets returned as a different object.

45. D. When creating a formatter object, remember that MM represents month while mm represents minute. Since there are not minutes defined on a LocalDate object, the code throws
an UnsupportedTemporalTypeException. You don’t need to know the name of the exception, but you do need to know that an exception is thrown.
46. D. There are two signatures for the replace() method. One takes two char parameters. The other signature takes a CharSequence. Both String and StringBuilder implement
this interface. This makes all three alternatives correct, and Option D is correct.
47. C. Pay attention to the data types. The print() method is looping through a list of String objects. However, the Predicate expects an Integer. Since these don’t match, the if
statement does not compile.
48. D. Line 12 creates an empty ArrayList. While it isn’t recommended to use generics on only the left side of the assignment operator, this is allowed. It just gives a warning. Lines
13 and 14 add two elements. Line 15 resets to an empty ArrayList. Line 16 adds an element, so now we have an ArrayList of size 1. Line 17 attempts to remove the element
at index 1. Since Java uses zero-based indexes, there isn’t an element there and the code throws an IndexOutOfBoundsException.
49. C. The declaration of witch is incorrect. It tries to store a char into a String variable reference. This does not compile, making Option C correct. If this was fixed, the answer
would be Option B.
50. C. The Java 8 date and time classes are immutable. This means they do not contain setter methods and the code does not compile.



---------------- HOT TOPICS -----------------------------

========================== Creating a String ==========================


String s1 = "Computer-";  String s2 = "Science-";   String s3 = s1.concat(s2);
String s4 = "Portal";     String s5 = s3.concat(s4);
System.out.println(s5); Result: Computer-Science-Portal
        

FUNCTIONS:
         01. length() 02. charAt() 03. indexOf() 
         04. substring() 
                  
         05. replace() Ex:String result = lowercase.replace('a', 'A');
         06. contains()
         07. equals() and equalsIgnoreCase()
                  Ex:
                  System.out.println("abc".equals("ABC")); // false
                  System.out.println("ABC".equals("ABC")); // true
                  System.out.println("abc".equalsIgnoreCase("ABC")); // true
         08. startsWith() and endsWith()
         09. toLowerCase() and toUpperCase 
         10. trim()


========================== Creating a StringBuilder ==========================
Functions:
         01. length() 02. charAt() 03. indexOf() 04. substring() 
         05. append() 06. insert() (Ex: sb.insert(7, "-");)
         07. delete() and deleteCharAt() Ex: sb.delete(1, 3); sb.deleteCharAt(5); // throws an exception
         08. reverse() 09. toString()=to get a string representation of an object.


There are three ways to construct a StringBuilder:
         StringBuilder sb1 = new StringBuilder();
         StringBuilder sb2 = new StringBuilder("animal");
         StringBuilder sb3 = new StringBuilder(10);

4: StringBuilder a = new StringBuilder("abc");
5: StringBuilder b = a.append("de");
6: b = b.append("f").append("g");
7: System.out.println("a=" + a);
8: System.out.println("b=" + b);

againStrings[0] = new StringBuilder(); // DOES NOT COMPILE
objects[0] = new StringBuilder(); // careful!

========================== Array =================================
-Fixed-size -Can not Add/Insert, Edit, and Delete once declared/initialized.

FUNCTIONS:--
       01. length 02. Arrays.sort() 03. Arrays.binarySearch()

String[] birds = new String[6];
System.out.println(birds.length);

int[] numbers = {2,4,6,8};
System.out.println(Arrays.binarySearch(numbers, 2)); // 0

String[] numbers = { "10", "9", "100" };
Arrays.sort(numbers);
Arrays.binarySearch(numbers, 2)












-
