Very Easy.
Check hot topics bottom of the page.

*** যদি আমি API-এর মৌলিক বিষয়গুলো না জানি, তাহলে আমি কী কী সমস্যার সম্মুখীন হব?


==========================  কিছু প্রশ্ন, যা আপনাকে গভীরভাবে চিন্তা করতে সাহায্য করবে: ========================================

১.  জাভা এপিআই ছাড়া প্রোগ্রামিং করলে কী অসুবিধা হবে?
2.  জাভা এপিআই-এর মূল উদ্দেশ্য কী: String, StringBuilder(),  ArrayList(), List, asList(), toArray(), Predicate<String>, LocalDate, LocalDateTime, Period, DateTimeFormatter


এপিআই ছাড়া কঠিন হবে-
১.  মাল্টি-থ্রেডিং এবং কনকারেন্সি ম্যানেজমেন্ট: একটি ব্যাংকিং সার্ভার একই সময়ে বহু গ্রাহকের অনুরোধ পরিচালনা করে। java.util.concurrent) এই কাজগুলির জন্য শক্তিশালী সরঞ্জাম সরবরাহ করে। 
২.  ডেটাবেস অ্যাক্সেস: ব্যাংকিং অ্যাপ্লিকেশনগুলির ডেটা ডেটাবেসে সংরক্ষণ করা হয়। JDBC - Java Database Connectivity) জাভা প্রোগ্রামকে বিভিন্ন ডেটাবেসের সাথে সংযোগ স্থাপন এবং ডেটা ম্যানিপুলেট করার জন্য একটি স্ট্যান্ডার্ড ইন্টারফেস সরবরাহ করে। 
৩.  বিভিন্ন ব্যাংকিং পরিষেবা ইন্টিগ্রেট করা:  যেমন অনলাইন ব্যাংকিং, মোবাইল ব্যাংকিং, এটিএম পরিষেবা ইত্যাদি। এপিআই (যেমন নেটওয়ার্কিং এর জন্য java.net বা ডেটা পার্সিং এর জন্য javax.json) 
৪.  নিরাপত্তা প্রোটোকল বাস্তবায়ন: javax.crypto, javax.net.ssl)এই প্রোটোকলগুলির জন্য বিল্ট-ইন সাপোর্ট সরবরাহ করে। 
৫.  লেনদেনের লগিং ও নিরীক্ষণ: java.util.logging) লগিংয়ের জন্য স্ট্যান্ডার্ড সরঞ্জাম সরবরাহ করে। 
৬.  বহিরাগত সিস্টেমের সাথে যোগাযোগ: যেমন পেমেন্ট গেটওয়ে, ক্রেডিট ব্যুরো ইত্যাদি। জাভা এপিআই (যেমন HTTP সংযোগের জন্য java.net) এই প্রক্রিয়াটিকে সহজ করে তোলে। 
৭.  গ্রাহকের তথ্য সংরক্ষণ ও পুনরুদ্ধার:  java.util প্যাকেজের কালেকশন এপিআই (Collections API) এই কাজটিকে অনেক সহজ করে তোলে।


===============================================================================================================  
                        # Chapter Summary: Java Strings, Collections, and Functional Programming 
=============================================================================================================== 

This chapter covers essential Java concepts including:
- String manipulation and immutability
- StringBuilder vs String
- Java Collections Framework
- Lambda expressions and functional interfaces
- Java Date/Time API

## Key Concepts to Master

### 1. String Fundamentals
 String Operations:
   - Predict output of string manipulations
   - Understand immutability consequences
   - Know when to use StringBuilder

- Immutability: Strings cannot be changed after creation
- String Pool: Reuses string literals to save memory
- Key Methods:
  - `length()`, `charAt()`, `substring()`
  - `indexOf()`, `startsWith()`, `endsWith()`
  - `replace()`, `trim()`, `concat()`

### 2. StringBuilder
- Mutable alternative to String
- Key Methods:
  - `append()`, `insert()`, `delete()`
  - `reverse()`, `replace()`
- More efficient for multiple modifications

### 3. Collections Framework
Collection Usage:
   - Proper initialization and modification
   - Common method behaviors
   - Capacity vs size differences

- List: Ordered collection (ArrayList, LinkedList)
- Set: Unique elements (HashSet, TreeSet)
- Map: Key-value pairs (HashMap, TreeMap)
- Common Operations:
  - `add()`, `remove()`, `get()`, `contains()`
  - `size()`, `isEmpty()`, `clear()`

### 4. Functional Programming
Lambda Expressions:
   - Valid syntax forms
   - Functional interface matching
   - Method reference conversions

- Lambda Expressions: `(parameters) -> expression`
- Functional Interfaces:
  - `Predicate<T>`: `boolean test(T t)`
  - `Consumer<T>`: `void accept(T t)`
  - `Function<T,R>`: `R apply(T t)`
- Method references (`System.out::println`)

### 5. Date/Time API (java.time)
 Date/Time API:
   - Immutability patterns
   - Period calculations
   - DateTimeFormatter usage

- LocalDate: Date without time
- LocalTime: Time without date
- LocalDateTime: Date and time
- Period: Date-based amount of time
- Immutable and thread-safe


## Key Differences to Remember

1. String vs StringBuilder:
   - String: Immutable, thread-safe, better for constants
   - StringBuilder: Mutable, better for modifications

2. ArrayList Capacity:
   - Initial capacity is optimization hint
   - Size is actual element count

3. Lambda Syntax:
   - Parentheses optional for single parameter
   - Braces and return required for multiple statements
   - Type inference available

4. Date/Time Classes:
   - LocalDate: year/month/day
   - LocalTime: hour/minute/second/nano
   - LocalDateTime: combines date and time


## Common Pitfalls:
   - String vs StringBuilder performance
   - Collection index boundaries
   - Lambda syntax errors
   - Date/Time immutability


=====================Chapter 9(Selected Java API) =========================================

3,5,7,11,12,15,16,*19,21,25,26,27,*28,
33,*34,36,37,40,43,44,47,48, 49,50 = 24.


1. What is the best reason for using StringBuilder instead of String?
        A. StringBuilder adds support for multiple threads.
        B. StringBuilder can use == to compare values. **
        C. StringBuilder saves memory by reducing the number of objects created.
        D. StringBuilder supports different languages and encodings.
        
2. What is not true about a String?
        A. It can be created without coding a call to a constructor.
        B. It can be reused via the string pool. **
        C. It is final.
        D. It is mutable.

3. Which of the following creates a StringBuilder with a different value than the other options?
        A. new StringBuilder().append("clown")
        B. new StringBuilder("clown")
        C. new StringBuilder("cl").insert(2, "own")
        D. All of them create the same value.

4. What is the output of the following?
        StringBuilder teams = new StringBuilder("333");
        teams.append(" 806");
        teams.append(" 1601");
        System.out.print(teams);
        A. 333
        B. 333 806 1601
        C. The code compiles but outputs something else.
        D. The code does not compile.

5. How many of the types ArrayList, List, and Object can fill in the blank to produce code that compiles?
        List frisbees = new __();
        A. None
        B. One
        C. Two
        D. Three
        
6. What is the output of the following?
        List<String> tools = new ArrayList<>();
        tools.add("hammer");
        tools.add("nail");
        tools.add("hex key");
        System.out.println(tools.get(1));
        A. hammer
        B. hex key
        C. nail
        D. None of the above

7. What is the result of the following code?
        StringBuilder sb = new StringBuilder("radical").insert(sb.length(), "robots");
        System.out.println(sb);
        A. radicarobots
        B. radicalrobots
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

8. What is the output of the following?
        List<String> museums = new ArrayList<>(1);
        museums.add("Natural History");
        museums.add("Science");
        museums.add("Art");
        museums.remove(2);
        System.out.println(museums);
        A. [Natural History, Science]
        B. [Natural History, Art, Science]
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

9. What is the output of the following?
        12: StringBuilder b = new StringBuilder("12");
        13: b = b.append("3");
        14: b.reverse();
        15: System.out.println(b.toString());
        A. 12
        B. 123
        C. 321
        D. The code does not compile.

10. What is the main benefit of a lambda expression?
        A. It allows you to convert a primitive to a wrapper class.
        B. It allows you to change the bytecode while the application is running.
        C. It allows you to inherit from multiple classes.
        D. It allows you to write code that has the execution deferred(বিলম্বিত).

11. What is the output of the following?
        5: StringBuilder line = new StringBuilder("-");
        6: StringBuilder anotherLine = line.append("-");
        7: System.out.print(line == anotherLine);
        8: System.out.print(" ");
        9: System.out.print(line.length());
        A. false 1
        B. false 2
        C. true 1
        D. true 2

12. The author of this method forgot to include the data type. Which of the following reference types can fill in the blank to complete this method?
        public static void secret(__ mystery) {
        mystery.add("metal");
        String str = mystery.get(0);
        int num = mystery.length();
        }
        A. ArrayList
        B. ArrayList<String>
        C. StringBuilder
        D. None of the above

13. Which portion of code can be removed so that this line of code continues to compile?
        Predicate<StringBuilder> p = (StringBuilder b) -> {return true;};
        A. Remove StringBuilder b
        B. Remove ->
        C. Remove { and ;}
        D. Remove { return and ;}

14. What is the output of the following?
        20: List<Character> chars = new ArrayList<>();
        21: chars.add('a');
        22: chars.add('b');
        23: chars.set(1, 'c');
        24: chars.remove(0);
        25: System.out.print(chars.size() + " " + chars.contains('b'));
        A. 1 false
        B. 1 true
        C. 2 false
        D. 2 true

15. What is the output of the following?
        12: String b = "12";
        13: b += "3";
        14: b.reverse();
        15: System.out.println(b.toString());
        A. 12
        B. 123
        C. 321
        D. The code does not compile.

16. How many of these lines fail to compile?
        Predicate<String> pred1 = s -> false;
        Predicate<String> pred2 = (s) -> false;
        Predicate<String> pred3 = String s -> false;
        Predicate<String> pred4 = (String s) -> false;
        A. One
        B. Two
        C. Three
        D. Four

17. What does the following do?
        public class Shoot {
        interface Target {
        boolean needToAim(double angle);
        }
        static void prepare(double angle, Target t) {
        boolean ready = t.needToAim(angle); // k1
        System.out.println(ready);
        }
        public static void main(String[] args) {
        prepare(45, d -> d > 5 || d < -5); // k2
        }
        }
        A. It prints true.
        B. It prints false.
        C. It doesn’t compile due to line k1.
        D. It doesn’t compile due to line k2.

18. What is the output of the following?
        String teams = new String("694");
        teams.concat(" 1155");
        teams.concat(" 2265");
        teams.concat(" 2869");
        System.out.println(teams);
        A. 694
        B. 694 1155 2265 2869
        C. The code compiles but outputs something else.
        D. The code does not compile.

19. Which of these classes are in the java.util package?
        I. ArrayList
        II. LocalDate
        III. String
        A. I only
        B. II only
        C. I and II
        D. I, II, and III

20. Which of the answer choices results in a different value being output than the other three choices?
        StringBuilder sb = new StringBuilder("radical ");
        sb = ;
        System.out.print(sb);
        A. new StringBuilder("radical ").append("robots")
        B. new StringBuilder("radical ").delete(1, 100).append("obots").insert(1, "adical r")
        C. new StringBuilder("radical ").insert(7, "robots")
        D. new StringBuilder("radical ").insert(sb.length(), "robots")

21. What is the output of the following?
        String[] array = {"Natural History", "Science"};
        List<String> museums = Arrays.asList(array);
        museums.set(0, "Art");
        System.out.println(museums.contains("Art"));
        A. true
        B. false
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

22. Which is a true statement?
        A. If s.contains("abc") is true, then s.equals("abc") is also true.
        B. If s.contains("abc") is true, then s.startsWith("abc") is also true.
        C. If s.startsWith("abc") is true, then s.equals("abc") is also true.
        D. If s.startsWith("abc") is true, then s.contains("abc") is also true.

23. What is the output of the following?
        20: List<Character> chars = new ArrayList<>();
        21: chars.add('a');
        22: chars.add('b');
        23: chars.set(1, 'c');
        24: chars.remove(0);
        25: System.out.print(chars.length());
        A. 0
        B. 1
        C. 2
        D. None of the above

24. The author of this method forgot to include the data type. Which of the following reference
        types can fill in the blank to complete this method?
        public static void secret( mystery) {
        mystery = mystery.replace("1", "8");
        mystery.startsWith("paper");
        String s = mystery.toString();
        }
        A. ArrayList
        B. String
        C. StringBuilder
        D. None of the above

25. Which statement is true about the following figure while ensuring the code continues to compile?
        List P  balloons = new ArrayList Q ();
        A. <> can be inserted at position P without making any other changes.
        B. <> can be inserted at position Q without making any other changes.
        C. <> can be inserted at both positions P and Q.
        D. None of the above

26. Which of the following can fill in the blank to make the code compile?
        import java.util.function.*;
        public class Card {
        public static void main(String[] s) {
        Predicate<String> pred = __ -> true;
        }
        }
        A. (Integer i)
        B. (Object o)
        C. (String s)
        D. None of the above

27. What is the output of the following?
        5: String line = new String("-");
        6: String anotherLine = line.concat("-");
        7: System.out.print(line == anotherLine);
        8: System.out.print(" ");
        9: System.out.print(line.length());
        A. false 1
        B. false 2
        C. true 1
        D. true 2

28. What does the following output?
        Predicate dash = c -> c.startsWith("-");
        System.out.println(dash.test("–"));
        A. true
        B. false
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

29. Of the classes LocalDate, LocalDateTime, LocalTime, and LocalTimeStamp, how many include hours, minutes, and seconds?
        A. One
        B. Two
        C. Three
        D. Four

30. What is the output of the following class?
        1: package rocket;
        2: public class Countdown {
        3: public static void main(String[] args) {
        4: String builder = "54321";
        5: builder = builder.substring(4);
        6: System.out.println(builder.charAt(2));
        7: }
        8: }
        A. 2
        B. 3
        C. 4
        D. None of the above

31. Which equivalent code can replace i -> i != 0 in the following line?
        Predicate<Integer> ip = i -> i != 0;
        A. i -> { i != 0 }
        B. i -> { i != 0; }
        C. i -> { return i != 0 }
        D. i -> { return i != 0; }

32. What is the output of the following?
        LocalDate xmas = LocalDate.of(2016, 12, 25);
        xmas.plusDays(-1);
        System.out.println(xmas.getDayOfMonth());
        A. 24
        B. 25
        C. 26
        D. None of the above

33. What is the output of the following?
        1: public class Legos {
        2: public static void main(String[] args) {
        3: StringBuilder sb = new StringBuilder();
        4: sb.append("red");
        5: sb.deleteCharAt(0);
        6: sb.delete(1, 2);
        7: System.out.println(sb);
        8: }
        9: }
        A. e
        B. d
        C. ed
        D. None of the above

34. What does the following output?
        Predicate clear = c -> c.equals("clear");
        System.out.println(clear.test("pink"));
        A. true
        B. false
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

35. Which starts counting from one rather than zero?
        A. Array indexes
        B. The index used by charAt in a String
        C. The months in a LocalDateTime
        D. The months in a LocalTime

36. Which statement is not true of Predicate?
        A. A boolean is returned from the method it declares.
        B. It is an interface.
        C. The method it declares accepts two parameters.
        D. The method it declares is named test.

37. Which of these periods represents a larger amount of time?
        Period period1 = Period.ofWeeks(1).ofDays(3);
        Period period2 = Period.ofDays(10);
        A. period1
        B. period2
        C. They represent the same length of time.
        D. None of the above. This code does not compile.

38. What is the result of the following?
        import java.time.*;
        import java.time.format.*;
        public class HowLong {
        public static void main(String[] args) {
        LocalDate newYears = LocalDate.of(2017, 1, 1);
        Period period = Period.ofDays(1);
        DateTimeFormatter format = DateTimeFormatter.ofPattern("MM-dd-yyyy");
        System.out.print(format.format(newYears.minus(period)));
        }
        }
        A. 01-01-2017
        B. 12-31-2016
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

39. Which of the following can fill in the blank so the following code prints true?
        String happy = " :) - (: ";
        String really = happy.trim();
        String question = ;
        System.out.println(really.equals(question));
        A. happy.substring(0, happy.length() - 1)
        B. happy.substring(0, happy.length())
        C. happy.substring(1, happy.length() - 1)
        D. happy.substring(1, happy.length())

40. Which is not a true statement about the Period class?
        A. A Period is immutable.
        B. A Period is typically used for adding or subtracting time from dates.
        C. You can create a Period representing 2 minutes.
        D. You can create a Period representing 5 years.

41. What is the output of the following class?
        1: package rocket;
        2: public class Countdown {
        3: public static void main(String[] args) {
        4: StringBuilder builder = new StringBuilder("54321");
        5: builder.substring(2);
        6: System.out.println(builder.charAt(1));
        7: }
        8: }
        A. 1
        B. 2
        C. 3
        D. 4

42. What does the following output?
        List<Integer> pennies = new ArrayList<>();
        pennies.add(3);
        pennies.add(2);
        pennies.add(1);
        pennies.remove(2);
        System.out.println(pennies);
        A. [3, 1]
        B. [3, 2]
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

43. The author of this method forgot to include the data type. Which of the following reference types can best fill in the blank to complete this method?
        public static void secret(__ mystery) {
        char ch = mystery.charAt(3);
        mystery = mystery.insert(1, "more");
        int num = mystery.length();
        }
        A. ArrayList
        B. String
        C. StringBuilder
        D. None of the above

44. What is the smallest unit you can add to a LocalTime object?
        A. Second
        B. Millisecond
        C. Nanosecond
        D. Picosecond

45. What is the result of the following?
        import java.time.*;
        import java.time.format.*;
        public class HowLong {
        public static void main(String[] args) {
        LocalDate newYears = LocalDate.of(2017, 1, 1);
        Period period = Period.ofDays(1);
        DateTimeFormatter format = DateTimeFormatter.ofPattern("mm-dd-yyyy");
        System.out.print(format.format(newYears.minus(period)));
        }
        }
        A. 01-01-2017
        B. 12-31-2016
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

46. Which of the following types can you pass as a parameter to the replace() method on the String class?
        I. char
        II. String
        III. StringBuilder
        A. I
        B. I and II
        C. II and III
        D. I, II, and III

47. How many lines does this code output?
        import java.util.*;
        import java.util.function.*;
        public class PrintNegative {
        public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("-5");
        list.add("0");
        list.add("5");
        print(list, e -> e < 0);
        }
        public static void print(List<String> list, Predicate<Integer> p) {
        for (String num : list)
        if (p.test(num))
        System.out.println(num);
        }
        }
        A. One
        B. Two
        C. None. The code does not compile.
        D. None. The code throws an exception at runtime.

48. What is the output of the following?
        12: List<String> magazines = new ArrayList();
        13: magazines.add("Readers Digest");
        14: magazines.add("People");
        15: magazines.clear();
        16: magazines.add("The Economist");
        17: magazines.remove(1);
        18: System.out.println(magazines.size());
        A. 0
        B. 1
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

49. What is the output of the following?
        public class Costume {
        public static void main(String[] black) {
        String witch = 'b';
        String tail = "lack";
        witch = witch.concat(tail);
        System.out.println(witch);
        }
        }
        A. b
        B. black
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.

50. What is the result of the following?
        LocalDate xmas = LocalDate.of(2016, 12, 25);
        xmas.setYear(2017);
        System.out.println(xmas.getYear());
        A. 2016
        B. 2017
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.
        


================================ Answers =============================

1. C, 2.D, 3.D, 4.B, 5.B, 6.C, 7.C, 8.A, 9.C, 10.D,
11.D, 12.D, 13.D, 14.A, 15.D, 16.A, 17.A, 18.A, 19.A, 20.C,
21.A, 22.D, 23.D, 24.B, 25.B, 26.D, 27.A, 28.C, 29.B, 30.D,
31.D, 32.B, 33.A, 34.B, 35.C, 36.C, 37.B, 38.B, 39.C, 40.C,
41.D, 42.B, 43.C, 44.C, 45.D, 46.D, 47.C, 48.D, 49.C, 50.C

১. গ. বিকল্প ক ভুল কারণ `StringBuilder` একাধিক থ্রেড সমর্থন করে না। আসলে, থ্রেডগুলো OCA-তে অন্তর্ভুক্তও নয়, যা আপনার জন্য একটি সূত্র হওয়া উচিত যে এই উত্তরটি ভুল! পরীক্ষার জন্য আপনার এটি জানার দরকার নেই, তবে `StringBuffer` একাধিক থ্রেড সমর্থন করে। বিকল্প খ ভুল কারণ `==` রেফারেন্স তুলনা করে, মান নয়। বিকল্প ঘ ভুল কারণ `String` এবং `StringBuilder` উভয়ই ভাষা এবং এনকোডিং সমর্থন করে। বিকল্প গ সঠিক এবং `StringBuilder` ব্যবহারের প্রধান কারণ। `String` প্রায়শই কিছু নির্দিষ্ট মেথড যেমন `concat()` কল করার সময় একটি নতুন অবজেক্ট তৈরি করে। `StringBuilder` `append()` এর মতো অপারেশনগুলোকে অপ্টিমাইজ করে কারণ এটি পরিবর্তনযোগ্য।
২. ঘ. একটি `String` সরাসরি কনস্ট্রাক্টর কল না করে একটি লিটারাল ব্যবহার করে তৈরি করা যেতে পারে, যা বিকল্প ক-কে ভুল করে। `String` পুনঃব্যবহারের জন্য একটি স্ট্রিং পুল বিদ্যমান, যা বিকল্প খ-কে ভুল করে। একটি `String` `final` এবং `immutable`, যা বিকল্প গ-কে ভুল এবং বিকল্প ঘ-কে সঠিক করে।
৩. ঘ. এই প্রশ্নটি পরীক্ষা করছে যে আপনি মেথড চেইনিং কীভাবে কাজ করে তা বোঝেন কিনা। বিকল্প ক একটি খালি `StringBuilder` তৈরি করে এবং তারপর `clown`-এর পাঁচটি অক্ষর এতে যোগ করে। বিকল্প খ কেবল কনস্ট্রাক্টর কল করার সময় `clown` তৈরি করে। অবশেষে, বিকল্প গ একই মান তৈরি করে, কেবল দুটি অংশে। অতএব, বিকল্প ঘ সঠিক।
৪. খ. যেহেতু `StringBuilder` পরিবর্তনযোগ্য, `append()` এর প্রতিটি কল মানটিতে যোগ করে। `print()` কল করার সময়, `toString()` স্বয়ংক্রিয়ভাবে কল হয় এবং 333 806 1601 আউটপুট হয়। অতএব, বিকল্প খ সঠিক।

৫. খ. `List` একটি ইন্টারফেস, ক্লাস নয়। এটি ইনস্ট্যানশিয়েট করা যায় না। যদিও `Object` একটি কংক্রিট ক্লাস, এটি `List` ইন্টারফেস প্রয়োগ করে না তাই এটি `frisbees`-এ অ্যাসাইন করা যায় না। উল্লেখ্য যে, আপনি যদি একটি সুস্পষ্ট কাস্ট যোগ করেন, তবে এটি কম্পাইল হবে এবং রানটাইমে একটি ব্যতিক্রম ছুঁড়ে দেবে। তিনটি বিকল্পের মধ্যে, কেবল `ArrayList`-ই ফাঁকা স্থান পূরণ করতে পারে, তাই বিকল্প খ সঠিক।
৬. গ. একটি `ArrayList` স্বয়ংক্রিয়ভাবে উপাদানগুলোকে সাজায় না। এটি কেবল সেগুলোকে ক্রমানুসারে মনে রাখে। যেহেতু জাভা শূন্য-ভিত্তিক সূচক ব্যবহার করে, বিকল্প গ সঠিক।
৭. গ. কনস্ট্রাক্টর কল করা এবং তারপর `insert()` মেথড চেইনিং-এর একটি উদাহরণ। তবে, `sb.length()` কলটি একটি সমস্যা। `sb` রেফারেন্সটি চেইন্ড কলগুলো সম্পূর্ণ না হওয়া পর্যন্ত বিদ্যমান থাকে না। এটি একটি আলাদা লাইনে আছে বলেই রেফারেন্সটি কখন তৈরি হয় তা পরিবর্তন হয় না। যেহেতু কোডটি কম্পাইল করে না, বিকল্প গ সঠিক।
৮. ক. যদিও `ArrayList` একটি উপাদানের প্রাথমিক ক্ষমতা দিয়ে ঘোষণা করা হয়, তবে আরও উপাদান যোগ করার সাথে সাথে এটি প্রসারিত হতে পারে। `add()` মেথডের তিনটি কলই `ArrayList`-এর শেষে একটি উপাদান যোগ করে। `remove()` মেথড কলটি সূচক ২-এর উপাদানটিকে মুছে দেয়, যা Art। অতএব, বিকল্প ক সঠিক।
৯. গ. লাইন ১২-তে, `StringBuilder`-এর মান ১২। লাইন ১৩-তে, এটি ১২৩ হয়। যেহেতু `StringBuilder` পরিবর্তনযোগ্য, একই রেফারেন্সে ফলাফল সংরক্ষণ করা অপ্রয়োজনীয়। তারপর লাইন ১৪-তে, মানটি উল্টানো হয়, যা আমাদের ৩২১ দেয় এবং বিকল্প গ-কে সঠিক করে।
১০. ঘ. বিকল্প ক ভুল কারণ এটি অটোবক্সিং বর্ণনা করে। বিকল্প খ এবং গ জাভাতে সম্ভব নয়। বিকল্প ঘ সঠিক কারণ এটি ল্যাম্বডা বর্ণনা করে। ল্যাম্বডাগুলো স্থগিত এক্সিকিউশন ব্যবহার করে এবং কোডবেসের অন্য কোথাও চালানো যেতে পারে।

১১. ঘ. একটি `StringBuilder` পরিবর্তনযোগ্য, তাই লাইন ৬ সম্পূর্ণ হওয়ার পরে দৈর্ঘ্য দুই হয়। `StringBuilder` মেথডগুলো একই অবজেক্টের একটি রেফারেন্স ফেরত দেয় যাতে আপনি মেথড কলগুলো চেইন করতে পারেন। অতএব, `line` এবং `anotherLine` একই অবজেক্টকে নির্দেশ করে। এর মানে হল লাইন ৭ `true` প্রিন্ট করে। তারপর লাইন ৯-তে, উভয় রেফারেন্স দৈর্ঘ্য ২-এর একই অবজেক্টকে নির্দেশ করে এবং বিকল্প ঘ সঠিক।
১২. ঘ. `add()` এবং `get()` মেথডগুলো `ArrayList`-এ উপলব্ধ। তবে, `ArrayList` উপাদানগুলোর সংখ্যা পেতে `length` এর পরিবর্তে `size` ব্যবহার করে। অতএব, বিকল্প ঘ সঠিক। যদি `length`-কে `size`-এ পরিবর্তন করা হতো, তাহলে ফাঁকা স্থানে রাখলে বিকল্প খ কম্পাইল হতো। বিকল্প ক ফাঁকা স্থানে এখনও কম্পাইল হতো না কারণ মানটিকে `str`-এ সংরক্ষণ করার জন্য একটি কাস্ট প্রয়োজন হতো।
১৩. ঘ. বিকল্প ক চতুর, কিন্তু ভুল। যদিও একটি ল্যাম্বডার শূন্য প্যারামিটার থাকতে পারে, একটি `Predicate`-এর থাকতে পারে না। একটি `Predicate`-কে একটি `boolean`-এ ম্যাপ করা একটি টাইপ হিসাবে সংজ্ঞায়িত করা হয়। বিকল্প খ স্পষ্টতই ভুল কারণ `->` একটি ল্যাম্বডার অংশগুলোকে আলাদা করে। বিকল্প গ এবং ঘ একই রকম। বিকল্প গ ভুল কারণ `return` কেবল তখন অনুমতিপ্রাপ্ত যখন বন্ধনীগুলো উপস্থিত থাকে। বিকল্প ঘ সঠিক।
১৪. ক. লাইন ২০-২২ দুটি উপাদান সহ একটি `ArrayList` তৈরি করে। লাইন ২৩ দ্বিতীয়টিকে একটি নতুন মান দিয়ে প্রতিস্থাপন করে। এখন `chars` হল `[a, c]`। তারপর লাইন ২৪ প্রথম উপাদানটিকে সরিয়ে দেয়, যা কেবল `[c]` তৈরি করে। বিকল্প ক সঠিক কারণ কেবল একটি উপাদান আছে, তবে এটি `b` মান নয়।

১৫. ঘ. ধূর্ত প্রশ্ন। `String` ক্লাসে কোনো `reverse` মেথড নেই। `StringBuilder` ক্লাসে একটি আছে। অতএব, কোডটি কম্পাইল করে না এবং বিকল্প ঘ সঠিক।
১৬. ক. কেবলমাত্র একটি প্যারামিটার দিয়ে একটি ল্যাম্বডা তৈরি করার সময়, কয়েকটি ভিন্নতা রয়েছে। `pred1` পদ্ধতিটি সবচেয়ে সংক্ষিপ্ত উপায় দেখায়, যেখানে টাইপ বাদ দেওয়া হয় এবং বন্ধনী বাদ দেওয়া হয়। `pred2` পদ্ধতিটি অনুরূপ, তবে এতে বন্ধনী অন্তর্ভুক্ত থাকে। উভয়ই বৈধ। `pred4` পদ্ধতিটি বন্ধনী এবং টাইপ উভয়ই নির্দিষ্ট করে দীর্ঘ উপায়। যে একটি কম্পাইল করে না তা হল `pred3`। টাইপ অন্তর্ভুক্ত করা হলে বন্ধনীগুলো আবশ্যক।
১৭. ক. এটি একটি ল্যাম্বডা ব্যবহার করে কোডের একটি সঠিক উদাহরণ। ইন্টারফেসটিতে একটি একক অ্যাবস্ট্রাক্ট মেথড রয়েছে। ল্যাম্বডাটি সঠিকভাবে একটি `double` প্যারামিটার গ্রহণ করে এবং একটি `boolean` ফেরত দেয়। এটি ইন্টারফেসের সাথে মিলে যায়। ল্যাম্বডা সিনট্যাক্স সঠিক। যেহেতু ৪৫ ৫ এর চেয়ে বড়, বিকল্প ক সঠিক।
১৮. ক. যেহেতু `String` অপরিবর্তনীয়, `concat()` এর প্রতিটি কল একটি নতুন অবজেক্টকে নতুন মান দিয়ে ফেরত দেয়। তবে, সেই ফেরত মানটি উপেক্ষা করা হয় এবং `teams` ভেরিয়েবলের মান কখনও পরিবর্তিত হয় না। অতএব এটি ৬৯৪ থাকে এবং বিকল্প ক সঠিক।
১৯. ক. `ArrayList` ক্লাসটি `java.util` প্যাকেজে রয়েছে, যা I-কে সঠিক করে। `LocalDate` ক্লাসটি `java.time` প্যাকেজে রয়েছে, যা II-কে ভুল করে। `String` ক্লাসটি `java.lang` প্যাকেজে রয়েছে, যার অর্থ আপনি কোনো `import` টাইপ না করেই এটি ব্যবহার করতে পারেন, যা III-কে ভুল করে। অতএব, বিকল্প ক সঠিক।
২০. গ. বিকল্প ক সহজ এবং `radical robots` আউটপুট দেয়। বিকল্প খ একটি জটিল পদ্ধতিতে একই কাজ করে। প্রথমে বিকল্প খ প্রথম অক্ষরের পরে সমস্ত অক্ষর মুছে ফেলে। আসলে ১০০ অক্ষর মুছে ফেলার মতো নেই তা কোনো ব্যাপার না। তারপর এটি `obots` যোগ করে শেষে, যা বিল্ডারটিকে `robots` ধারণ করে। অবশেষে, এটি স্ট্রিংয়ের অবশিষ্ট অংশটি প্রথম সূচকের ঠিক পরে সন্নিবেশ করায়। এটি কল্পনা করা কঠিন হলে প্রবাহটি আঁকার চেষ্টা করুন। বিকল্প ঘ `StringBuilder`-এর শেষের ঠিক পরে `robots` সন্নিবেশ করে একই মান তৈরি করে। বিকল্প গ কাছাকাছি, তবে এতে একটি অফ-বাই-ওয়ান ত্রুটি রয়েছে। এটি স্পেসের পরে না হয়ে `l` অক্ষরের পরে `robots` সন্নিবেশ করায়। এর ফলে `radicalrobots` এর পরে একটি স্পেস থাকে। বিকল্প গ অন্যদের থেকে ভিন্ন এবং সঠিক উত্তর।

২১. ক. যেহেতু আমরা একটি অ্যারে থেকে তালিকা তৈরি করছি, এটি একটি নির্দিষ্ট আকারের। আমরা উপাদান পরিবর্তন করার অনুমতিপ্রাপ্ত। এই কোডের শেষে, `museums` হল `[Art, Science]`। অতএব, এটি Art ধারণ করে এবং বিকল্প ক সঠিক।
২২. ঘ. যদি `String` "deabc" হয় তবে বিকল্প ক এবং খ সত্য নয়। যদি `String` "abcde" হয় তবে বিকল্প গ সত্য নয়। বিকল্প ঘ সকল ক্ষেত্রে সত্য।
২৩. ঘ. লাইন ২৫ কম্পাইল করে না। একটি `ArrayList`-এ, উপাদানগুলোর সংখ্যা পেতে `size` মেথড ব্যবহার করা হয়। `length()` মেথড একটি `String` বা `StringBuilder`-এর জন্য ব্যবহৃত হয়।
২৪. খ. `toString()` মেথড কলটি জিনিসগুলোকে সংকুচিত করতে সাহায্য করে না কারণ সমস্ত জাভা অবজেক্টে সেই মেথড উপলব্ধ। অন্য দুটি মেথড বেশি সহায়ক। `String` এই তিনটির মধ্যে একমাত্র টাইপ যার `startsWith()` মেথড রয়েছে, যা বিকল্প খ-কে সঠিক করে। `String`-এর এখানে ঘোষিত `replace()` মেথডটিও রয়েছে। আপনি যদি পুরো API মুখস্ত করে থাকেন, তাহলে আপনি হয়তো জানবেন যে `StringBuilder`-এরও একটি `replace()` মেথড আছে, তবে এতে দুটি প্যারামিটারের পরিবর্তে তিনটি প্যারামিটার প্রয়োজন। অনুগ্রহ করে সেই স্তরের বিস্তারিতভাবে API মুখস্ত করবেন না। আমরা আমাদের অধ্যয়ন নির্দেশিকাতে আপনার যা জানা দরকার তা অন্তর্ভুক্ত করেছি। আপনার যদি এই বাইরের জ্ঞান থাকে, তবে প্রশ্নগুলোতে অতিরিক্ত পড়ার বিষয়ে সতর্ক থাকুন!
২৫. খ. `<>` কে ডায়মন্ড অপারেটর বলা হয়। এখানে, এটি একই ঘোষণার জন্য জেনেরিক টাইপ দুবার পুনরাবৃত্তি এড়াতে একটি শর্টকাট হিসাবে কাজ করে। এক্সপ্রেশনের ডানদিকে, এটি একটি সুবিধাজনক শর্টকাট। জাভার এখনও বাম দিকে টাইপ প্রয়োজন যাতে কিছু অনুমান করার থাকে। চিত্রে, P অবস্থানটি বাম দিক এবং Q অবস্থানটি ডান দিক। অতএব, বিকল্প খ সঠিক।

২৬. ঘ. ল্যাম্বডার টাইপ `Predicate`-এ ঘোষিত জেনেরিকের সাথে মিলতে হবে। এই ক্ষেত্রে, এটি `String`। অতএব, বিকল্প ক এবং খ ভুল। যদিও বিকল্প গ সঠিক টাইপের, এটি `s` ভেরিয়েবলটি ব্যবহার করে, যা `main()` মেথড প্যারামিটার থেকে ইতিমধ্যেই ব্যবহৃত হচ্ছে। অতএব, এর কোনটিই সঠিক নয় এবং বিকল্প ঘ হল উত্তর।
২৭. ক. একটি `String` অপরিবর্তনীয় তাই লাইন ৬-এ একটি ভিন্ন অবজেক্ট ফেরত দেওয়া হয়। লাইন ৬ সম্পূর্ণ হওয়ার পরে `anotherLine` নির্দেশিত অবজেক্টের দৈর্ঘ্য ২ হয়। তবে, মূল `line` রেফারেন্স এখনও দৈর্ঘ্য ১-এর একটি অবজেক্টকে নির্দেশ করে। অতএব, বিকল্প ক সঠিক।
২৮. গ. যদিও একটি `Predicate`-এর একটি জেনেরিক টাইপ থাকা সাধারণ, তবে এটি প্রয়োজন হয় না। যখন জেনেরিকটি বাদ দেওয়া হয়, তখন এটিকে `Object` টাইপের একটি `Predicate` হিসাবে বিবেচনা করা হয়। যেহেতু `startsWith()` `Object`-এ বিদ্যমান নেই, প্রথম লাইনটি কম্পাইল করে না এবং বিকল্প গ সঠিক।
২৯. খ. `LocalDate` কেবল তারিখ অংশ অন্তর্ভুক্ত করে, সময় অংশ নয়। `LocalTimeStamp` নামে কোনো ক্লাস নেই। অন্য দুটি, `LocalDateTime` এবং `LocalTime`, উভয়ই সময় উপাদান অন্তর্ভুক্ত করে, যা বিকল্প খ-কে সঠিক করে।
৩০. ঘ. লাইন ৪ দৈর্ঘ্য ৫-এর একটি `String` তৈরি করে। যেহেতু `String` অপরিবর্তনীয়, লাইন ৫ মান ১ সহ একটি নতুন `String` তৈরি করে এবং এটি `builder`-এ অ্যাসাইন করে। মনে রাখবেন যে জাভাতে সূচকগুলো ০ থেকে শুরু হয়, তাই `substring()` মেথডটি পঞ্চম উপাদান থেকে শেষ পর্যন্ত মানগুলো নিচ্ছে। যেহেতু প্রথম উপাদানটি শেষ উপাদান, সেখানে কেবল একটি অক্ষর রয়েছে। তারপর লাইন ৬ দ্বিতীয় সূচকযুক্ত উপাদানটি পুনরুদ্ধার করার চেষ্টা করে। যেহেতু কেবল একটি উপাদান রয়েছে, এটি একটি `StringIndexOutOfBoundsException` দেয় এবং বিকল্প ঘ সঠিক।

৩১. ঘ. আপনি যখন বন্ধনী ব্যবহার করেন, তখন ল্যাম্বডা কম্পাইল হওয়ার জন্য `return` কীওয়ার্ড এবং সেমিকোলন উভয়ই প্রয়োজন, যা বিকল্প ঘ-কে সঠিক করে।
৩২. খ. জাভা ৮ তারিখ এবং সময় ক্লাসগুলো অপরিবর্তনীয়। `plusDays` মেথডটি ক্রিসমাস ইভ (২৪শে ডিসেম্বর) উপস্থাপনকারী একটি `LocalDate` অবজেক্ট ফেরত দেয়। তবে, এই ফেরত মানটি উপেক্ষা করা হয়। `xmas` ভেরিয়েবলটি এখনও আসল মানটি উপস্থাপন করে, তাই বিকল্প খ সঠিক।
৩৩. ক. লাইন ৩ একটি খালি `StringBuilder` তৈরি করে। লাইন ৪ এতে তিনটি অক্ষর যোগ করে। লাইন ৫ প্রথম অক্ষরটি মুছে ফেলে, যার ফলে `ed` হয়। লাইন ৬ পজিশন ১ থেকে শুরু করে পজিশন ২ এর ঠিক আগে অক্ষরগুলো মুছে ফেলে, যা সূচক ১-এর অক্ষরটি মুছে দেয়, যা `d`। একমাত্র অক্ষর বাকি থাকে `e`, তাই বিকল্প ক সঠিক।
৩৪. খ. যদিও একটি `Predicate`-এর একটি জেনেরিক টাইপ থাকা সাধারণ, তবে এটি প্রয়োজন হয় না। যখন জেনেরিকটি বাদ দেওয়া হয়, তখন এটিকে `Object` টাইপের একটি `Predicate` হিসাবে বিবেচনা করা হয়। যেহেতু `equals()` মেথডটি `Object`-এ বিদ্যমান, এটি ঠিক আছে। বিকল্প খ সঠিক কারণ `Predicate` `false` হিসাবে পরীক্ষা করে।

৩৫. গ. জাভাতে, বেশিরভাগ জিনিস শূন্য-ভিত্তিক সূচক ব্যবহার করে, যার মধ্যে অ্যারে এবং একটি `String` অন্তর্ভুক্ত। জাভা ৮ থেকে মাসগুলো এই প্রথার ব্যতিক্রম। এটি উত্তরকে বিকল্প গ বা ঘ করে তোলে। তবে, `LocalTime`-এ তারিখ ক্ষেত্র থাকে না, তাই এটি অবশ্যই বিকল্প গ হতে হবে।
৩৬. গ. `Predicate` একটি ইন্টারফেস যার একটি মেথড আছে। মেথডের স্বাক্ষর হল `boolean test(T t)`। বিকল্প গ হল উত্তর কারণ মেথডটি দুটি প্যারামিটারের পরিবর্তে একটি প্যারামিটার গ্রহণ করে।
৩৭. খ. এখানে সতর্ক থাকুন। `Period` ক্লাসটি `period` ফেরত দিতে একটি স্ট্যাটিক হেল্পার মেথড ব্যবহার করে। এটি মেথড কলগুলো চেইন করে না, তাই `period1` কেবল তিন দিন উপস্থাপন করে। যেহেতু তিন দিন ১০ দিনের চেয়ে কম, `period2` বড় এবং বিকল্প খ সঠিক।
৩৮. খ. কোডটি ১লা জানুয়ারি ২০১৭ তারিখ এবং এক দিনের একটি সময়কাল সঠিকভাবে তৈরি করে শুরু হয়। তারপর এটি স্পষ্টভাবে মাস, তারপর দিন, তারপর বছর হিসাবে বিন্যাস সংজ্ঞায়িত করে। অবশেষে, কোডটি এক দিন বিয়োগ করে, যা আমাদের ৩১শে ডিসেম্বর ২০১৬-এর বিন্যাসিত সংস্করণ দেয়।
৩৯. গ. `trim()` মেথডটি সমস্ত অগ্রণী এবং অনুসারী সাদা স্থান সরানো সহ একটি `String` ফেরত দেয়। এই প্রশ্নে, এটি সাত-অক্ষরের `String`: ":) - (:"। বিকল্প ক এবং খ ভুল কারণ তারা `happy`-তে প্রথম ফাঁকা স্থানটি সরায় না। বিকল্প ঘ ভুল কারণ এটি `happy`-তে শেষ অক্ষরটি সরায় না। অতএব, বিকল্প গ সঠিক।
৪০. গ. `Period` ক্লাসটি অপরিবর্তনীয় অবজেক্ট তৈরি করে এবং সাধারণত `LocalDate` বা `LocalDateTime` অবজেক্ট থেকে যোগ/বিয়োগ করতে ব্যবহৃত হয়। এটি দিন, সপ্তাহ, মাস বা বছরের সময়কাল তৈরি করতে দেয়। যেহেতু এটি সময়ের জন্য ব্যবহার করা যায় না, বিকল্প গ হল উত্তর।

৪১. ঘ. লাইন ৪ দৈর্ঘ্য ৫-এর একটি `StringBuilder` তৈরি করে। `substring()` মেথড `StringBuilder`-এর দিকে মনোযোগ দিন। এটি `321` মান সহ একটি `String` ফেরত দেয়। এটি `StringBuilder` নিজেই পরিবর্তন করে না। তারপর লাইন ৬ সেই অপরিবর্তিত মান থেকে দ্বিতীয় সূচকযুক্ত উপাদানটি পুনরুদ্ধার করছে, যা `4`। অতএব, বিকল্প ঘ সঠিক।
৪২. খ. এটি চতুর। `ArrayList`-এ দুটি `remove()` মেথড উপলব্ধ। একটি সূচক দ্বারা একটি উপাদান সরায় এবং একটি `int` প্যারামিটার নেয়। অন্যটি মান দ্বারা একটি উপাদান সরায়। জেনেরিকগুলোর কারণে, এই উদাহরণে এটি একটি `Integer` প্যারামিটার নেয়। যেহেতু `int` প্রিমিটিভটি একটি ভাল মিল, সূচক ২-এর উপাদানটি সরানো হয়, যা ১-এর মান। অতএব, বিকল্প খ সঠিক।
৪৩. গ. `ArrayList`-এর একটি `size()` মেথড আছে `length()` মেথড না হয়ে, যা বিকল্প ক-কে ভুল করে। `charAt()` এবং `length()` মেথডগুলো `String` এবং `StringBuilder` উভয় ক্ষেত্রেই ঘোষিত। তবে, `insert()` মেথডটি কেবল একটি `StringBuilder`-এ ঘোষিত এবং একটি `String`-এ নয়। অতএব, বিকল্প গ সঠিক।
৪৪. গ. `minusNanos` এবং `plusNanos` হল উপলব্ধ ক্ষুদ্রতম একক, যা বিকল্প গ-কে সঠিক করে। বিকল্প ঘ ভুল কারণ `LocalTime` এত সূক্ষ্ম নয়। উল্লেখ্য যে আপনি অনেক ন্যানোসেকেন্ড যোগ করে মিলিসেকেন্ড যোগ করতে পারলেও, এর জন্য কোনো মেথড নেই। একটি মিলিসেকেন্ডও একটি ন্যানোসেকেন্ডের চেয়ে বড়। অবশেষে, `LocalTime` অপরিবর্তনীয় এই তথ্য দ্বারা বিভ্রান্ত হবেন না। আপনি এখনও সময় যোগ করতে পারেন; এটি কেবল একটি ভিন্ন অবজেক্ট হিসাবে ফেরত আসে।

৪৫. ঘ. একটি ফরম্যাটার অবজেক্ট তৈরি করার সময়, মনে রাখবেন যে `MM` মাসকে বোঝায় যখন `mm` মিনিটকে বোঝায়। যেহেতু একটি `LocalDate` অবজেক্টে কোনো মিনিট সংজ্ঞায়িত করা হয় না, কোডটি একটি `UnsupportedTemporalTypeException` ছুঁড়ে দেয়। আপনার ব্যতিক্রমের নামটি জানার প্রয়োজন নেই, তবে একটি ব্যতিক্রম ছুঁড়ে দেওয়া হয় তা আপনার জানা দরকার।
৪৬. ঘ. `replace()` মেথডের দুটি স্বাক্ষর রয়েছে। একটি দুটি `char` প্যারামিটার নেয়। অন্য স্বাক্ষরটি একটি `CharSequence` নেয়। `String` এবং `StringBuilder` উভয়ই এই ইন্টারফেসটি প্রয়োগ করে। এটি তিনটি বিকল্পকে সঠিক করে এবং বিকল্প ঘ সঠিক।
৪৭. গ. ডেটা টাইপগুলোতে মনোযোগ দিন। `print()` মেথডটি `String` অবজেক্টের একটি তালিকা ধরে লুপ করছে। তবে, `Predicate` একটি `Integer` আশা করে। যেহেতু এগুলো মেলে না, `if` স্টেটমেন্টটি কম্পাইল করে না।
৪৮. ঘ. লাইন ১২ একটি খালি `ArrayList` তৈরি করে। যদিও অ্যাসাইনমেন্ট অপারেটরের কেবল বাম দিকে জেনেরিক ব্যবহার করার সুপারিশ করা হয় না, তবে এটি অনুমোদিত। এটি কেবল একটি সতর্কতা দেয়। লাইন ১৩ এবং ১৪ দুটি উপাদান যোগ করে। লাইন ১৫ একটি খালি `ArrayList`-এ রিসেট করে। লাইন ১৬ একটি উপাদান যোগ করে, তাই এখন আমাদের দৈর্ঘ্য ১-এর একটি `ArrayList` আছে। লাইন ১৭ সূচক ১-এর উপাদানটি সরানোর চেষ্টা করে। যেহেতু জাভা শূন্য-ভিত্তিক সূচক ব্যবহার করে, সেখানে কোনো উপাদান নেই এবং কোডটি একটি `IndexOutOfBoundsException` ছুঁড়ে দেয়।
৪৯. গ. `witch`-এর ঘোষণা ভুল। এটি একটি `char`-কে একটি `String` ভেরিয়েবল রেফারেন্সে সংরক্ষণ করার চেষ্টা করে। এটি কম্পাইল করে না, যা বিকল্প গ-কে সঠিক করে। যদি এটি ঠিক করা হতো, তবে উত্তরটি বিকল্প খ হতো।
৫০. গ. জাভা ৮ তারিখ এবং সময় ক্লাসগুলো অপরিবর্তনীয়। এর অর্থ হল সেগুলোতে সেটার মেথড থাকে না এবং কোডটি কম্পাইল করে না।"













1. C. Option A is incorrect because StringBuilder does not support multiple threads. In fact, threads aren’t even covered on the OCA, which should be your clue that this answer
is wrong! You don’t need to know this for the exam, but StringBuffer supports multiple threads. Option B is incorrect because == compares references, not values. Option D is
incorrect because both String and StringBuilder support languages and encodings. Option C is correct and the primary reason to use StringBuilder. String often creates a
new object each time you call certain methods on the object like concat(). StringBuilder optimizes operations like append() because it is mutable.
2. D. A String can be created using a literal rather than calling a constructor directly, making Option A incorrect. A string pool exists for String reuse, making Option B incorrect.
A String is final and immutable, making Option C incorrect and Option D correct.
3. D. This question is testing whether you understand how method chaining works. Option A creates an empty StringBuilder and then adds the five characters in clown to it. Option B
simply creates the clown when calling the constructor. Finally, Option C creates the same value, just in two parts. Therefore, Option D is correct.
4. B. Since StringBuilder is mutable, each call to append adds to the value. When calling print, toString() is automatically called and 333 806 1601 is output. 
Therefore, Option B is correct.

5. B. List is an interface and not a class. It cannot be instantiated. While Object is a concrete class, it does not implement the List interface so it cannot be assigned to frisbees.
Note that if you were to add an explicit cast, it would compile and throw an exception at runtime. Of the three options, only ArrayList can fill in the blank, so Option B is correct.
6. C. An ArrayList does not automatically sort the elements. It simply remembers them in order. Since Java uses zero-based indexes, Option C is correct.
7. C. Calling the constructor and then insert() is an example of method chaining. However, the sb.length() call is a problem. The sb reference doesn’t exist until after the chained
calls complete. Just because it happens to be on a separate line doesn’t change when the reference is created. Since the code does not compile, Option C is correct.
8. A. While the ArrayList is declared with an initial capacity of one element, it is free to expand as more elements are added. Each of the three calls to the add() method adds an
element to the end of the ArrayList. The remove() method call deletes the element at index 2, which is Art. Therefore, Option A is correct.
9. C. On line 12, the value of the StringBuilder is 12. On line 13, it becomes 123. Since StringBuilder is mutable, storing the result in the same reference is redundant. Then on
line 14, the value is reversed, giving us 321 and making Option C correct.
10. D. Option A is incorrect as it describes autoboxing. Options B and C are not possible in Java. Option D is correct as it describes lambdas. Lambdas use deferred execution and can
be run elsewhere in the codebase.

11. D. A StringBuilder is mutable, so the length is two after line 6 completes. The StringBuilder methods return a reference to the same object so you can chain method
calls. Therefore, line and anotherLine refer to the same object. This means that line 7 prints true. Then on line 9, both references point to the same object of length 2, and Option D is correct.
12. D. The add() and get() methods are available on ArrayList. However, ArrayList uses size rather than length to get the number of elements. Therefore, Option D is
correct. If length was changed to size, Option B would compile if put in the blank. Option A still wouldn’t compile in the blank because a cast would be needed to store the value in str.
13. D. Option A is tricky, but incorrect. While a lambda can have zero parameters, a Predicate cannot. A Predicate is defined as a type mapping to a boolean. Option B is
clearly incorrect as -> separates the parts of a lambda. Options C and D are similar. Option C is incorrect because return is only allowed when the brackets are present. Option D is
correct.
14. A. Lines 20–22 create an ArrayList with two elements. Line 23 replaces the second one with a new value. Now chars is [a, c]. Then line 24 removes the first element, making it
just [c]. Option A is correct because there is only one element, but it is not the value b.

15. D. Trick question. There is no reverse method on the String class. There is one on the StringBuilder class. Therefore, the code does not compile, and Option D is correct.
16. A. When creating a lambda with only one parameter, there are a few variants. The pred1
approach shows the shortest way, where the type is omitted and the parentheses are omitted. The pred2 approach is similar except it includes the parentheses. Both are legal. The
pred4 approach is the long way with both the parentheses and type specified. The only one that doesn’t compile is pred3. The parentheses are required if including the type.
17. A. This is a correct example of code that uses a lambda. The interface has a single abstract method. The lambda correctly takes one double parameter and returns a boolean. This
matches the interface. The lambda syntax is correct. Since 45 is greater than 5, Option A is correct.
18. A. Since String is immutable, each call to concat() returns a new object with the new value. However, that return value is ignored and the teams variable never changes in value.
Therefore it stays as 694, and Option A is correct.
19. A. The ArrayList class is in the java.util package, making I correct. The LocalDate class is in the java.time package, making II incorrect. The String class is in the
java.lang package, which means you can use it without typing an import, making III incorrect. Therefore, Option A is correct.
20. C. Option A is straightforward and outputs radical robots. Option B does the same in a convoluted manner. First Option B removes all the characters after the first one. It
doesn’t matter that there aren’t actually 100 characters to delete. Then it appends obots to the end, making the builder contain robots. Finally, it inserts the remainder of the
string immediately after the first index. Try drawing the flow if this is hard to envision. Option D also creates the same value by inserting robots immediately after the end of
the StringBuilder. Option C is close, but it has an off-by-one error. It inserts robots after the letter l rather than after the space. This results in the value radicalrobots
followed by a space. Option C is different than the others and the correct answer.

21. A. Since we are creating the list from an array, it is a fixed size. We are allowed to change elements. At the end of this code, museums is [Art, Science]. Therefore, it contains Art,
and Option A is correct.
22. D. Options A and B are not true if the String is "deabc". Option C is not true if the String is "abcde". Option D is true in all cases.
23. D. Line 25 does not compile. On an ArrayList, the method to get the number of elements is size. The length() method is used for a String or StringBuilder.
24. B. The toString() method call doesn’t help in narrowing things down as all Java objects have that method available. The other two methods are more helpful. String is the only
type of these three to have a startsWith() method, making Option B correct. String also has the replace() method declared here. If you memorized the whole API, you might
know that StringBuilder also has a replace() method, but it requires three parameters instead of two. Please don’t memorize the API in that level of detail. We included what you
need to know in our study guide. If you do have this outside knowledge, be careful not to read into the questions!
25. B. The <> is known as the diamond operator. Here, it works as a shortcut to avoid repeating the generic type twice for the same declaration. On the right side of the expression, this
is a handy shortcut. Java still needs the type on the left side so there is something to infer. In the figure, position P is the left side and position Q is the right side. 
Therefore, Option B is correct.

26. D. The type in the lambda must match the generic declared on the Predicate. In this case, that is String. Therefore, Options A and B are incorrect. While Option C is of the correct
type, it uses the variable s, which is already in use from the main() method parameter. Therefore, none of these are correct, and Option D is the answer.
27. A. A String is immutable so a different object is returned on line 6. The object anotherLine points to is of length 2 after line 6 completes. However, the original line
reference still points to an object of length 1. Therefore, Option A is correct.
28. C. While it is common for a Predicate to have a generic type, it is not required. However, it is treated like a Predicate of type Object if the generic type is missing. Since
startsWith() does not exist on Object, the first line does not compile, and Option C is correct.
29. B. LocalDate only includes the date portion and not the time portion. There is no class named LocalTimeStamp. The other two, LocalDateTime and LocalTime, both include the
time elements, making Option B correct.
30. D. Line 4 creates a String of length 5. Since String is immutable, line 5 creates a new String with the value 1 and assigns it to builder. Remember that indexes in Java begin
with 0, so the substring() method is taking the values from the fifth element through the end. Since the first element is the last element, there’s only one character in there. Then line
6 tries to retrieve the second indexed element. Since there is only one element, this gives a StringIndexOutOfBoundsException, and Option D is correct.

31. D. When you’re using brackets, both the return keyword and semicolon are needed for the lambda to compile, making Option D correct.
32. B. Java 8 date and time classes are immutable. The plusDays method returns a LocalDate object presenting Christmas Eve (December 24th). However, this return value is ignored.
The xmas variable still represents the original value, so Option B is correct.
33. A. Line 3 creates an empty StringBuilder. Line 4 adds three characters to it. Line 5 removes the first character, resulting in ed. Line 6 deletes the characters starting at position
1 and ending right before position 2, which removes the character at index 1, which is d. The only character left is e, so Option A is correct.
34. B. While it is common for a Predicate to have a generic type, it is not required. When the generic is omitted, it is treated like a Predicate of type Object. Since the equals()
method exists on Object, this is fine. Option B is correct because the Predicate tests as false.

35. C. In Java, most things use zero-based indexes, including arrays and a String. Months are an exception to this convention starting Java 8. This makes the answer either Option C or
D. However, LocalTime does not contain date fields, so it has to be Option C.
36. C. Predicate is an interface with one method. The method signature is boolean test(T t). Option C is the answer because the method accepts one parameter rather than two.
37. B. Be careful here. The Period class uses a static helper method to return the period. It does not chain method calls, so period1 only represents three days. Since three days is less
than 10 days, period2 is larger, and Option B is correct.
38. B. The code starts by correctly creating a date representing January 1, 2017, and a period representing one day. It then explicitly defines the format as month followed by day
followed by year. Finally, the code subtracts a day, giving us the formatted version of December 31, 2016.
39. C. The trim() method returns a String with all leading and trailing white space removed. In this question, that’s the seven-character String: ":) - (:". Options A and B are
incorrect because they do not remove the first blank space in happy. Option D is incorrect because it does not remove the last character in happy. Therefore, Option C is correct.
40. C. The Period class creates immutable objects and is usually used to add/subtract from a LocalDate or LocalDateTime object. It allows creating date, week, month, or year periods.
Since it cannot be used for time, Option C is the answer.

41. D. Line 4 creates a StringBuilder of length 5. Pay attention to the substring() method StringBuilder. It returns a String with the value 321. It does not change the
StringBuilder itself. Then line 6 is retrieving the second indexed element from that unchanged value, which is 4. Therefore, Option D is correct.
42. B. This one is tricky. There are two remove() methods available on ArrayList. One removes an element by index and takes an int parameter. The other removes an element
by value. Due to the generics, it takes an Integer parameter in this example. Since the int primitive is a better match, the element with index 2 is removed, which is the value of 1.
Therefore, Option B is correct.
43. C. ArrayList has a size() method rather than a length() method, making Option A incorrect. The charAt() and length() methods are declared on both String and
StringBuilder. However, the insert() method is only declared on a StringBuilder and not a String. Therefore, Option C is correct.
44. C. The minusNanos and plusNanos are the smallest units available, making Option C correct. Option D is incorrect because LocalTime is not that granular. Note that while you can
add milliseconds by adding many nanoseconds, there isn’t a method for it. A millisecond is also larger than a nanosecond. Finally, don’t be tricked by the fact that LocalTime is immutable.
You can still add time; it just gets returned as a different object.

45. D. When creating a formatter object, remember that MM represents month while mm represents minute. Since there are not minutes defined on a LocalDate object, the code throws
an UnsupportedTemporalTypeException. You don’t need to know the name of the exception, but you do need to know that an exception is thrown.
46. D. There are two signatures for the replace() method. One takes two char parameters. The other signature takes a CharSequence. Both String and StringBuilder implement
this interface. This makes all three alternatives correct, and Option D is correct.
47. C. Pay attention to the data types. The print() method is looping through a list of String objects. However, the Predicate expects an Integer. Since these don’t match, the if
statement does not compile.
48. D. Line 12 creates an empty ArrayList. While it isn’t recommended to use generics on only the left side of the assignment operator, this is allowed. It just gives a warning. Lines
13 and 14 add two elements. Line 15 resets to an empty ArrayList. Line 16 adds an element, so now we have an ArrayList of size 1. Line 17 attempts to remove the element
at index 1. Since Java uses zero-based indexes, there isn’t an element there and the code throws an IndexOutOfBoundsException.
49. C. The declaration of witch is incorrect. It tries to store a char into a String variable reference. This does not compile, making Option C correct. If this was fixed, the answer
would be Option B.
50. C. The Java 8 date and time classes are immutable. This means they do not contain setter methods and the code does not compile.



---------------- HOT TOPICS -----------------------------

========================== Creating a String ==========================
String a = "";  a += 2;  a += 'c'; a += false; Result: 2cfalse

String s1 = "Computer-";  String s2 = "Science-";   String s3 = s1.concat(s2);
String s4 = "Portal";     String s5 = s3.concat(s4);
System.out.println(s5); Result: Computer-Science-Portal
        

FUNCTIONS:
         01. length() 02. charAt() 03. indexOf() 
         04. substring() 
                  Ex: 
                  String string = "animals";
                  System.out.println(string.substring(3)); // mals
                  System.out.println(string.substring(string.indexOf('m'))); // mals
                  System.out.println(string.substring(3, 4)); // m
         05. replace() Ex:String result = lowercase.replace('a', 'A');
         06. contains()
         07. equals() and equalsIgnoreCase()
                  Ex:
                  System.out.println("abc".equals("ABC")); // false
                  System.out.println("ABC".equals("ABC")); // true
                  System.out.println("abc".equalsIgnoreCase("ABC")); // true
         08. startsWith() and endsWith()
         09. toLowerCase() and toUpperCase 
         10. trim()


========================== Creating a StringBuilder ==========================
Functions:
         01. length() 02. charAt() 03. indexOf() 04. substring() 
         05. append() 06. insert() (Ex: sb.insert(7, "-");)
         07. delete() and deleteCharAt() Ex: sb.delete(1, 3); sb.deleteCharAt(5); // throws an exception
         08. reverse() 09. toString()=to get a string representation of an object.


There are three ways to construct a StringBuilder:
         StringBuilder sb1 = new StringBuilder();
         StringBuilder sb2 = new StringBuilder("animal");
         StringBuilder sb3 = new StringBuilder(10);

4: StringBuilder a = new StringBuilder("abc");
5: StringBuilder b = a.append("de");
6: b = b.append("f").append("g");
7: System.out.println("a=" + a);
8: System.out.println("b=" + b);

againStrings[0] = new StringBuilder(); // DOES NOT COMPILE
objects[0] = new StringBuilder(); // careful!

========================== Array =================================
-Fixed-size -Can not Add/Insert, Edit, and Delete once declared/initialized.

FUNCTIONS:--
       01. length 02. Arrays.sort() 03. Arrays.binarySearch()

String[] birds = new String[6];
System.out.println(birds.length);

int[] numbers = {2,4,6,8};
System.out.println(Arrays.binarySearch(numbers, 2)); // 0

String[] numbers = { "10", "9", "100" };
Arrays.sort(numbers);
Arrays.binarySearch(numbers, 2)

========================== ArrayList ==========================
-Java Class and mutable
-Can Add/Insert, Edit, and Delete once declared/initialized.

FUNCTIONS: 
         01. add()       02. get()       
         03. set()       04. size()
         05. contains()  06. equals()
         07. remove()    08. removeOf()
         09. clear()     10. isEmpty() 
         10. data.toArray();
         11. Arrays.asList()
                Ex: String[] array = {"Natural History", "Science"};
                    List<String> museums = Arrays.asList(array);

There are 3 ways to create an ArrayList:--
         ArrayList list1 = new ArrayList();
         ArrayList list2 = new ArrayList(10);
         ArrayList list3 = new ArrayList(list2);












-
