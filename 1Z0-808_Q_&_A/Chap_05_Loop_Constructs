Medium Easy.


==================== কিছু প্রশ্ন: ==========================

** যদি আমি Loop-এর  বিষয়গুলো না জানি, তাহলে আমি কী কী সমস্যার সম্মুখীন হব?
** কম্পিউটার প্রোগ্রামিংয়ে লুপের কি কোনো বিকল্প আছে?

১.  একটি Array-এর প্রতিটি সংখ্যাকে প্রিন্ট করার জন্য লুপ ব্যবহার না করলে আপনাকে কী করতে হবে? 
    আপনি কীভাবে ১ থেকে ১০০ পর্যন্ত সংখ্যাগুলোর যোগফল বের করবেন?
২.  যদি আপনাকে ব্যবহারকারীর কাছ থেকে ইনপুট নিতে হয় যতক্ষণ না সে "exit" লেখে, লুপ ছাড়া আপনি এটি কীভাবে করবেন?

### জ্ঞানের পরিধি যাচাইয়ের জন্য:
* "বিভিন্ন ধরণের লুপ (যেমন `for`, `while`, `do-while`) এবং কন্ডিশনাল কনস্ট্রাক্ট (`if`, `else if`, `switch`) এর মধ্যে মূল পার্থক্যগুলো কী এবং কখন কোনটি ব্যবহার করা সবচেয়ে উপযুক্ত?"
* "আপনি কি লুপ এবং কন্ডিশনাল কনস্ট্রাক্টের নেস্টেড (nested) ব্যবহারের জটিলতা এবং সম্ভাব্য সমস্যাগুলো সম্পর্কে কিছু আলোকপাত করতে পারবেন?"
* "কোড রিড্যাবিলিটি এবং মেইনটেন্যাবিলিটির দৃষ্টিকোণ থেকে, লুপ এবং কন্ডিশনাল লজিক লেখার সর্বোত্তম অনুশীলনগুলো কী কী বলে আপনি মনে করেন?"



==========================================================================================================
This chapter covers essential Java loop constructs including:
1. - while loops
2. - do-while loops
3. - traditional for loops
4. - enhanced for-each loops
5. - Loop control statements (break and continue)
6. - Nested loops and labeled loops

## Key Differences to Remember
1. while vs do-while:
2. Traditional for vs Enhanced for:
3. break vs continue:
4. Labeled Control:


## Key Concepts to Master

### 1. Loop Types and Characteristics

| লুপের ধরণ       | মূল বৈশিষ্ট্য                                 | কখন শর্ত পরীক্ষা করা হয়          | সর্বনিম্ন কতবার চলবে |
|-----------------|------------------------------------------|----------------------------------|--------------------|
| while           | Boolean Condition প্রবেশের নিয়ন্ত্রণ করে      | প্রথম পুনরাবৃত্তির(Repetation) আগে  | ০                  |
| do-while        | Boolean Condition পুনরাবৃত্তি নিয়ন্ত্রণ করে     | প্রথম পুনরাবৃত্তির পরে                | ১                  |
| Traditional for | ৩টি অংশ সহ Counter-Based কাউন্টার-ভিত্তিক  | প্রতিটি পুনরাবৃত্তির আগে             | ০                  |
| Enhanced for    | Collection/Array-এর মাধ্যমে পুনরাবৃত্তি করে   | অন্তর্নিহিত                         | ০                  |

### 2. Loop Control Statements
- break: Exits the current loop immediately
- continue: Skips current iteration and proceeds to next
- Labeled statements: Control outer loops from nested structures

### 3. Important Syntax Rules
- All segments in traditional for loop are optional:
  for(;;) {}  // Valid infinite loop
- Enhanced for loop syntax:
  for(Type var : collection) {}
- do-while requires semicolon after condition:
  do {} while(condition);

## Exam Preparation Strategy

1. Loop Behavior Analysis:
   - Trace execution flow through different loop types
   - Predict number of iterations
   - Identify infinite loops

2. Control Statement Usage:
   - Understand break vs continue
   - Know how labeled statements work
   - Recognize proper placement of semicolons

3. Loop Equivalency:
   - Convert between while and for loops
   - Recognize when enhanced for can replace traditional for
   - Understand limitations of enhanced for (no index access)

4. Common Pitfalls:
   - Missing semicolon in do-while
   - Using == instead of equals() in String comparisons
   - Modifying loop variables incorrectly
   - Off-by-one errors in loop conditions

## Key Differences to Remember

1. while vs do-while:
   - do-while guarantees at least one execution
   - while may execute zero times

2. Traditional for vs Enhanced for:
   - Enhanced for simpler but less flexible
   - Traditional for allows index access and reverse iteration

3. break vs continue:
   - break exits the loop entirely
   - continue skips to next iteration

4. Labeled Control:
   - Can break/continue specific outer loops
   - Labels must precede the loop declaration

By mastering these concepts and practicing similar questions, you'll be well-prepared for exam questions on Java loops. Pay special attention to:
- Loop initialization and termination conditions
- Proper use of loop control statements
- Behavior differences between loop types
- Common syntax mistakes




================================== Chapter_05(Using Loop Constructs) ====================================

1,3,8,10,13,23,24,26,30,33,34,37,38, 47,49=15


6,*16,21,*23,*24,26,28,*30,**31,33,34,35,*38,39,*40,41,43,47,48 = 19


1. Which type of loop is best known for its boolean condition that controls entry to the loop?
        A. do-while loop
        B. for (traditional)
        C. for-each
        D. while
        
2. Which type of loop is best known for using an index or counter?
        A. do-while loop
        B. for (traditional)
        C. for-each
        D. while
        
3. Which type of loop is guaranteed to have the body execute at least once?
        A. do-while loop
        B. for (traditional)
        C. for-each
        D. while
        
4. Which of the following can loop through an array without referring to the elements by  index?
        A. do-while loop
        B. for (traditional)
        C. for-each
        D. while
        
5. What keyword is used to end the current loop iteration and proceed execution with the next  iteration of that loop?
        A. break
        B. continue
        C. end
        D. skip
        
6. What keyword is used to proceed with execution immediately after a loop?
        A. break
        B. continue
        C. end
        D. skip
        
7. Which type of loop has three segments within parentheses?
        A. do-while loop
        B. for (traditional)
        C. for-each
        D. while
        
        
8. Which of the following statements is/are true?
        I. A traditional for loop can iterate through an array starting from index 0.
        II. A traditional for loop can iterate through an array starting from the end.
        A. Only I
        B. Only II
        C. Both statements
        D. Neither statement
        
9. Which of the following statements is/are true?
        I. A for-each loop can iterate through an array starting from index 0.
        II. A for-each loop can iterate through an array starting from the end.
        A. Only I
        B. Only II
        C. Both statements
        D. Neither statement
        
10. Which type of loop has a boolean condition that is first checked after a single iteration through the loop?
        A. do-while loop
        B. for (traditional)
        C. for-each
        D. while
        
11. What does the following code output?
        int singer = 0;
        while (singer)
        System.out.println(singer++);
        A. 0
        B. The code does not compile.
        C. The loops complete with no output.
        D. This is an infinite loop.
        
12. What does the following code output?
        List<String> drinks = Arrays.asList("can", "cup");
        for (int container = drinks.size() - 1; container >= 0; container--)
        System.out.print(drinks.get(container) + ",");
        A. can,cup,
        B. cup,can,
        C. The code does not compile.
        D. None of the above
        
        
        
13. What does the following code output?
        public static void main(String[] args) {
        List<String> bottles = Arrays.asList("glass", "plastic");
        for (int type = 0; type < bottles.size();) {
        System.out.print(bottles.get(type) + ",");
        break;
        }
        System.out.print("end");
        }
        A. glass,end
        B. glass,plastic,end
        C. The code does not compile.
        D. None of the above
        
14. What does the following code output?
        String letters = "";
        while (letters.length() != 2)
        letters+="a";
        System.out.println(letters);
        A. aa
        B. aaa
        C. The loops complete with no output.
        D. This is an infinite loop.
        
15. What is the result of the following when run with java peregrine. TimeLoop September 3 1940?
        package peregrine;
        public class TimeLoop {
        public static void main(String[] args) {
        for (int i = args.length; i>=0; i++)
        System.out.println("args");
        }
        }
        A. args
        B. argsargs
        C. The code does not compile.
        D. None of the above
        
        
16. What is the output of the following code?
        package chicago;
        public class Loop {
        private static int count;
        private static String[] stops = new String[] { "Washington", "Monroe", "Jackson", "LaSalle" };
        public static void main(String[] args) {
        while (count < stops.length) {
        if (stops[count++].length() < 8) {
        break;
        }
        }
        System.out.println(count);
        }
        }
        A. 1
        B. 2
        C. 4
        D. The code does not compile.
        
17. What is the result of the following code?
        do {
        int count = 0;
        do {
        count++;
        } while (count < 2);
        break;
        } while (true);
        System.out.println(count);
        A. 2
        B. 3
        C. The code does not compile.
        D. This is an infinite loop.
        
18. Which of the following segments of a for loop can be left blank?
        for (segmentA; segmentB; segmentC) {     }
        A. segmentA
        B. segmentB
        C. segmentC
        D. All of the above
        
19. How many of the loop types (while, do while, traditional for, and enhanced for) allow you to write code that creates an infinite loop?
        A. One
        B. Two
        C. Three
        D. Four
        
20. What is the output of the following?
        List<String> drinks = Arrays.asList("can", "cup");
        for (int container = 0; container < drinks.size(); container++)
        System.out.print(drinks.get(container) + ",");
        A. can,cup,
        B. cup,can,
        C. The code does not compile.
        D. None of the above
        
21. What happens when running the following code?
        do (
        System.out.println("helium");
        ) while (false);
        A. It completes successfully without output.
        B. It outputs helium once.
        C. It keeps outputting helium.
        D. The code does not compile.
        
22. Which of the following is equivalent to this code snippet given an array of String objects?
        for (int i=0; i<fun.length; i++)
        System.out.println(fun[i]);
        A. for (String f = fun) System.out.println(f);
        B. for (String f : fun) System.out.println(f);
        C. for (String = fun) System.out.println(it);
        D. None of the above
        
        
23. How many of these statements can be inserted after the println to have the code flow follow the arrow in this diagram?
        break;
        break letters;
        break numbers;

   ->   letters: for (char ch=ˈaˈ; ch<=ˈzˈ; ch++) {
  |     numbers: for (int n=0; n<=10; n++) {
  |     System.out.println(ch);
  |_____
        }
        }
        A. None
        B. One
        C. Two
        D. Three
        
24. Using the diagram in the previous question, how many of these statements can be inserted
        after the println to have the code flow follow the arrow in the diagram?
        continue;
        continue letters;
        continue numbers;
        A. None
        B. One
        C. Two
        D. Three
        
25. What does the following code output?
        int singer = 0;
        while (singer > 0)
        System.out.println(singer++);
        A. 0
        B. The code does not compile.
        C. The loops completes with no output.
        D. This is an infinite loop.
        
26. Which of the following types is taxis not allowed to be in order for this code to compile?
        for (Object obj : taxis) {   } 
        A. ArrayList<Integer>
        B. int[]
        C. StringBuilder
        D. All of these are allowed.
        
27. What is the output of the following?
        boolean balloonInflated = false;
        do {
        if (!balloonInflated) {
        balloonInflated = true;
        System.out.print("inflate-");
        }
        } while (! balloonInflated);
        System.out.println("done");
        A. done
        B. inflate-done
        C. The code does not compile.
        D. This is an infinite loop.
        
28. What does the following code output?
        String letters = "";
        while (letters.length() != 3)
        letters+="ab";
        System.out.println(letters);
        A. ab
        B. abab
        C. The loop completes with no output.
        D. This is an infinite loop.
        
29. What describes the order in which the three expressions appear in a for loop?
        A. boolean conditional, initialization expression, update statement
        B. initialization expression, boolean conditional, update statement
        C. initialization expression, update statement, boolean conditional
        D. None of the above
        
30. What is the result of the following?
        int count = 10;
        List<Character> chars = new ArrayList<>();
        do {
        chars.add('a');
        for (Character x : chars) count -=1;
        } while (count > 0);
        System.out.println(chars.size());
        A. 3
        B. 4
        C. The code does not compile.
        D. None of the above
        
31. What is the result of the following?
        int k = 0;
        for (int i = 10; i > 0; i--) {
        while (i > 3) i -= 3;
        k += 1;
        }
        System.out.println(k);
        A. 1
        B. 2
        C. 3
        D. 4
        
32. Which of the following is equivalent to this code snippet given an array of String objects?
        for (int i=fun.length-1; i>=0; i--)
        System.out.println(fun[i]);
        A. for (String f = fun) System.out.println(f);
        B. for (String f : fun) System.out.println(f);
        C. for (String f fun) System.out.println(it);
        D. None of the above
        
33. What does the following code output?
        public static void main(String[] args) {
        List<String> bottles = Arrays.asList("glass", "plastic");
        for (int type = 0; type < bottles.size();)
        System.out.print(bottles.get(type) + ",");
        break;
        System.out.print("end");
        }      
        
        A. glass,end
        B. glass,plastic,end
        C. The code does not compile.
        D. None of the above
        
34. What is the result of the following?
        String[] nycTourLoops = new String[] { "Downtown", "Uptown", "Brooklyn" };
        String[] times = new String[] { "Day", "Night" };
        for (int i = 0, j = 0; i < nycTourLoops.length && j < times.length; i++; j++){
        System.out.print(nycTourLoops[i] + " " + times[j] + "-");
        }
        A. Downtown Day
        B. Downtown Day-Uptown Night
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.
        
35. What is the result of the following when run with java peregrine.TimeLoop September 3 1940?
        package peregrine;
        public class TimeLoop {
        public static void main(String[] args) {
        for (int i = args.length; i>=0; i--)
        System.out.println(args[i]);
        }
        }
        A. September
        B. 1940
        C. The code does not compile.
        D. None of the above
        
36. What is the output of the following?
        public class Shoelaces {
        public static void main(String[] args) {
        String tie = null;
        while (tie == null)
        tie = "shoelace";
        System.out.print(tie);
        }
        }
        
        A. null
        B. shoelace
        C. shoelaceshoelace
        D. None of the above
        
37. The following code outputs a single letter x. What happens if you remove lines 25 and 28?
        23: String race = "";
        24: loop:
        25: do {
        26: race += "x";
        27: break loop;
        28: } while (true);
        29: System.out.println(race);
        A. It prints an empty string.
        B. It still outputs a single letter x.
        C. It no longer compiles.
        D. It becomes an infinite loop.
        
38. What is the output of the following code?
        package chicago;
        public class Loop {
        private static int count;
        private static String[] stops = new String[] { "Washington", "Monroe", "Jackson", "LaSalle" };
        public static void main(String[] args) {
        while (count < stops.length) {
        if (stops[count++].length() < 8) {
        continue;
        }
        }
        System.out.println(count);
        }
        }
        A. 1
        B. 2
        C. 4
        D. The code does not compile.
        
39. What is the output of the following?
        StringBuilder builder = new StringBuilder();
        String str = new String("Leaves growing");
        do {
        System.out.println(str);
        } while (builder);
        System.out.println(builder);
        A. Leaves growing
        B. This is an infinite loop.
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.
        
40. What is the result of the following code?
        6: int count = 0;
        7: do {
        8: do {
        9: count++;
        10: } while (count < 2);
        11: break;
        12: } while (true);
        13: System.out.println(count);
        A. 2
        B. 3
        C. The code does not compile.
        D. This is an infinite loop.
        
41. Fill in the blank so this code compiles and does not cause an infinite loop.
        t: while (true) {
        f: while(true) { 
                ________
        }
        }
        A. break;
        B. break f;
        C. break t;
        D. None of the above
        
        
42. What is the result of the following?
        String[] nycTourLoops = new String[] { "Downtown", "Uptown", "Brooklyn" };
        String[] times = new String[] { "Day", "Night" };
        for (int i = 0, j = 0; i < nycTourLoops.length && j < times.length; i++, j++){
                System.out.print(nycTourLoops[i] + " " + times[j] + "-");
        }
        A. Downtown Day
        B. Downtown Day-Uptown Night
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.
        
43. How many lines does the following code output?
        import java.util.*;
        public class Exams {
        public static void main(String[] args) {
        List<String> exams = Arrays.asList("OCA", "OCP");
        for (String e1 : exams)
        for (String e2 : exams)
        System.out.println(e1 + " " + e2);
        }
        }
        A. One
        B. Four
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.
        
44. Which of the following best describes the flow of execution in this for loop if beta always returns false?
        for (alpha; beta; gamma) {
          delta;
        }
        A. alpha
        B. alpha, beta
        C. alpha, beta, gamma
        D. None of the above

45. Which of the following best describes the flow of execution in this for loop if the loop body is run exactly once?
        for (alpha; beta; gamma) {
        delta;
        }
        A. alpha, delta, gamma, beta
        B. alpha, beta, delta, gamma, beta
        C. alpha, delta, gamma, alpha, beta
        D. alpha, beta, delta, gamma, alpha, beta
        
46. Which of the following iterates a different number of times than the others?
        A. for (int k=0; k < 5; k++) {}
        B. for (int k=1; k <= 5; k++) {}
        C. int k=0; do { } while(k++ < 5)
        D. int k=0; while (k++ < 5) {}
        
47. What is the output of the following?
        public class Shoelaces {
        public static void main(String[] args) {
        String tie = null;
        while (tie == null);
        tie = "shoelace";
        System.out.print(tie);
        }
        }
        A. null
        B. shoelace
        C. shoelaceshoelace
        D. None of the above
        
48. What is the output of the following?
        12: int result = 8;
        13: for: while (result > 7) {
        14: result++;
        15: do {
        16: result--;
        17: } while (result > 5);
        18: break for;
        19: }
        20: System.out.println(result);
        
        A. 5
        B. 8
        C. The code does not compile.
        D. The code compiles but throws an exception at runtime.
        
49. What is the output of the following?
        boolean baloonInflated = false;
        do {
        if (!baloonInflated) {
        baloonInflated = true;
        System.out.print("inflate-");
        }
        } while (baloonInflated);
        System.out.println("done");
        A. done
        B. inflate-done
        C. The code does not compile.
        D. This is an infinite loop.
        
50. Which of the following can fill in the blank to have the code compile successfully?
        package nyc;
        public class TouristBus {
        public static void main(String... args) {
        String[] nycTourLoops = new String[] { "Downtown", "Uptown", "Brooklyn" };
        String[] times = new String[] { "Day", "Night" };
        for ( __ i < 1; i++, j++)
        System.out.println(nycTourLoops[i] + " " + times[j]);
        }
        }
        A. int i=0; j=0;
        B. int i=0, j=0;
        C. int i=0; int j=0;
        D. int i=0, int j=0;


=================================== Answers ==============================================

1.D, 2.B, 3.A, 4.C, 5.B,
6.A, 7.B, 8.C, 9.A,10.A,

11.B, 12.B, 13.A, 14.A, 15.D, 
16.B, 17.C, 18.D, 19.C, 20.A,

21.D, 22.B, 23.C, 24.B, 25.C, 
26.C, 27.B, 28.D, 29.B, 30.B, 

31.A, 32.D, 33.C, 34.C, 35.D, 
36.B, 37.C, 38.C, 39.C, 40.A, 

41.C, 42.B, 43.B, 44.B, 45.B, 
46.C, 47.D, 48.C, 49.D, 50.B,



১. ডি. একটি while লুপের একটি শর্ত থাকে যা একটি বুলিয়ান মান ফেরত দেয় যা লুপটিকে নিয়ন্ত্রণ করে। এটি লুপের শুরুতে থাকে এবং লুপে প্রবেশের আগে পরীক্ষা করা হয়। সুতরাং, অপশন ডি সঠিক। একটি ঐতিহ্যবাহী for লুপেরও একটি বুলিয়ান শর্ত থাকে যা লুপে প্রবেশের আগে পরীক্ষা করা হয়। তবে, এটি একটি কাউন্টার ভেরিয়েবল থাকার জন্য সবচেয়ে বেশি পরিচিত, যা অপশন বি কে ভুল করে। অপশন এ ভুল কারণ do-while লুপের বুলিয়ান শর্ত লুপের শেষে থাকে। অপশন সি ভুল কারণ লুপ কনস্ট্রাক্টের অংশ হিসেবে কোনো শর্ত নেই।
২. বি. একটি ঐতিহ্যবাহী for লুপ লুপের অগ্রগতির সাথে সাথে একটি লুপ ভেরিয়েবল গণনা করা বা কমানোর জন্য সবচেয়ে বেশি পরিচিত। সুতরাং, অপশন বি সঠিক। অপশন এ এবং ডি ভুল কারণ do-while এবং while লুপ তাদের বুলিয়ান শর্তের জন্য পরিচিত। অপশন সি ভুল কারণ for-each লুপ কোনো ইনডেক্স ছাড়াই পুনরাবৃত্তি করে।
৩. এ. একটি do-while লুপ লুপের বডি নির্বাহের পরে লুপের শর্ত পরীক্ষা করে। এটি নিশ্চিত করে যে এটি সর্বদা অন্তত একবার নির্বাহ করা হয় এবং অপশন এ সঠিক। অপশন বি ভুল কারণ আপনি এমন লুপ লিখতে পারেন যা লুপের বডিতে কখনোই প্রবেশ করে না, যেমন for (int i=0;i<1;i++)। একইভাবে, অপশন ডি ভুল কারণ একটি while লুপ লেখা যেতে পারে যেখানে প্রাথমিক লুপের শর্ত মিথ্যা। অপশন সি ভুল কারণ একটি for-each লুপ একটি খালি লিস্টের উপর পুনরাবৃত্তি করার সময় লুপের বডিতে প্রবেশ করে না।
৪. সি. যদিও একটি ঐতিহ্যবাহী for লুপ প্রায়শই একটি অ্যারের মাধ্যমে লুপ করে, তবে এটি ইনডেক্স ব্যবহার করে, যা অপশন বি কে ভুল করে। for-each লুপ প্রতিটি উপাদানের মধ্য দিয়ে যায় এবং এটিকে একটি ভেরিয়েবলে সংরক্ষণ করে। অপশন সি সঠিক।
৫. বি. continue কীওয়ার্ড লুপের বর্তমান পুনরাবৃত্তি অবিলম্বে শেষ করতে এবং পরবর্তী পুনরাবৃত্তি থেকে নির্বাহ পুনরায় শুরু করতে ব্যবহৃত হয়। সুতরাং, অপশন বি সঠিক। অপশন এ ভুল কারণ break স্টেটমেন্ট লুপের বডির পরে নির্বাহ চালিয়ে যেতে বাধ্য করে। অপশন সি এবং ডি ভুল কারণ এগুলো জাভাতে কোনো কীওয়ার্ড নয়।

৬. এ. break কীওয়ার্ড লুপের বর্তমান পুনরাবৃত্তি অবিলম্বে শেষ করতে, লুপের অবশিষ্ট যেকোনো নির্বাহ এড়িয়ে যেতে এবং লুপের ঠিক পরে নির্বাহ পুনরায় শুরু করতে ব্যবহৃত হয়। সুতরাং, অপশন এ সঠিক। অপশন বি ভুল কারণ continue এর জন্য নির্বাহ বর্তমান লুপের পরবর্তী নির্বাহে চলে যায়। অপশন সি এবং ডি ভুল কারণ এগুলো জাভাতে কোনো কীওয়ার্ড নয়।
৭. বি. একটি ঐতিহ্যবাহী for লুপ একটি ইনিশিয়ালাইজেশন স্টেটমেন্ট, একটি কন্ডিশন স্টেটমেন্ট এবং একটি আপডেট স্টেটমেন্ট থাকার জন্য সবচেয়ে বেশি পরিচিত। অপশন বি সঠিক।
৮. সি. একটি ঐতিহ্যবাহী for লুপের মাধ্যমে, আপনি কোডে ইনডেক্সগুলো যে ক্রমে দেখা হয় তা নিয়ন্ত্রণ করতে পারেন। এর মানে হল আপনি একটি অ্যারের মাধ্যমে ঊর্ধ্বক্রম বা নিম্নক্রমে লুপ করতে পারেন এবং অপশন সি সঠিক।
৯. এ. একটি for-each লুপের মাধ্যমে, লুপের ক্রম আপনার জন্য নির্ধারিত হয়। একটি অ্যারের ক্ষেত্রে, এর মানে হল ইনডেক্স 0 থেকে শুরু করা এবং অপশন এ সঠিক। একটি ঐতিহ্যবাহী for লুপ আপনাকে ক্রম নিয়ন্ত্রণ করতে এবং উভয় ক্রমে পুনরাবৃত্তি করতে দেয়।
১০. এ. একটি do-while লুপের শেষে একটি বুলিয়ান মান ফেরত দেওয়ার শর্ত থাকে। সুতরাং, অপশন এ সঠিক। অপশন ডি ভুল কারণ একটি while লুপের শুরুতে এই শর্ত থাকে। একটি ঐতিহ্যবাহী for লুপ একটি লুপ ভেরিয়েবল থাকার জন্য সবচেয়ে বেশি পরিচিত, যা অপশন বি কে ভুল করে। অপশন সি ভুল কারণ লুপ কনস্ট্রাক্টের অংশ হিসেবে কোনো শর্ত নেই।

১১. বি. একটি while লুপের একটি বুলিয়ান শর্ত প্রয়োজন। যদিও singer একটি ভেরিয়েবল, এটি বুলিয়ান নয়। সুতরাং, কোডটি কম্পাইল হবে না এবং অপশন বি সঠিক।
১২. বি. এটি একটি ArrayList বা List এর শেষ থেকে শুরু করে প্রথম ইনডেক্স পর্যন্ত যাওয়ার জন্য একটি সঠিক লুপ। এটি লিস্টের শেষ ইনডেক্স থেকে শুরু হয় এবং লিস্টের প্রথম ইনডেক্স পর্যন্ত যায়। অপশন বি সঠিক।
১৩. এ. লুপের প্রথমবার, ইনডেক্স 0 এবং glass আউটপুট হয়। break স্টেটমেন্ট তারপর লুপের সমস্ত অবশিষ্ট নির্বাহ এড়িয়ে যায় এবং main() মেথড শেষ হয়। যদি break কীওয়ার্ড না থাকত, তবে এটি একটি অসীম লুপ হত কারণ কোনো ইনক্রিমেন্টর নেই।
১৪. এ. letters ইনিশিয়ালাইজ হওয়ার সাথে সাথেই লুপের শর্ত পরীক্ষা করা হয়। letters ভেরিয়েবলের দৈর্ঘ্য 0, যা 2 এর সমান নয়, তাই লুপে প্রবেশ করা হয়। লুপের বডিতে, letters দৈর্ঘ্য 1 হয় এবং "a" ধারণ করে। লুপের ইনডেক্স আবার পরীক্ষা করা হয় এবং এখন 1 2 এর সমান নয়। লুপে প্রবেশ করা হয় এবং letters দৈর্ঘ্য 2 হয় এবং "aa" ধারণ করে। তারপর লুপের ইনডেক্স আবার পরীক্ষা করা হয়। যেহেতু দৈর্ঘ্য এখন 2, লুপটি সম্পন্ন হয় এবং aa আউটপুট হয়। অপশন এ সঠিক।
১৫. ডি. প্রোগ্রামে তিনটি আর্গুমেন্ট পাস করা হয়েছে। এর মানে হল লুপের প্রথম পুনরাবৃত্তিতে i এর মান 3। প্রোগ্রাম args প্রিন্ট করে। তারপর i 4 এ বৃদ্ধি পায়। যা 0 এর চেয়ে বড় বা সমান। যেহেতু i কখনোই ছোট হয় না, তাই এই কোডটি একটি অসীম লুপ তৈরি করে এবং উত্তর হল অপশন ডি।

১৬. বি. যেহেতু count একটি ক্লাস ভেরিয়েবল যা বিশেষভাবে ইনিশিয়ালাইজ করা হয়নি, তাই এটি ডিফল্টভাবে 0 থাকে। লুপের প্রথম পুনরাবৃত্তিতে, "Washington" এর দৈর্ঘ্য 11 এবং count 1 এ সেট করা হয়। if স্টেটমেন্টের বডি রান করে না। তারপর লুপ পরবর্তী পুনরাবৃত্তিতে চলে যায়। এইবার, পোস্ট-ইনক্রিমেন্ট অপারেটর count কে 2 এ সেট করার আগে ইনডেক্স 1 ব্যবহার করে। "Monroe" পরীক্ষা করা হয়, যার দৈর্ঘ্য মাত্র 6। break স্টেটমেন্ট নির্বাহকে লুপের পরে পাঠায় এবং 2 আউটপুট হয়। অপশন বি সঠিক।
১৭. সি. প্রথমে এই কোডটিকে একটি অসীম লুপ মনে হতে পারে। তবে, count ভেরিয়েবলটি লুপের ভিতরে ঘোষণা করা হয়েছে। লুপের পরে যেখানে println() দ্বারা এটি উল্লেখ করা হয়েছে সেখানে এর কোনো স্কোপ নেই। সুতরাং, কোডটি কম্পাইল হবে না এবং অপশন সি সঠিক।
১৮. ডি. একটি for লুপের তিনটি অংশই খালি থাকতে পারে। প্রকৃতপক্ষে, for(;;) {} একটি অসীম লুপ।
১৯. সি. একটি for-each ব্যবহার করে অসীম লুপ তৈরি করা সম্ভব নয় কারণ এটি কেবল একটি অ্যারে বা ArrayList এর মাধ্যমে লুপ করে। অন্যান্য প্রকারগুলো অসীম লুপের অনুমতি দেয়, যেমন, do { } while(true), for(;;) এবং while(true)। সুতরাং, অপশন সি সঠিক। এবং হ্যাঁ, আমরা জানি যে আপনার নিজস্ব কাস্টম Iterable তৈরি করে for-each দিয়ে একটি অসীম লুপ তৈরি করা সম্ভব। তবে এটি OCA বা OCP পরীক্ষায় নেই। যদি আপনি মনে করেন উত্তর অপশন ডি, তবে এটি বাস্তব পরীক্ষায় কী পড়া উচিত নয় তার একটি দুর্দান্ত অনুস্মারক!
২০. এ. এটি শুরু থেকে একটি ArrayList বা List এর মাধ্যমে যাওয়ার জন্য একটি সঠিক লুপ। এটি ইনডেক্স 0 থেকে শুরু হয় এবং লিস্টের শেষ ইনডেক্স পর্যন্ত যায়। অপশন এ সঠিক।

২১. ডি. যদি লুপের ভিতরে কেবল একটি স্টেটমেন্ট থাকে তবে ব্র্যাকেট ঐচ্ছিক। তবে লুপের বডির চারপাশে বন্ধনী ব্যবহার করার অনুমতি নেই, তাই কোডটি কম্পাইল হবে না এবং অপশন ডি সঠিক।
২২. বি. for-each লুপ ভেরিয়েবল এবং কোলন সিনট্যাক্স ব্যবহার করে, যা অপশন বি কে সঠিক করে।
২৩. সি. ধরা যাক, আমরা একটি ব্যাংকিং লেনদেন প্রক্রিয়াকরণ সিস্টেম তৈরি করছি। 
        এই সিস্টেমে বিভিন্ন শাখা (branch) এবং প্রতিটি শাখার অধীনে বিভিন্ন অ্যাকাউন্ট (account) রয়েছে। 
        আমাদের একটি নির্দিষ্ট শাখা ("Downtown") এবং একটি নির্দিষ্ট অ্যাকাউন্ট ("123456") খুঁজে বের করে একটি লেনদেন (transaction) সম্পন্ন করতে হবে।
       
       String targetBranch = "Downtown"; // আমাদের লক্ষ্য শাখা
        String targetAccount = "123456"; // আমাদের লক্ষ্য অ্যাকাউন্ট
        double transactionAmount = 100.0; // লেনদেনের পরিমাণ

        branches: for (String branch : getListOfBranches()) { // বিভিন্ন শাখার উপর লুপ
            System.out.println("লেনদেন প্রক্রিয়াকরণ হচ্ছে শাখা: " + branch);
            accounts: for (String accountNumber : getAccountsInBranch(branch)) { // প্রতিটি শাখার অ্যাকাউন্টের উপর লুপ
                System.out.println("  অ্যাকাউন্ট পরীক্ষা করা হচ্ছে: " + accountNumber);

                // লক্ষ্য অ্যাকাউন্ট খুঁজে বের করা এবং লেনদেন প্রক্রিয়া করার অনুকরণ
                if (branch.equals(targetBranch) && accountNumber.equals(targetAccount)) {
                    System.out.println("    লক্ষ্য অ্যাকাউন্ট পাওয়া গেছে: " + accountNumber + ", শাখা: " + branch);
                    processTransaction(accountNumber, transactionAmount);
                    break branches; // লক্ষ্য অ্যাকাউন্ট খুঁজে পাওয়া এবং লেনদেন সম্পন্ন হওয়ার পরে,
                                    // আমরা 'branches' লুপ থেকে সম্পূর্ণভাবে বের হয়ে যেতে পারি
                }
                // অন্যান্য অ্যাকাউন্টের জন্য লেনদেন প্রক্রিয়াকরণের লজিক (যদি থাকে)
                // ...
            }
            // শাখার জন্য অতিরিক্ত প্রক্রিয়াকরণ (যদি থাকে)
            // ...
        }
        
        এই চিত্রে, আমরা ভেতরের লুপটি শেষ করতে এবং letters লেবেলে নির্বাহ পুনরায় শুরু করতে চাই। 
        এর মানে হল আমরা কেবল ভেতরের লুপ থেকে বের হতে চাই। একটি break স্টেটমেন্ট ঠিক তাই করে। 
        এটি বর্তমান লুপটি শেষ করে এবং লুপের ঠিক পরে নির্বাহ পুনরায় শুরু করে, যা break; কে সঠিক উত্তর করে তোলে। 
        break numbers; স্টেটমেন্ট স্পষ্টভাবে কোন লুপটি শেষ করতে হবে তা বলে, যা একই কাজ করে, এটিকে সঠিক করে তোলে। 
        বিপরীতে, break letters; বাইরের লুপটি শেষ করে, যার ফলে কোডটি কেবল একবার println() রান করে। 
        সুতরাং, দুটি স্টেটমেন্ট সঠিকভাবে ডায়াগ্রামের সাথে মেলে এবং অপশন সি সঠিক।
২৪. বি. এই চিত্রে, আমরা ভেতরের লুপটি শেষ করতে এবং letters লেবেলে নির্বাহ পুনরায় শুরু করতে চাই। 
        continue letters; স্টেটমেন্ট তাই করে। অন্য দুটি স্টেটমেন্ট ভেতরের লুপে নির্বাহ পুনরায় শুরু করে। 
        সুতরাং, কেবল দ্বিতীয় স্টেটমেন্টটি সঠিকভাবে ডায়াগ্রামের সাথে মেলে এবং অপশন বি সঠিক।
২৫. সি. একটি while লুপ লুপে প্রবেশের আগে বুলিয়ান শর্ত পরীক্ষা করে। এই কোডে, সেই শর্তটি মিথ্যা, তাই লুপের বডি কখনোই রান করে না। কোনো আউটপুট তৈরি হয় না এবং অপশন সি সঠিক।

২৬. সি. একটি for-each লুপ অ্যারে এবং ArrayList অবজেক্টের সাথে ব্যবহার করার অনুমতি দেওয়া হয়। StringBuilder এই লুপের জন্য অনুমোদিত টাইপ নয়, তাই অপশন সি উত্তর।
২৭. বি. এটি একটি সঠিক do-while লুপ। লুপের প্রথম পুনরাবৃত্তিতে, if স্টেটমেন্ট নির্বাহ হয় এবং inflate- প্রিন্ট করে। তারপর লুপের শর্ত পরীক্ষা করা হয়। balloonInflated ভেরিয়েবলটি true, তাই লুপের শর্ত false এবং লুপটি সম্পন্ন হয়।
২৮. ডি. letters ইনিশিয়ালাইজ হওয়ার সাথে সাথেই লুপের শর্ত পরীক্ষা করা হয়। letters ভেরিয়েবলের দৈর্ঘ্য 0, যা 3 এর সমান নয়, তাই লুপে প্রবেশ করা হয়। লুপের বডিতে, letters দৈর্ঘ্য 2 হয় এবং "ab" ধারণ করে। লুপের ইনডেক্স আবার পরীক্ষা করা হয় এবং এখন 2 3 এর সমান নয়। লুপে প্রবেশ করা হয় এবং letters দৈর্ঘ্য 4 হয় এবং "abab" ধারণ করে। তারপর লুপের ইনডেক্স আবার পরীক্ষা করা হয়। যেহেতু দৈর্ঘ্য 4 3 এর সমান নয়, তাই লুপের বডি আবার প্রবেশ করে। এটি 6, 8, 10 ইত্যাদির জন্য পুনরাবৃত্তি হয়। লুপটি কখনোই শেষ হয় না এবং অপশন ডি সঠিক।
২৯. বি. একটি for লুপে, অংশগুলো হল একটি ইনিশিয়ালাইজেশন এক্সপ্রেশন, একটি বুলিয়ান কন্ডিশনাল এবং সেই ক্রমে একটি আপডেট স্টেটমেন্ট। সুতরাং, অপশন বি সঠিক।
৩০. বি.
পুনরাবৃত্তি ১: chars ['a'] হয়। ভেতরের লুপ একবার চলে এবং count 10 - 1 = 9 হয়।
পুনরাবৃত্তি ২: chars ['a', 'a'] হয়। ভেতরের লুপ দুবার চলে এবং count 9 - 2 = 7 হয়।
পুনরাবৃত্তি ৩: chars ['a', 'a', 'a'] হয়। ভেতরের লুপ তিনবার চলে এবং count 7 - 3 = 4 হয়।
পুনরাবৃত্তি ৪: chars ['a', 'a', 'a', 'a'] হয়। ভেতরের লুপ চারবার চলে এবং count 4 - 4 = 0 হয়।
লুপের শর্ত count > 0 এখন মিথ্যা, তাই লুপটি শেষ হয়। সুতরাং, অপশন বি সঠিক।

৩১. এ. বাইরের লুপের প্রথম পুনরাবৃত্তিতে,
পুনরাবৃত্তি	i (লুপের শুরুতে)	While লুপ (i)	i (While এর পরে)	k (ইনক্রিমেন্টের আগে)	k (ইনক্রিমেন্টের পরে)
১	১০	১০, ৭, ৪	১	০	১
২	৯	৯, ৬, ৩	৩	১	২
৩	৮	৮, ৫, ২	২	২	৩
৪	৭	৭, ৪, ১	১	৩	৪
৫	৬	৬, ৩	৩	৪	৫
৬	৫	৫, ২	২	৫	৬
৭	৪	৪, ১	১	৬	৭
৮	৩	(কিছু না)	৩	৭	৮
৯	২	(কিছু না)	২	৮	৯
১০	১	(কিছু না)	১	৯	১০

Export to Sheets
৩২. ডি. অপশন এ এবং সি কম্পাইল হবে না কারণ তারা for-each লুপের সঠিক সিনট্যাক্স ব্যবহার করে না। for-each লুপ কেবল ঊর্ধ্বক্রমে একটি অ্যারের মাধ্যমে যেতে পারে। এটি ক্রম নিয়ন্ত্রণ করতে পারে না, যা অপশন সি কে ভুল করে। সুতরাং, অপশন ডি উত্তর।
৩৩. সি. যেহেতু for স্টেটমেন্টের চারপাশে কোনো ব্র্যাকেট নেই, তাই লুপের বডি কেবল এক লাইন। break স্টেটমেন্ট লুপের ভিতরে নেই। যেহেতু break একটি মেথডের টপ লেভেলে ব্যবহার করা যায় না, তাই কোডটি কম্পাইল হবে না এবং অপশন সি সঠিক।
৩৪. সি. একাধিক আপডেট এক্সপ্রেশন সেমিকোলন নয়, কমা দিয়ে আলাদা করা হয়। কঠিন, আমরা জানি। তবে এটি একটি গুরুত্বপূর্ণ পার্থক্য। এটি অপশন সি কে সঠিক করে।
৩৫. ডি. প্রোগ্রামে তিনটি আর্গুমেন্ট পাস করা হয়েছে। এর মানে হল লুপের প্রথম পুনরাবৃত্তিতে i এর মান 3। প্রোগ্রাম args[3] প্রিন্ট করার চেষ্টা করে। যেহেতু জাভাতে ইনডেক্স শূন্য-ভিত্তিক, তাই এটি একটি ArrayIndexOutOfBoundsException থ্রো করে।

৩৬. বি. লুপের শর্ত প্রথমবার পরীক্ষা করার সময়, tie ভেরিয়েবলটি null থাকে। লুপের বডি নির্বাহ হয়, tie সেট করে। ইন্ডেন্টেশন সত্ত্বেও, লুপের বডির চারপাশে কোনো ব্র্যাকেট নেই তাই প্রিন্ট এখনও রান করে না। তারপর লুপের শর্ত পরীক্ষা করা হয় এবং tie আর null নয়। লুপের পরে প্রিন্ট রান করে এবং একবার shoelace প্রিন্ট করে, যা অপশন বি কে সঠিক করে।
৩৭. সি. কোডটি যেমন আছে তেমনই কম্পাইল হয়। তবে, আমাদের জিজ্ঞাসা করা হয়নি যে কোডটি যেমন আছে তেমনই কম্পাইল হয় কিনা। লাইন ২৭ একটি লুপ লেবেল উল্লেখ করে। লেবেলটি এখনও উপস্থিত থাকলেও, এটি আর কোনো লুপকে নির্দেশ করে না। এর ফলে কোডটি কম্পাইল হবে না এবং অপশন সি সঠিক।
৩৮. সি. এখানে continue স্টেটমেন্টটি অপ্রয়োজনীয় কারণ লুপের পরে এড়িয়ে যাওয়ার মতো আর কোনো কোড নেই। continue স্টেটমেন্টটি কেবল লুপের পরবর্তী পুনরাবৃত্তিতে নির্বাহ পুনরায় শুরু করে, যা if-then স্টেটমেন্টটি খালি থাকলে ঘটবে। সুতরাং, অ্যারের প্রতিটি উপাদানের জন্য count বৃদ্ধি পায়। কোডটি 4 আউটপুট করে এবং অপশন সি সঠিক।
৩৯. সি. একটি do-while লুপের একটি বুলিয়ান শর্ত প্রয়োজন। builder ভেরিয়েবলটি একটি StringBuilder এবং বুলিয়ান নয়। কোডটি কম্পাইল হবে না এবং অপশন সি সঠিক।
৪০. এ. প্রথমে এই কোডটিকে একটি অসীম লুপ মনে হতে পারে। তবে, একটি break স্টেটমেন্ট রয়েছে। লাইন ৬ এ, count 0 এ সেট করা হয়। লাইন ৯ এ, এটি 1 এ পরিবর্তিত হয়। তারপর লাইন ১০ এর শর্তটি রান করে। count 2 এর চেয়ে কম তাই ভেতরের লুপ চলতে থাকে। তারপর ভেতরের লুপের পরবর্তী পুনরাবৃত্তিতে count 2 এ সেট করা হয়। লাইন ১০ এর লুপের শর্তটি আবার রান করে এবং এইবার মিথ্যা হয়। ভেতরের লুপটি সম্পন্ন হয়। তারপর বাইরের লুপের লাইন ১১ রান করে এবং নির্বাহকে লাইন ১৩ তে লুপের পরে পাঠায়। এই সময়ে count এখনও 2, তাই অপশন এ সঠিক।

৪১. সি. অপশন এ ভেতরের লুপ থেকে বের হয়, কিন্তু বাইরের লুপটি এখনও অসীম। অপশন বি এরও একই সমস্যা। অপশন সি সঠিক কারণ এটি উভয় লুপ থেকে বের হয়।
৪২. বি. এই কোডটি সঠিক। এটি দুটি ভেরিয়েবল ইনিশিয়ালাইজ করে এবং শর্ত পরীক্ষা এবং আপডেট স্টেটমেন্ট উভয় ক্ষেত্রেই ভেরিয়েবল দুটি ব্যবহার করে। যেহেতু এটি উভয় অ্যারের আকার সঠিকভাবে পরীক্ষা করে, তাই এটি উপাদানের প্রথম দুটি সেট প্রিন্ট করে এবং অপশন বি সঠিক।
৪৩. বি. একই লিস্টের মাধ্যমে একাধিকবার লুপ করার অনুমতি দেওয়া হয়। বাইরের লুপ দুবার নির্বাহ হয়। ভেতরের লুপ বাইরের লুপের প্রতিটি পুনরাবৃত্তির জন্য দুবার নির্বাহ হয়। সুতরাং, ভেতরের লুপ চারবার নির্বাহ হয় এবং অপশন বি সঠিক।
৪৪. বি. ইনিশিয়ালাইজার, যা alpha, প্রথমে রান করে। তারপর জাভা লুপের নির্বাহ শুরু করা উচিত কিনা তা দেখার জন্য শর্ত, যা beta, পরীক্ষা করে। যেহেতু beta মিথ্যা ফেরত দেয়, তাই লুপে কখনোই প্রবেশ করা হয় না এবং অপশন বি সঠিক।
৪৫. বি. ইনিশিয়ালাইজার, যা alpha, প্রথমে রান করে। তারপর জাভা লুপের নির্বাহ শুরু করা উচিত কিনা তা দেখার জন্য শর্ত, যা beta, পরীক্ষা করে। তারপর লুপের বডি, যা delta, রান করে। লুপের নির্বাহের পরে, আপডেটার, যা gamma, রান করে। তারপর লুপের শর্ত, যা beta, আবার পরীক্ষা করা হয়। সুতরাং, অপশন বি সঠিক।

৪৬. সি. অপশন এ পুনরাবৃত্তিতে পাঁচটি ইনডেক্সের মাধ্যমে যায়: 0, 1, 2, 3 এবং 4। অপশন বি ও পাঁচটি ইনডেক্সের মাধ্যমে যায়: 1, 2, 3,4 এবং 5। অপশন ডি ও 0 থেকে 4 পর্যন্ত পাঁচটি পুনরাবৃত্তির মাধ্যমে যায়। তবে, অপশন সি ছয়টি পুনরাবৃত্তির মাধ্যমে যায় যেহেতু লুপের শর্ত লুপের শেষে থাকে। সুতরাং এটি অন্যদের মতো নয় এবং অপশন সি উত্তর।
৪৭. ডি. লুপের শর্ত প্রথমবার পরীক্ষা করার সময়, tie ভেরিয়েবলটি null থাকে। তবে, শর্তের ঠিক পরে সেমিকোলন থাকার কারণে লুপের বডি খালি থাকে। এর মানে হল লুপের শর্তটি চলতে থাকে tie সেট করার কোনো সুযোগ ছাড়াই। সুতরাং, এটি একটি অসীম লুপ এবং অপশন ডি সঠিক।
৪৮. সি. প্রবাহ ট্র্যাক করার জন্য সময় নষ্ট করার আগে মৌলিক ত্রুটিগুলো সন্ধান করতে ভুলবেন না। এই ক্ষেত্রে, লুপের লেবেলটি for কীওয়ার্ড ব্যবহার করার চেষ্টা করছে। এটি অনুমোদিত নয়, তাই কোডটি কম্পাইল হবে না। যদি লেবেলটি বৈধ হত, তবে অপশন এ সঠিক হত।
৪৯. ডি. লুপের প্রথম পুনরাবৃত্তিতে, if স্টেটমেন্ট inflate- প্রিন্ট করে নির্বাহ করে। তারপর লুপের শর্ত পরীক্ষা করা হয়। baloonInflated ভেরিয়েবলটি true, তাই লুপের শর্ত true এবং লুপ চলতে থাকে। if স্টেটমেন্ট আর রান করে না, তবে ভেরিয়েবলটি আর কখনো তার অবস্থা পরিবর্তন করে না, তাই লুপটি শেষ হয় না।
৫০. বি. একটি for লুপে, টাইপটি কেবল একবার নির্দিষ্ট করার অনুমতি দেওয়া হয়। কমা একাধিক ভেরিয়েবলকে আলাদা করে কারণ তারা একই স্টেটমেন্টের অংশ। সুতরাং, অপশন বি সঠিক।










1. D. A while loop has a condition that returns a boolean that controls the loop. It appears at the beginning and is checked before entering the loop. Therefore, Option D
is correct. A traditional for loop also has a boolean condition that is checked before entering the loop. However, it is best known for having a counter variable, making
Option B incorrect. Option A is incorrect because the boolean condition on a do-while loop is at the end of the loop. Option C is incorrect because there is no condition as part of the loop construct.
2. B. A traditional for loop is best known for having a loop variable counting up or down as the loop progresses. Therefore, Option B is correct. Options A and D are incorrect because
do-while and while loops are known for their boolean conditions. Option C is incorrect because the for-each loop iterates through without an index.
3. A. A do-while loop checks the loop condition after execution of the loop body. This ensures it always executes at least once, and Option A is correct. Option B is incorrect
because there are loops you can write that do not ever enter the loop body, such as for (int i=0;i<1;i++). Similarly, Option D is incorrect because a while loop can be
written where the initial loop condition is false. Option C is incorrect because a for-each loop does not enter the loop body when iterating over an empty list.
4. C. While a traditional for loop often loops through an array, it uses an index to do so, making Option B incorrect. The for-each loop goes through each element, storing it in a
variable. Option C is correct.
5. B. The continue keyword is used to end the loop iteration immediately and resume execution at the next iteration. Therefore, Option B is correct. Option A is incorrect because
the break statement causes execution to proceed after the loop body. Options C and D are incorrect because these are not keywords in Java.

6. A. The break keyword is used to end the loop iteration immediately, skip any remaining executions of the loop, and resume execution immediately after the loop. Therefore, Option A is
correct. Option B is incorrect because execution proceeds at the next execution of the current loop for continue. Options C and D are incorrect because these are not keywords in Java.
7. B. A traditional for loop is best known for having an initialization statement, condition statement, and update statement. Option B is correct.
8. C. With a traditional for loop, you control the order in which indexes are visited in code. This means you can loop through an array in ascending or descending order, and Option C is correct.
9. A. With a for-each loop, the loop order is determined for you. With an array, this means starting with index 0, and Option A is correct. A traditional for loop allows you to control
the order and iterate in either order.
10. A. A do-while loop has a condition that returns a boolean at the end of the loop. Therefore, Option A is correct. Option D is incorrect because a while loop has this condition at
the beginning of the loop. A traditional for loop is best known for having a loop variable, making Option B incorrect. Option C is incorrect because there is no condition as part of
the loop construct.

11. B. A while loop requires a boolean condition. While singer is a variable, it is not a boolean. Therefore, the code does not compile, and Option B is correct.
12. B. This is a correct loop to go through an ArrayList or List starting from the end. It starts with the last index in the list and goes to the first index in the list. Option B is correct.
13. A. The first time through the loop, the index is 0 and glass, is output. The break statement then skips all remaining executions on the loop and the main() method ends. 
If there was no break keyword, this would be an infinite loop because there’s no incrementor.
14. A. Immediately after letters is initialized, the loop condition is checked. The variable letters is of length 0, which is not equal to 2 so the loop is entered. In the loop body,
letters becomes length 1 with contents "a". The loop index is checked again and now 1 is not equal to 2. The loop is entered and letters becomes length 2 and contains "aa". Then
the loop index is checked again. Since the length is now 2, the loop is completed and aa is output. Option A is correct.
15. D. There are three arguments passed to the program. This means that i is 3 on the first iteration of the loop. The program prints args. Then i is incremented to 4. Which is also
greater than or equal to 0. Since i never gets smaller, this code produces an infinite loop and the answer is Option D.

16. B. Since count is a class variable that isn’t specifically initialized, it defaults to 0. On the first iteration of the loop, "Washington", is 11 characters and count is set to 1. The if
statement’s body is not run. The loop then proceeds to the next iteration. This time, the post-increment operator uses index 1 before setting count to 2. "Monroe" is checked, which
is only 6 characters. The break statement sends the execution to after the loop and 2 is output. Option B is correct.
17. C. At first this code appears to be an infinite loop. However, the count variable is declared inside the loop. It is not in scope after the loop where it is referenced by the println().
Therefore, the code does not compile, and Option C is correct.
18. D. A for loop is allowed to have all three segments left blank. In fact, for(;;) {} is an infinite loop.
19. C. It is not possible to create an infinite loop using a for-each because it simply loops through an array or ArrayList. The other types allow infinite loops, such as, for example,
do { } while(true), for(;;) and while(true). Therefore, Option C is correct. And yes, we know it is possible to create an infinite loop with for-each by creating your own
custom Iterable. This isn’t on the OCA or OCP exam though. If you think the answer is Option D, this is a great reminder of what not to read into on the real exam!
20. A. This is a correct loop to go through an ArrayList or List starting from the beginning. It starts with index 0 and goes to the last index in the list. Option A is correct.

21. D. Braces are optional around loops if there is only one statement. Parentheses are not allowed to surround a loop body though, so the code does not compile, and Option D is correct.
22. B. The for-each loop uses a variable and colon as the syntax, making Option B correct.
23. C. In this figure, we want to end the inner loop and resume execution at the letters label. This means we only want to break out of the inner loop. A break statement does just that.
It ends the current loop and resumes execution immediately after the loop, making break; a correct answer. The break numbers; statement explicitly says which loop to end, which
does the same thing, making it correct as well. By contrast, break letters; ends the outer loop, causing the code only to run the println() once. Therefore, two statements correctly
match the diagram, and Option C is correct.
24. B. In this figure, we want to end the inner loop and resume execution at the letters label. The continue letters; statement does that. The other two statements resume execution
at the inner loop. Therefore, only the second statement correctly matches the diagram, and Option B is correct.
25. C. A while loop checks the boolean condition before entering the loop. In this code, that condition is false, so the loop body is never run. No output is produced, and Option C is correct.

26. C. A for-each loop is allowed to be used with arrays and ArrayList objects. StringBuilder is not an allowed type for this loop, so Option C is the answer.
27. B. This is a correct do-while loop. On the first iteration of the loop, the if statement executes and prints inflate-. Then the loop condition is checked. The variable
balloonInflated is true, so the loop condition is false and the loop completes.
28. D. Immediately after letters is initialized, the loop condition is checked. The variable letters is of length 0, which is not equal to 3, so the loop is entered. In the loop body,
letters becomes length 2 and contains "ab". The loop index is checked again and now 2 is not equal to 3. The loop is entered and letters becomes length 4 with contents "abab".
Then the loop index is checked again. Since the length 4 is not equal to 3, the loop body is entered again. This repeats for 6, 8, 10, etc. The loop never ends, and Option D is correct.
29. B. In a for loop, the segments are an initialization expression, a boolean conditional, and an update statement in that order. Therefore, Option B is correct.
30. B. 
Iteration 1: chars becomes ['a']. The inner loop runs once, and count becomes 10 - 1 = 9.
Iteration 2: chars becomes ['a', 'a']. The inner loop runs twice, and count becomes 9 - 2 = 7.
Iteration 3: chars becomes ['a', 'a', 'a']. The inner loop runs three times, and count becomes 7 - 3 = 4.
Iteration 4: chars becomes ['a', 'a', 'a', 'a']. The inner loop runs four times, and count becomes 4 - 4 = 0.
The loop condition count > 0 is now false, so the loop terminates. Therefore, Option B is correct.

31. A. On the first iteration of the outer loop, 
        Iteration	i (Start of Loop)	While Loop (i)	i (After While)	k (Before Increment)	k (After Increment)
        1	                10	        10, 7, 4	1	        0	                1
        2	                9	        9, 6, 3	        3	        1	                2
        3	                8	        8, 5, 2	        2	        2	                3
        4	                7	        7, 4, 1	        1	        3	                4
        5	                6	        6, 3	        3	        4	                5
        6	                5	        5, 2	        2	        5	                6
        7	                4	        4, 1	        1	        6	                7
        8	                3	        (None)	        3	        7	                8
        9	                2	        (None)	        2	        8	                9
        10	                1	        (None)	        1	        9	                10

32. D. Options A and C do not compile as they do not use the correct syntax for a for-each loop. The for-each loop is only able to go through an array in ascending order. It is not
able to control the order, making Option C incorrect. Therefore, Option D is the answer.
33. C. Since there are no brackets around the for statement, the loop body is only one line. The break statement is not in the loop. Since break cannot be used at the top level of a
method, the code does not compile, and Option C is correct.
34. C. Multiple update expressions are separated with a comma rather than a semicolon. Tricky, we know. But it is an important distinction. This makes Option C correct.
35. D. There are three arguments passed to the program. This means that i is 3 on the first iteration of the loop. The program attempts to print args[3]. Since indexes are zero based
in Java, it throws an ArrayIndexOutOfBoundsException.

36. B. The first time the loop condition is checked, the variable tie is null. The loop body executes, setting tie. Despite the indention, there are no brackets surrounding the loop
body so the print does not run yet. Then the loop condition is checked and tie is not null. The print runs after the loop, printing out shoelace once, making Option B correct.
37. C. The code compiles as is. However, we aren’t asked about whether the code compiles as is. Line 27 refers to a loop label. While the label is still present, it no longer points to a
loop. This causes the code to not compile, and Option C is correct.
38. C. The continue statement is useless here since there is no code later in the loop to skip. The continue statement merely resumes execution at the next iteration of the loop, which
is what would happen if the if-then statement was empty. Therefore, count increments for each element of the array. The code outputs 4, and Option C is correct.
39. C. A do-while loop requires a boolean condition. The builder variable is a StringBuilder and not a boolean. The code does not compile, and Option C is correct.
40. A. At first this code appears to be an infinite loop. However, there is a break statement. On line 6, count is set to 0. On line 9, it is changed to 1. Then the condition on line 10 runs.
count is less than 2 so the inner loop continues. Then count is set to 2 on the next iteration of the inner loop. The loop condition on line 10 runs again and this time is false. The inner
loop is completed. Then line 11 of the outer loop runs and sends execution to after the loop on line 13. At this point count is still 2, so Option A is correct.

41. C. Option A breaks out of the inner loop, but the outer loop is still infinite. Option B has the same problem. Option C is correct because it breaks out of both loops.
42. B. This code is correct. It initializes two variables and uses both variables in the condition check and the update statements. Since it checks the size of both arrays correctly, it prints
the first two sets of elements, and Option B is correct.
43. B. Looping through the same list multiple times is allowed. The outer loop executes twice. The inner loop executes twice for each of those iterations of the outer loop. Therefore, the
inner loop executes four times, and Option B is correct.
44. B. The initializer, which is alpha, runs first. Then Java checks the condition, which is beta, to see if loop execution should start. Since beta returns false, the loop is never
entered, and Option B is correct.
45. B. The initializer, which is alpha, runs first. Then Java checks the condition, which is beta, to see if loop execution should start. Then the loop body, which is delta, runs. After
the loop execution, the updater, which is gamma, runs. Then the loop condition, which is beta, is checked again. Therefore, Option B is correct.

46. C. Option A goes through five indexes on the iterations: 0, 1, 2, 3 and 4. Option B also goes through five indexes: 1, 2, 3, 4 and 5. Option D goes through five iterations as well,
from 0 to 4. However, Option C goes through six iterations since the loop condition is at the end of the loop. Therefore it is not like the others, and Option C is the answer.
47. D. The first time the loop condition is checked, the variable tie is null. However, the loop body is empty due to the semicolon right after the condition. This means the loop condition
keeps running with no opportunity for tie to be set. Therefore, this is an infinite loop, and Option D is correct.
48. C. Remember to look for basic errors before wasting time tracking the flow. In this case, the label of the loop is trying to use the keyword for. This is not allowed, so the code does
not compile. If the label was valid, Option A would be correct.
49. D. On the first iteration of the loop, the if statement executes printing inflate-. Then the loop condition is checked. The variable baloonInflated is true, so the loop condition
is true and the loop continues. The if statement no longer runs, but the variable never changes state again, so the loop doesn’t end.
50. B. In a for loop, the type is only allowed to be specified once. A comma separates multiple variables since they are part of the same statement. Therefore, Option B is correct.



========================================================================================== 
                         # Chapter Summary: Loops in Java
========================================================================================== 






===========
সমস্যা উল্লেখ করা হলো:

* পুনরাবৃত্তিমূলক কাজ: যদি আপনাকে একই কাজ একাধিকবার করতে হয় (যেমন, একটি অ্যারের প্রতিটি উপাদানের উপর কিছু অপারেশন করা, বা একটি নির্দিষ্ট লাইন ১০ বার প্রিন্ট করা), লুপ ছাড়া আপনাকে সেই কোডটি ততবার লিখতে হবে। 
        এতে কোডের পরিমাণ অনেক বেড়ে যাবে এবং কোড জটিল ও ত্রুটিপূর্ণ হওয়ার সম্ভাবনা বাড়বে।

* ডাটা স্ট্রাকচারের উপর কাজ: অ্যারে, লিস্ট বা অন্য কোনো ডাটা স্ট্রাকচারের প্রতিটি উপাদানের উপর কোনো অপারেশন (যেমন প্রিন্ট করা, যোগ করা, ফিল্টার করা) লুপ ছাড়া করা প্রায় অসম্ভব। 
        আপনাকে প্রতিটি উপাদানের জন্য আলাদা আলাদা কোড লিখতে হবে, যা অত্যন্ত সময়সাপেক্ষ এবং অব্যবহারিক।

* শর্তাধীন পুনরাবৃত্তি: অনেক ক্ষেত্রে, একটি নির্দিষ্ট কাজ কতবার করতে হবে তা আগে থেকে জানা যায় না, বরং কোনো শর্তের উপর নির্ভর করে। 
        লুপ (যেমন `while` লুপ) ছাড়া এই ধরনের পরিস্থিতি সামাল দেওয়া কঠিন।

* অ্যালগরিদমের বাস্তবায়ন: অনেক অ্যালগরিদম (যেমন সার্চিং, সর্টিং) পুনরাবৃত্তিমূলক প্রক্রিয়ার উপর নির্ভরশীল। লুপ ছাড়া এই অ্যালগরিদমগুলো বাস্তবায়ন করা সম্ভব নয়।






-

