
Date: 31(Tues)-July-2024

--------------Chaptar:01 Java Basics (07) ----------
01. Define the scope of variables 
02. Define the structure of a Java class
03. Create executable Java applications with a main method; 
04. Run a Java program from the command line; 
05. Produce console output
06. Import other Java packages to make them accessible in your code
07. Compare and contrast the features and components of Java such as platform independence, object orientation, encapsulation, etc.

==============================================================

--------------------01. Define the scope of variables----------------------------------
Here's a detailed breakdown of the scope of variables:

####### Scope of Variables

1. ----Instance Variables ----
   - Declared inside a class but outside any method, constructor, or block.
   - Created when an object of the class is created and destroyed when the object is destroyed.
   - Accessible from all methods, constructors, and blocks in the class.
   - Default values are assigned if not explicitly initialized.

2. -----Class Variables (Static Variables) ----
   - Declared with the `static` keyword inside a class but outside any method, constructor, or block.
   - Created when the program starts and destroyed when the program stops.
   - Accessible from all static and instance methods, constructors, and blocks.
   - Default values are assigned if not explicitly initialized.

3. ----Local Variables----
   - Declared inside a method, constructor, or block.
   - Created when the method, constructor, or block is entered and destroyed when it is exited.
   - Must be initialized explicitly before use as they do not have default values.
   - Scope is limited to the method, constructor, or block in which they are declared.

4. ----Parameters ----
   - Variables passed to methods, constructors, or blocks.
   - Treated as local variables within the scope of the method, constructor, or block.
   - Must be initialized explicitly before use.

###### Key Points to Remember ############

- Variable Shadowing: A local variable can have the same name as an instance or class variable, causing the local variable to shadow the other variable within its scope.
- Access Modifiers: Visibility of instance and class variables can be controlled using access modifiers (`private`, `protected`, `public`, and default).
- Final Variables: Variables declared with the `final` keyword cannot be reassigned once initialized.
- Static Context: In a static method, you cannot directly access instance variables or methods; you must use a reference to an instance of the class.
- Initialization: Local variables must be initialized before use, while instance and class variables are automatically initialized with default values if not explicitly done.



--------------------02. Define the structure of a Java class---------------------------

Basic Structure
A Java class typically consists of the following components:

###### Class Declaration: ######
   public class MyClass {
       // Class body
   }
   
   public: Access modifier indicating the class is accessible from anywhere.
   class: Keyword to define a class.
   MyClass: Name of the class.

######  Fields (Attributes): ######
   private int age;
   public String name;
   
   Data members that store the state of an object.
   Access modifiers (e.g., private, public) determine visibility.

###### Methods (Behaviors): ######
   public void greet() {
       System.out.println("Hello, " + name + "!");
   }
   
   Functions that define the actions an object can perform.
   Access modifiers (e.g., public, private) control method accessibility.
   Return type specifies the data type of the value returned by the method.

###### Constructor: ######
   - Special method used to initialize objects.
   - No return type, including void.
   - Constructor name matches the class name.

   Example:
   public class Person {
       private String name;
       private int age;
   
       public Person(String name, int age) {
           this.name = name;
           this.age = age;
       }
   
       public void   
    greet() {
           System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");   
   
       }
   }




--------------------03. Create executable Java applications with a main method; --------------
Static: method belongs to the class itself, rather than an instance of the class.
Void: (return type)method does not return any value.

What is the Main method, Why it is static and Void?
Ans: The main method: 
     - is the entry point of the Java program, 
     - declares static because it calls before any objects are created and 
     - does not return any value.

######## Example 1: Basic Structure with Main Method ########
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

######## Example 2: Using Static and Instance Methods ########
public class Example2 {
    public static void main(String[] args) {
        Example2 obj = new Example2();
        obj.instanceMethod();
        staticMethod();
    }

    public void instanceMethod() {
        System.out.println("This is an instance method.");
    }

    public static void staticMethod() {
        System.out.println("This is a static method.");
    }
}
```

######## Example 3: Constructor Overloading ########
Can a Class have multiple constructors?
If, Yes, How to call each other?
Can a constructor Overload in a same class?

public class Example3 {
    int value;

    public Example3() {
        this(10); // Calls the other constructor
    }

    public Example3(int value) {
        this.value = value;
    }

    public static void main(String[] args) {
        Example3 obj = new Example3();
        System.out.println("Value: " + obj.value);
    }
}
```

######## Example 4: Using Static Blocks ########
public class Example4 {
    static {
        System.out.println("Static block executed.");
    }

    public static void main(String[] args) {
        System.out.println("Main method executed.");
    }
}
```

######## Example 5: Final Variables and Initialization ########
public class Example5 {
    final int value;

    public Example5(int value) {
        this.value = value;
    }

    public static void main(String[] args) {
        Example5 obj = new Example5(100);
        System.out.println("Final value: " + obj.value);
    }
}
```

########  Example 6: Abstract Class and Method ########
abstract class Animal {
    abstract void sound();

    public void sleep() {
        System.out.println("Sleeping...");
    }
}

public class Example6 extends Animal {
    @Override
    void sound() {
        System.out.println("Roar");
    }

    public static void main(String[] args) {
        Example6 lion = new Example6();
        lion.sound();
        lion.sleep();
    }
}
```

######## Example 7: Interface Implementation ########
interface Printable {
    void print();
}

public class Example7 implements Printable {
    public void print() {
        System.out.println("Printing...");
    }

    public static void main(String[] args) {
        Example7 obj = new Example7();
        obj.print();
    }
}
```

######## Example 8: Inheritance and Method Overriding ########
class Parent {
    void display() {
        System.out.println("Parent class method.");
    }
}

public class Example8 extends Parent {
    @Override
    void display() {
        System.out.println("Child class method.");
    }

    public static void main(String[] args) {
        Example8 obj = new Example8();
        obj.display();
    }
}
```

########  Example 9: Try-With-Resources ########
import java.io.*;

public class Example9 {
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader("test.txt"))) {
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.out.println("An error occurred: " + e.getMessage());
        }
    }
}
```

########### Example 10: Lambda Expressions (Java 8+) ###########
Lambda expressions are a concise way to represent anonymous functions.

Key Points:
-Lambda expressions can be used to simplify code and make it more readable.
-They are often used with functional interfaces like Runnable, Comparator, and Predicate.
-Lambda expressions can be assigned to variables of functional interface types.
-They can be passed as arguments to methods that accept functional interfaces.

Benefits of Using Lambda Expressions:
-Concise syntax:  provide a shorter and more readable way to express functions.
-Functional programming style: They enable a functional programming style, leading to more declarative and expressive code.
-Improved code readability:  can make code easier to understand and maintain.
-Increased productivity: By reducing boilerplate code, lambda expressions can improve developer productivity.

Basic Structure:
(parameters) -> { body }
Parameters: A comma-separated list of parameters.
->: The arrow token separates parameters from the body.
Body: The code to be executed.

Example:
(x, y) -> x + y
This lambda expression takes two integer parameters x and y and returns their sum.

Simple Example:
import java.util.Arrays;
import java.util.List;

public class Example10 {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("one", "two", "three");
        list.forEach(item -> System.out.println(item));
    }
}

--------------- Using Lambda Expressions with Functional Interfaces:----------------
Lambda expressions can be used with functional interfaces, which are interfaces with a single abstract method.

interface MathOperation {
    int operation(int a, int b);
}

public class LambdaExample {
    public static void main(String[] args) {
        MathOperation addition = (a, b) -> a + b;
        MathOperation subtraction = (a, b) -> a - b;   

        MathOperation multiplication = (a, b) -> a * b;
        MathOperation division = (a, b) -> a / b;

        System.out.println(addition.operation(5,   
 3));
        System.out.println(subtraction.operation(5, 3));
        System.out.println(multiplication.operation(5, 3));
        System.out.println(division.operation(5, 3));
    }
}


Output:
8
2
15
1


Additional Examples:
Using a lambda expression with the "Runnable" interface:
Runnable r = () -> System.out.println("Hello from lambda!");
new Thread(r).start();

Using a lambda expression with the "Comparator" interface:
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Collections.sort(names, (s1, s2) -> s1.compareToIgnoreCase(s2));




--------------------04. Run a Java program from the command line;  ---------------------------

Running a Java program from the command line involves a few steps, including 
 -writing the Java code, 
 -compiling it with the Java compiler, and then 
 -executing the compiled bytecode with the Java Virtual Machine (JVM). 
Here's a step-by-step guide:

######## Step 1: Write Your Java Code ########
Create a Java file with your code. For example, let's write a simple "Hello, World!" program.
1. Open a text editor and write the following code:
    ```java
    public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello, World!");
        }
    }
    ```

2. Save the file as `HelloWorld.java`.
######## Step 2: Open the Command Line ########
Open the command line (Command Prompt on Windows, Terminal on macOS or Linux).

######## Step 3: Navigate to the Directory ########
Navigate to the directory where you saved the `HelloWorld.java` file. You can use the `cd` command to change directories. For example:

cd path/to/your/java/file

######## Step 4: Compile the Java Code ########
Use the `javac` command to compile your Java file. This command will generate a `HelloWorld.class` file containing the bytecode.

javac HelloWorld.java
```If there are no errors, the `HelloWorld.class` file will be created in the same directory.

######## Step 5: Run the Compiled Java Program ########
Use the `java` command to run the compiled Java program. You should specify the class name without the `.class` extension.
java HelloWorld


You should see the output: Hello, World!


########  Additional Tips ########
- **Setting Up the Environment**: Ensure that the `javac` and `java` commands are available in your PATH. You can check this by running `javac -version` and `java -version`. If not, you may need to add the JDK bin directory to your system's PATH.
- **Handling Packages**: If your Java file includes a package declaration, you need to navigate to the root directory of your package structure and use the fully qualified class name to compile and run the program.

######## Example with Package ########
1. Create a file named `com/example/HelloWorld.java` with the following content:
    ```java
    package com.example;

    public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello, World!");
        }
    }
    ```

2. Open the command line and navigate to the directory containing the `com` directory:
    cd path/to/your/java/file

3. Compile the Java file:
    javac com/example/HelloWorld.java

4. Run the compiled Java program using the fully qualified class name:
    java com.example.HelloWorld


--------------------05. Produce console output  ----------------------------------------------

Producing console output in Java is typically done using the 
01. `System.out.println()`, 
02. `System.out.print()`, and 
03. `System.out.printf()` methods. 

######## Explanation ########
- `System.out.println("...")`: Prints the string and moves to a new line.
- `System.out.print("...")`: Prints the string without moving to a new line.
- `System.out.printf("format string", args)`: Prints a formatted string. The `%n` format specifier in `printf` is used to insert a newline.


########  Example Program Using All Methods ########
Here is a full example demonstrating all three methods:

public class ConsoleOutputExample {
    public static void main(String[] args) {
        // Using System.out.println()
        System.out.println("This is an example of println.");
        System.out.println("It moves to a new line after printing.");

        // Using System.out.print()
        System.out.print("This is an example of print.");
        System.out.print(" It continues on the same line.");

        // Using System.out.printf()
        System.out.printf("%nThis is an example of printf. Name: %s, Age: %d, Score: %.2f%n", "Bob", 25, 88.75);
    }
}
```

**Output:**
This is an example of println.
It moves to a new line after printing.
This is an example of print. It continues on the same line.
This is an example of printf. Name: Bob, Age: 25, Score: 88.75




--------------------06. Import other Java packages to make them accessible in your code  ---------------------------

Importing packages 
   -allow  to use of classes and interfaces that are defined in other packages. 
   -organize and reuse code more efficiently. 
There are several ways to import packages in Java:

########  1. Importing a Single Class ######## 
To import a specific class from a package, you use the `import` statement followed by the fully qualified class name.

**Syntax:**
import packageName.ClassName;


**Example:**
import java.util.ArrayList;

public class ImportExample {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Hello");
        list.add("World");
        System.out.println(list);
    }
}
```

########  2. Importing All Classes from a Package ######## 
To import all classes and interfaces from a package, you use the `import` statement followed by the package name and a `.*`.

**Syntax:**
import packageName.*;

**Example:**
import java.util.*;

public class ImportExample {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Hello");
        list.add("World");
        System.out.println(list);

        HashMap<String, String> map = new HashMap<>();
        map.put("Key1", "Value1");
        map.put("Key2", "Value2");
        System.out.println(map);
    }
}
```

########  3. Importing Static Members ######## 
If you want to import static members (fields and methods) of a class, you use the `import static` statement.

**Syntax:**
import static packageName.ClassName.staticMemberName;


or to import all static members:
import static packageName.ClassName.*;


**Example:**
import static java.lang.Math.*;

public class StaticImportExample {
    public static void main(String[] args) {
        double result = sqrt(25);  // No need to write Math.sqrt()
        System.out.println("Square root of 25 is: " + result);

        double piValue = PI;  // No need to write Math.PI
        System.out.println("Value of PI is: " + piValue);
    }
}
```

######## Practical Example ########
Here is a practical example that combines various types of imports:

1. Create a package named `com.example.utils` and a class `StringUtils` inside it:
    // File: com/example/utils/StringUtils.java
    package com.example.utils;

    public class StringUtils {
        public static String reverse(String str) {
            return new StringBuilder(str).reverse().toString();
        }
    }

2. Create a main class that uses `StringUtils` from the `com.example.utils` package:
    // File: Main.java
    import com.example.utils.StringUtils;
    import java.util.*;

    public class Main {
        public static void main(String[] args) {
            String original = "Hello World";
            String reversed = StringUtils.reverse(original);

            System.out.println("Original: " + original);
            System.out.println("Reversed: " + reversed);

            ArrayList<String> list = new ArrayList<>();
            list.add("One");
            list.add("Two");
            System.out.println(list);
        }
    }

######## Compiling and Running the Code ######## 
1. Save the `StringUtils` class in the directory `com/example/utils/`.
2. Save the `Main` class in the root directory where the `com` directory is located.
3. Open the command line and navigate to the root directory.
4. Compile the `StringUtils` class:
    javac com/example/utils/StringUtils.java

5. Compile the `Main` class:
    javac Main.java

6. Run the `Main` class:
    java Main

**Output:**
Original: Hello World
Reversed: dlroW olleH
[One, Two]

--------------------07. Compare and contrast the features and components of Java such as: platform independence, object orientation, encapsulation, etc.  ---------------------------

Java is a widely-used programming language known for its powerful features and capabilities. 
Here are comparisons and contrasts of some key features and components of Java: platform independence, object orientation, and encapsulation.

######### Platform Independence ##########

----Definition:----
- **Platform Independence** means that a program written in Java can run on any device that has the Java Virtual Machine (JVM) installed, regardless of the underlying hardware and operating system.

----Features:----
- **Write Once, Run Anywhere (WORA):** Java programs are compiled into bytecode, which can be executed on any JVM. This allows the same Java program to run on different platforms without modification.
- **Java Virtual Machine (JVM):** The JVM is the key to Java's platform independence. It abstracts the underlying hardware and operating system, allowing Java bytecode to run on any device with a compatible JVM.

----Benefits:----
- **Cross-Platform Compatibility:** Developers can write a single version of their application and deploy it across multiple platforms, reducing development and maintenance costs.
- **Portability:** Java programs can easily be moved from one platform to another without needing recompilation.

----Examples:----
- A Java program developed on Windows can run on Linux or macOS without any changes to the code.

########## Object Orientation ##########

----Definition:----
- **Object Orientation** is a programming paradigm based on the concept of "objects," which can contain data (fields) and code (methods). Java is inherently an object-oriented language.

----Features:----
- **Classes and Objects:** Java uses classes to define blueprints for objects. An object is an instance of a class.
- **Inheritance:** Java allows classes to inherit properties and methods from other classes, promoting code reuse and hierarchical classification.
- **Polymorphism:** Java supports polymorphism, allowing objects to be treated as instances of their parent class, enabling flexible and reusable code.
- **Abstraction:** Java allows the creation of abstract classes and interfaces to define abstract data types, which can be implemented by concrete classes.

----Benefits:----
- **Modularity:** Object-oriented design encourages modularity, making code easier to understand, maintain, and debug.
- **Reusability:** Code can be reused through inheritance and composition, reducing redundancy and improving efficiency.
- **Flexibility and Scalability:** Object-oriented design makes it easier to scale and extend applications by adding new classes and objects.

----Examples:----
- Creating a `Vehicle` class and then extending it with `Car` and `Bike` subclasses, each having specific implementations of methods defined in `Vehicle`.

########## Encapsulation ##########

----Definition:----
- **Encapsulation** is the practice of bundling data (fields) and methods that operate on that data into a single unit or class, and restricting access to some of the object's components.

----Features:----
- **Access Modifiers:** Java uses access modifiers (private, protected, public, and default) to control the visibility and accessibility of classes, methods, and fields.
- **Getters and Setters:** Java encourages the use of getter and setter methods to access and modify private fields, ensuring data integrity and encapsulation.
- **Data Hiding:** Encapsulation hides the internal state of an object from the outside world and only exposes a controlled interface.

----Benefits:----
- **Data Protection:** By restricting direct access to an object's fields, encapsulation protects the data from unintended or harmful modifications.
- **Maintainability:** Encapsulation makes it easier to change the internal implementation of a class without affecting other parts of the program.
- **Improved Modularity:** Encapsulation helps in organizing code into distinct sections with well-defined interfaces, enhancing modularity and readability.

----Examples:----
- Defining private fields in a class and providing public getter and setter methods to access and modify those fields.

########## Comparison and Contrast ##########

1. **Platform Independence vs. Object Orientation:**
   - Platform Independence: focuses on the ability of Java programs to run on any platform with a JVM, while 
   - Object Orientation: is a programming paradigm(Concept) that organizes code around objects and classes.
   
   - Platform independence is achieved through the JVM and bytecode,  
   - whereas object orientation is achieved through language features like classes, inheritance, and polymorphism.

2. **Object Orientation vs. Encapsulation:**
   - Object Orientation: encompasses broader principles, including encapsulation, inheritance, and polymorphism. 
   - Encapsulation: is specifically about bundling data and methods and restricting access to the inner workings of objects.

   - While encapsulation is a fundamental aspect of object-oriented programming, 
     object orientation also includes other concepts like inheritance and polymorphism to promote code reuse and flexibility.

3. **Platform Independence vs. Encapsulation:**
   - Platform Independence: is a feature that ensures Java programs can run on any platform, while 
   - Encapsulation: is a programming principle that ensures internal data protection and controlled access.

   - Platform independence relates to the deployment and execution environment of Java applications, 
   - whereas encapsulation is about the design and organization of code within those applications.




-
