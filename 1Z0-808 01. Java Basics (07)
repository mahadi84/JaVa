
Date: 31-July-2024(Wednesday)

--------------Chaptar:01 Java Basics (07) ----------
01. Define the scope of variables 
02. Define the structure of a Java class
03. Create executable Java applications with a main method; 
04. Run a Java program from the command line; 
05. Produce console output
06. Import other Java packages to make them accessible in your code
07. Compare and contrast the features and components of Java such as platform independence, object orientation, encapsulation, etc.

==============================================================

######################################################################################
    --------------------01. Define the scope of variables--------------------------
######################################################################################

####### Scope of Variables
###### Key Points to Remember(Variables) 
            -Variable Shadowing        -Final Variables
            -Static Context            -Initialization


####### Scope of Variables
1. Instance Variables ----
    -Declared inside a class but outside any method, constructor, or block.
    -Created when an object of the class is created and destroyed when the object is destroyed.
    -Accessible from all methods, constructors, and blocks in the class.
    -Default values are assigned if not explicitly initialized.

2. Class Variables (Static Variables) ----
    -Declared with the `static` keyword inside a class but outside any method, constructor, or block.
    -Belongs to the class itselt, not instances.
    -Created when the program starts and destroyed when the program stops.
    -Accessible from all static and instance methods, constructors, and blocks.
    -Default values are assigned if not explicitly initialized.

3. Local Variables----
    -Declared inside a method, constructor, or block.
    -Created when the method, constructor, or block is entered and destroyed when it is exited.
    -Must be initialized explicitly before use as they do not have default values.
    -Scope is limited to the method, constructor, or block in which they are declared.

4. Parameters ----
    -Variables passed to methods, constructors, or blocks.
    -Treated as local variables within the scope of the method, constructor, or block.
    -Must be initialized explicitly before use.

###### Key Points to Remember ############
-Variable Shadowing: A local variable can have the same name as an instance or class variable, causing the local variable to shadow the other variable within its scope.
-Final Variables: Variables declared with the `final` keyword cannot be reassigned once initialized.
-Static Context: In a static method, you cannot directly access instance variables or methods; you must use a reference to an instance of the class.
-Initialization: Local variables must be initialized before use, while instance and class variables are automatically initialized with default values if not explicitly done.


######################################################################################
--------------------02. Define the structure of a Java class--------------------------
######################################################################################

###### Class Declaration
######  Fields (Attributes)
###### Methods (Behaviors)
###### Constructor


###### Class Declaration: ######
   public class MyClass {
       // Class body
   }
   
   public: Access modifier indicating the class is accessible from anywhere.
   class: Keyword to define a class.
   MyClass: Name of the class.

######  Fields (Attributes): ######
   private int age;
   public String name;
   
   Data members that store the state of an object.
   Access modifiers (e.g., private, public) determine visibility.

###### Methods (Behaviors): ######
   public void greet() {
       System.out.println("Hello, " + name + "!");
   }
   
   Functions that define the actions an object can perform.
   Access modifiers (e.g., public, private) control method accessibility.
   Return type specifies the data type of the value returned by the method.

###### Constructor: ######
   -Special method used to initialize objects.
   -No return type, including void.
   -Constructor name matches the class name.

   Example:
   public class Person {
       private String name;
       private int age;
   
       public Person(String name, int age) {
           this.name = name;
           this.age = age;
       }
   
       public void   
    greet() {
           System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");   
   
       }
   }



######################################################################################
------------03. Create executable Java applications with a main method; ------
######################################################################################

######## Example 1: Basic Structure with Main Method
######## Example 2: Using Static and Instance Methods
######## Example 3: Constructor Overloading
######## Example 4: Using Static Blocks
######## Example 5: Final Variables and Initialization
######## Example 6: Abstract Class and Method
######## Example 7: Interface Implementation
######## Example 8: Inheritance and Method Overriding
######## Example 9: Try-With-Resources
######## Example 10: Lambda Expressions (Java 8+) : Example with Functional Interfaces


Static: member (method or fields) belongs to the class itself, rather than an instance of the class.
Void: (return type)method does not return any value.

What is the Main method, Why it is static and Void?
Ans: The main method: 
     - is the entry point of the Java program, 
     - declares static because it calls before any objects are created and 
     - does not return any value.

######## Example 1: Basic Structure with Main Method ########
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

######## Example 2: Using Static and Instance Methods ########
public class Example2 {
    public static void main(String[] args) {
        Example2 obj = new Example2();
        obj.instanceMethod();
        staticMethod();
    }

    public void instanceMethod() {
        System.out.println("This is an instance method.");
    }

    public static void staticMethod() {
        System.out.println("This is a static method.");
    }
}

######## Example 3: Constructor Overloading ########
Can a Class have multiple constructors?
If, Yes, How to call each other?
Can a constructor Overload in a same class?
Can a constructor be private?
What is singleton pattern?

public class Example3 {
    int value;

    public Example3() {
        this(10); // Calls the other constructor
    }

    public Example3(int value) {
        this.value = value;
    }

    public static void main(String[] args) {
        Example3 obj = new Example3();
        System.out.println("Value: " + obj.value);
    }
}


######################################################################################
     ---------------04. Run a Java program from the command line;  --------------
######################################################################################

######## Step 1: Write Your Java Code
######## Step 2: Open the Command Line
######## Step 3: Navigate to the Directory
######## Step 4: Compile the Java Code
######## Step 5: Run the Compiled Java Program
########  Additional Tips
######## Example with Package


######## Step 1: Write Your Java Code ########
Create a Java file with your code. For example, let's write a simple "Hello, World!" program.
1. Open a text editor and write the following code:
java
    public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello, World!");
        }
    }

2. Save the file as `HelloWorld.java`.
######## Step 2: Open the Command Line ########
Open the command line (Command Prompt on Windows, Terminal on macOS or Linux).

######## Step 3: Navigate to the Directory ########
Navigate to the directory where you saved the `HelloWorld.java` file. You can use the `cd` command to change directories. For example:

cd path/to/your/java/file

######## Step 4: Compile the Java Code ########
Use the `javac` command to compile your Java file. This command will generate a `HelloWorld.class` file containing the bytecode.

javac HelloWorld.javaIf there are no errors, the `HelloWorld.class` file will be created in the same directory.

######## Step 5: Run the Compiled Java Program ########
Use the `java` command to run the compiled Java program. You should specify the class name without the `.class` extension.
java HelloWorld

You should see the output: Hello, World!


########  Additional Tips ########
-Setting Up the Environment: Ensure that the `javac` and `java` commands are available in your PATH. You can check this by running `javac -version` and `java -version`. If not, you may need to add the JDK bin directory to your system's PATH.
-Handling Packages: If your Java file includes a package declaration, you need to navigate to the root directory of your package structure and use the fully qualified class name to compile and run the program.

######## Example with Package ########
1. Create a file named `com/example/HelloWorld.java` with the following content:

    package com.example;

    public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello, World!");
        }
    }


2. Open the command line and navigate to the directory containing the `com` directory:
    cd path/to/your/java/file

3. Compile the Java file:
    javac com/example/HelloWorld.java

4. Run the compiled Java program using the fully qualified class name:
    java com.example.HelloWorld

######################################################################################
       --------------------05. Produce console output  -------------------------
######################################################################################

######## Explanation ########
########  Example Program Using All Methods ########


######## Explanation ########
-System.out.println("..."): Prints the string and moves to a new line.
-System.out.print("..."): Prints the string without moving to a new line.
-System.out.printf("format string", args): Prints a formatted string. The `%n` format specifier in `printf` is used to insert a newline.


########  Example Program Using All Methods ########
Here is a full example demonstrating all three methods:

public class ConsoleOutputExample {
    public static void main(String[] args) {
        // Using System.out.println()
        System.out.println("This is an example of println.");
        System.out.println("It moves to a new line after printing.");

        // Using System.out.print()
        System.out.print("This is an example of print.");
        System.out.print(" It continues on the same line.");

        // Using System.out.printf()
        System.out.printf("%nThis is an example of printf. Name: %s, Age: %d, Score: %.2f%n", "Bob", 25, 88.75);
    }
}

Output:
This is an example of println.
It moves to a new line after printing.
This is an example of print. It continues on the same line.
This is an example of printf. Name: Bob, Age: 25, Score: 88.75

######################################################################################
-------06. Import other Java packages to make them accessible in your code  ----------
######################################################################################

########  0. Definition of Java Packag 
########  1. Importing a Single Class 
########  2. Importing All Classes from a Package 
########  3. Importing Static Members 
######## Practical Example


Definition of Java Package: 
A package is a namespace that organizes a set of related classes and interfaces. 
It helps manage the code structure, avoid name conflicts, and control access to classes and interfaces.

Importing packages 
   -allow  to use of classes and interfaces that are defined in other packages. 
   -organize and reuse code more efficiently. 
There are several ways to import packages in Java:

########  1. Importing a Single Class ######## 
To import a specific class from a package, you use the `import` statement followed by the fully qualified class name.

Syntax:
import packageName.ClassName;


Example:
import java.util.ArrayList;

public class ImportExample {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Hello");
        list.add("World");
        System.out.println(list);
    }
}

########  2. Importing All Classes from a Package ######## 
To import all classes and interfaces from a package, you use the `import` statement followed by the package name and a `.*`.

Syntax:
import packageName.*;

Example:
import java.util.*;

public class ImportExample {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Hello");
        list.add("World");
        System.out.println(list);

        HashMap<String, String> map = new HashMap<>();
        map.put("Key1", "Value1");
        map.put("Key2", "Value2");
        System.out.println(map);
    }
}

########  3. Importing Static Members ######## 
If you want to import static members (fields and methods) of a class, you use the `import static` statement.

Syntax:
import static packageName.ClassName.staticMemberName;


or to import all static members:
import static packageName.ClassName.*;


Example:
import static java.lang.Math.*;

public class StaticImportExample {
    public static void main(String[] args) {
        double result = sqrt(25);  // No need to write Math.sqrt()
        System.out.println("Square root of 25 is: " + result);

        double piValue = PI;  // No need to write Math.PI
        System.out.println("Value of PI is: " + piValue);
    }
}

######## Practical Example ########
Here is a practical example that combines various types of imports:

1. Create a package named `com.example.utils` and a class `StringUtils` inside it:
    // File: com/example/utils/StringUtils.java
    package com.example.utils;

    public class StringUtils {
        public static String reverse(String str) {
            return new StringBuilder(str).reverse().toString();
        }
    }

2. Create a main class that uses `StringUtils` from the `com.example.utils` package:
    // File: Main.java
    import com.example.utils.StringUtils;
    import java.util.*;

    public class Main {
        public static void main(String[] args) {
            String original = "Hello World";
            String reversed = StringUtils.reverse(original);

            System.out.println("Original: " + original);
            System.out.println("Reversed: " + reversed);

            ArrayList<String> list = new ArrayList<>();
            list.add("One");
            list.add("Two");
            System.out.println(list);
        }
    }

######## Compiling and Running the Code ######## 
    1. Save the `StringUtils` class in the directory `com/example/utils/`.
    2. Save the `Main` class in the root directory where the `com` directory is located.
    3. Open the command line and navigate to the root directory.
    4. Compile the `StringUtils` class:
        javac com/example/utils/StringUtils.java

    5. Compile the `Main` class:
        javac Main.java

    6. Run the `Main` class:
        java Main

    Output:
    Original: Hello World
    Reversed: dlroW olleH
    [One, Two]

############################################################################################################################################################################
------07. Compare and contrast the features and components of Java such as: platform independence, object orientation, encapsulation, etc.  ------------
############################################################################################################################################################################

######### Platform Independence (-Definition, -Features, -Benefits, -Examples)
########## Object Orientation   (-Definition, -Features, -Benefits, -Examples)
########## Encapsulation        (-Definition, -Features, -Benefits, -Examples)
########## Comparison and Contrast 
                01. Platform Independence vs. Object Orientation:
                02. Object Orientation vs. Encapsulation:
                03. Platform Independence vs. Encapsulation:


######### Platform Independence ##########
Java is a widely-used programming language known for its powerful features and capabilities. 

Definition:----
    Platform Independence means that a program written in Java can run on any device that has the Java Virtual Machine (JVM) installed, regardless of the underlying hardware and operating system.

Features:----
    -Write Once, Run Anywhere (WORA): Java programs are compiled into bytecode, which can be executed on any JVM. This allows the same Java program to run on different platforms without modification.
    -Java Virtual Machine (JVM): The JVM is the key to Java's platform independence. It abstracts the underlying hardware and operating system, allowing Java bytecode to run on any device with a compatible JVM.

Benefits:----
    -Cross-Platform Compatibility: Developers can write a single version of their application and deploy it across multiple platforms, reducing development and maintenance costs.
    -Portability: Java programs can easily be moved from one platform to another without needing recompilation.

Examples:----
    -A Java program developed on Windows can run on Linux or macOS without any changes to the code.

########## Object Orientation ##########

Definition:----
    Object Orientation is a programming paradigm(model or approch or pattern) based on the concept of "objects," which can contain data (fields) and code (methods). Java is inherently an object-oriented language.

Features:----
    -Classes and Objects: Java uses classes to define blueprints for objects. An object is an instance of a class.
    -Inheritance: Java allows classes to inherit properties and methods from other classes, promoting code reuse and hierarchical classification.
    -Polymorphism: Java supports polymorphism, allowing objects to be treated as instances of their parent class, enabling flexible and reusable code.
    -Abstraction: Java allows the creation of abstract classes and interfaces to define abstract data types, which can be implemented by concrete classes.

Benefits:----
    -Modularity: Object-oriented design encourages modularity, making code easier to understand, maintain, and debug.
    -Reusability: Code can be reused through inheritance and composition, reducing redundancy and improving efficiency.
    -Flexibility and Scalability: Object-oriented design makes it easier to scale and extend applications by adding new classes and objects.

Examples:----
    -Creating a `Vehicle` class and then extending it with `Car` and `Bike` subclasses, each having specific implementations of methods defined in `Vehicle`.

########## Encapsulation ##########

Definition:----
   Encapsulation is the practice of bundling data (fields) and methods that operate on that data into a single unit or class, and restricting access to some of the object's components.

Features:----
    -Access Modifiers: Java uses access modifiers (private, protected, public, and default) to control the visibility and accessibility of classes, methods, and fields.
    -Getters and Setters: Java encourages the use of getter and setter methods to access and modify private fields, ensuring data integrity and encapsulation.
    -Data Hiding: Encapsulation hides the internal state of an object from the outside world and only exposes a controlled interface.

Benefits:----
    -Data Protection: By restricting direct access to an object's fields, encapsulation protects the data from unintended or harmful modifications.
    -Maintainability: Encapsulation makes it easier to change the internal implementation of a class without affecting other parts of the program.
    -Improved Modularity: Encapsulation helps in organizing code into distinct sections with well-defined interfaces, enhancing modularity and readability.

Examples:----
    -Defining private fields in a class and providing public getter and setter methods to access and modify those fields.

########## Comparison and Contrast ##########

1. Platform Independence vs. Object Orientation:
    -Platform Independence: focuses on the ability of Java programs to run on any platform with a JVM, while 
    -Object Orientation: is a programming paradigm(Concept) that organizes code around objects and classes.
    
    -Platform independence is achieved through the JVM and bytecode,  
    -whereas object orientation is achieved through language features like classes, inheritance, and polymorphism.

2. Object Orientation vs. Encapsulation:
    -Object Orientation: encompasses broader principles, including encapsulation, inheritance, and polymorphism. 
    -Encapsulation: is specifically about bundling data and methods and restricting access to the inner workings of objects.

    -While encapsulation is a fundamental aspect of object-oriented programming, 
        object orientation also includes other concepts like inheritance and polymorphism to promote code reuse and flexibility.

3. Platform Independence vs. Encapsulation:
    -Platform Independence: is a feature that ensures Java programs can run on any platform, while 
    -Encapsulation: is a programming principle that ensures internal data protection and controlled access.

    -Platform independence relates to the deployment and execution environment of Java applications, 
    -whereas encapsulation is about the design and organization of code within those applications.




-
 

 

 

 

 


