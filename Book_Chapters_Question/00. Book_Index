
==================================================================================
 OCA(1Z0-808) Oracle Certified Associate Java SE 8 Programmer I Study Guide Exam
=================================================================================


############# Chapter 1 Java Building Blocks 1 ##########################

 - Understanding the Java Class Structure 2
    - Fields and Methods 2
    - Comments 4
         // comment until end of line OR  // // cat OR /* */ */
         /* Multiple Or /** Multiple
         * line comment
         */
    - Classes vs. Files 5
          > Java does not require that the class be public.
          > If you do have a public class, it needs to match the filename.
          > at most one of the classes in the file is allowed to be public.
    - Writing a main() Method 6
          > the entry point
          > java Zoo Zoo 2 whar are these?
          > what happens if you don’t pass in enough arguments?
            Reading args[0] goes fine and Zoo is printed out.
    - Understanding Package Declarations and Imports 9
         > Java comes with thousands of built-in classes, 
            and there are countless more from developers like me.
            With all those classes, Java needs a way to organize them.
         > puts classes in packages(as like put file into folder). 
         > logical groupings for classes.
         > Package names are hierarchical like the Japanise mail
         > package names dot-separeted like a.b.c
         > if no file found, error:"Class/member cannot be resolved to a type"
    - Wildcards 10
         > Classes in the same package are often imported together. 
             I can use a shortcut to import  all the classes in a package:
         > import java.util.*; // imports java.util.Random among other things
         > compiler figures out what’s actually needed.
    - Redundant Imports 11
         > 'java.lang.' This package is special in that it is automatically imported.
         > how many of the imports do you  think are redundant?
            1: import java.lang.System;    2: import java.lang.*;
            3: import java.util.Random;    4: import java.util.*;
         > will compile without any issue
         
    - Naming Conflicts 12
          > import java.util.*;   
            import java.sql.*; // DOES NOT COMPILE
            **any one of import above with .Date will remove the error
            public class Conflicts { Date date; } //compiler error:The type Date is ambiguous
            public class Conflicts { java.sql.Date date; } //OK now.
          > What if we do import both .Date like below?
            import java.util.Date;  
            import java.sql.Date;
          Ans: When the class is found in multiple packages, Java gives you the compiler error:
               "The import java.sql.Date collides with another import statement"
    - Creating a New Package 13
         > packages to avoid naming conflicts and to reuse your code
         >C:\temp\packagea\ClassA.java
            package packagea;
            public class ClassA {    }
         >C:\temp\packageb\ClassB.java
            package packageb;
            import packagea.ClassA;
            public class ClassB {         
            ClassA a;
            }
    - Code Formatting on the Exam 16
    - Creating Objects 16
          > Our programs wouldn’t be able to do anything useful if we didn’t have the ability to create
            new objects. Remember that an object is an instance of a class.
          > All we can see/feel are objects.
    - Constructors 17
    - Reading and Writing Object Fields 18
         >Swan mother = new Swan();
          mother.numberEggs = 1; // set variable
          System.out.println(mother.numberEggs); // read variable
    - Instance Initializer Blocks 18
    - Order of Initialization 19
         > Why below code DOES NOT COMPILE?
         { System.out.println(name); } // DOES NOT COMPILE
            private String name = "Fluffy";
         > What is the output of the following code? 
         public class Egg { public Egg() { number = 5; }
            public static void main(String[] args) {
            Egg egg = new Egg();
            System.out.println(egg.number);
            }
            private int number = 3;
            { number = 4; } 
         }
         
    - Distinguishing Between Object References and Primitives 20
    - Primitive Types 20
         > byte 8-bit(-2^7_to_2^7-1) integral value 123; short 16-bit; 
         > int 32-bit; long 64-bit; 
         > float 32-bit floating-point value 123.45f; 
         > double 64-bit floating-point value 123.456; 
         > boolean ; char 16-bit Unicode value 'a'

         > long max = 3123456789; // DOES NOT COMPILE
         > long max = 3123456789L; // now Java knows it is a long

         > double annoyingButLegal = 1_00_0.0_0; // this one compiles
         > double notByDecimal = 1000_.00; // DOES NOT COMPILE
    - Reference Types 24
         > A reference can be assigned to another object of the same type.
            String greeting = "How are you?";
         > A reference can be assigned to a new object using the new keyword.
            java.util.Date today=new java.util.Date();
         > An object in memory can be accessed only via a reference.

    - Key Differences 25
         > int value = null; // DOES NOT COMPILE > String s = null;
         > String reference = "hello";
            int len = reference.length();
            int bad = len.length(); // DOES NOT COMPILE
         > primitive name lowercase. classes name start with uppercase.
    - Declaring and Initializing Variables 25
         > int i1, i2, i3 = 0; > boolean b1, b2; 
         > String s1 = "1", s2;   > double d1, double d2;
    - Declaring Multiple Variables 26
    - Identifiers 27
         > to name, including variables, methods, classes, and fields:
         > The name must begin with a letter or the symbol $ or _.
         > Subsequent characters may also be numbers.
         > You cannot use the same name as a Java reserved word. 
            Ex: __SStillOkbutKnotsonice$

    - Understanding Default Initialization of Variables 29
    - Local Variables 29
         > defined within a method, must be initialized before use
    - Instance and Class Variables 30
         > Default return type:
         > boolean false  >byte, short, int, long 0 (in the type’s bit-length)
         > float, double 0.0 (in the type’s bit-length) > char '\u0000' (NUL)
         > All object references (everything else) null
    - Understanding Variable Scope 31
         > Local variables—in scope from declaration to end of block
         > Instance variables—in scope from declaration until object garbage collected
         > Class variables—in scope from declaration until program ends
    - Ordering Elements in a Class 34
         > Package 
         > Import 
         > Class
         > Field declarations int value; No Anywhere inside a class
         > Method declarations void method() No Anywhere inside a class
    - Destroying Objects 36
         > objects are stored in program memory’s heap
         > JVM has larges heap memory but it will run out of memory eventually.
         > a garbage collector to automatically look for objects that aren’t needed/referenced anymore.
    - Garbage Collection 36
         > System.gc() is not guaranteed to run
         > An object is no longer reachable when one of two situations occurs:
           >The object no longer has any references pointing to it.
           >All references to the object have gone out of scope.
         > object first becomes eligible for garbage collection:
           public class Scope {
               public static void main(String[] args) {
               String one, two;
               one = new String("a");
               two = new String("b");
               one = two;
               String three = one;
               one = null;
               } 
            }
         Ans: one,two,three = "b"
    - finalize() 38
         > might run zero or one time. run twice = impossible.
            public class Finalizer {
               private static List objects = new ArrayList();
               protected void finalize() {
               objects.add(this); // Don't do this
               } 
            }
    - Benefits of Java 39
         > Object Oriented(allows for functional programming as well) 
         > Encapsulation 
         > Platform Independent  > Robust > Simple > Secure
    
    - Summary 40
    - Exam Essentials 41
    - Review Questions 42


############# Chapter 2 Operators and Statements 51 ##########################

- Understanding Java Operators 52
      > unary operators +, -, !, ++, --
      > Multiplication/Division/Modulus *, /, %
      > Addition/Subtraction +, -
      > Shift operators <<, >>, >>>
      > Relational operators <, >, <=, >=, instanceof
      > Equal to/not equal to ==, !=
      > Logical operators &, ^(X-OR), |
      > Short-circuit logical operators &&, ||
      > Ternary operators boolean expression ? expression1 : expression2
      > Assignment operators =, +=, -=, *=, /=, %=, &=, ^=, !=, <<=, >>=, >>>=
    - Working with Binary Arithmetic Operators 53
      > order of precedence(*, /, %, +, -)
      > int x = 2 * ((5 + 3) * 4 – 8);
      > System.out.print(11 / 3); // Outputs 3  > System.out.print(11 % 3); // Outputs 2
    - Arithmetic Operators 53
    - Numeric Promotion 55
         1. If two values have different data types, Java will automatically promote to the larger of the two data types.
               > x * y? int x = 1; long y = 33; Ans: long
               > x + y? double x = 39.21; float y = 2.1; Ans: error if not 2.1f
               > x / y? short x = 10; short y = 3; Ans: int               
         2. If one of the values is integral and the other is floating-point, automatically promote  to the floating-point.
         3. byte, short, and char are first promoted to int any time they’re used with a Java binary arithmetic operator, 
            even if neither of the operands is int.
         4. After all promotion has occurred and the operands have the same data type, 
            the resulting value will have the same data type as its promoted operands.
            > x * y / z? short x = 14; float y = 13; double z = 30; Ans: promoted to double
    - Working with Unary Operators 57
           >boolean x, y = false; x= !y;
           >double x = 1.21;
                   x = -x;  System.out.println(x); // -1.21
                   x = -x;  System.out.println(x); // 1.21
    - Logical Complement and Negation Operators 57
    - Increment and Decrement Operators 58
         > pre-increment/decrement operator, the operator is applied first and the value return is the new value. Alternatively, 
         > post-increment/decrement operator, the original value of the expression is returned, 
           operator applied after the value is returned.
         > int x = 3; int y = ++x * 5 / x-- + --x; Result: x=; y=7;
    - Using Additional Binary Operators 60
         > short x = 10; short y = 3; short z = x * y; // DOES NOT COMPILE
         > short x = 10; short y = 3; short z = (short)(x * y); //downcasting
         > long x = 10; int y = 5; y = y * x; // DOES NOT COMPILE
         > long x = 10; int y = 5; y *= x; //Why it compiles? 
         **Ans: The compound operator will first cast x to a long, apply the multiplication of two long
         values, and then cast the result to an int. 
         > long x = 5; long y = (x=3); // Ans: x=3, y=3;
    - Assignment Operators 60
         > int x = 1.0; // DOES NOT COMPILE        >int x = (int)1.0; //OK now
         > short y = 1921222; // DOES NOT COMPILE  >short y = (short)1921222; // Stored as 20678 
         > int z = 9f; // DOES NOT COMPILE         >int z = (int)9l;
         > long t = 192301398193810323; // DOES NOT COMPILE  >long t = 192301398193810323L;
    - Compound Assignment Operators 62
         > int x = 2, z = 3; x = x * z; // Simple assignment operator x *= z; // Compound assignment operator
    - Relational Operators 63
         > (<, >, <=, >=)  
         > compare to numeric primitive data types only and return a boolean value.
         > If the two numeric operands are not of the same data type, the smaller one is promoted larger one.
         > a instanceof b | answer: true/false
    - Logical Operators 64
         > (&), (|), and (^), 
         > applied to both numeric and boolean data types.
         > when applied to numeric data types, referred to as bitwise operators, 

         > Here are some tips to help remember this table: (true & true),(false | false), (true ^ false)
          1. AND is only true if both operands are true.
          2. Inclusive OR is only false if both operands are false.
          3. Exclusive OR is only true if the operands are different.
         
         > (&& and ||) conditional operators, which are often referred to as short-circuit operators. 
         > the expression may never be evaluated if the final result can be determined by the left-hand side of the expression:
               example: 
               >boolean x = true || (y < 4); // will not evaluate: (y < 4)
               >if(x != null & x.getValue() < 5) { // Throws an exception if x is null
               >int x = 6; boolean y = (x >= 6) || (++x <= 7); System.out.println(x); (as x=6)Output: 6

    - Equality Operators 65
          > (equals operator == and not equals operator !=)
         1. Comparing two numeric primitive types. If the numeric values are of different data types, 
               the values are automatically promoted as previously described. 
            For example, 5 == 5.00 returns true since the left side is promoted to a double.
         2. Comparing two boolean values.
         3. Comparing two objects, including null and String values.
    - Understanding Java Statements 66
    - The if-then Statement 67
    - The if-then-else Statement 68
         >int x = 1;if(x) { // DOES NOT COMPILE
         >int x = 1; if(x = 5) { // DOES NOT COMPILE
         >Tenary Operator:
            int x = 5; System.out.println(x > 2 ? x < 4 ? 10 : 8 : 7); Ans: 8;
            int y = 10; int x = (y > 5) ? (2 * y) : (3 * y); Ans: 20
            System.out.println((y > 5) ? 21 : "Zebra");
            int animal = (y < 91) ? 9 : "Horse"; // DOES NOT COMPILE

    - The switch Statement 72
         > complex decision-making structure in which a single value is evaluated
         > zero or more case > default and break are optional;
         >Data types supported:
            > int and Integer,  > byte and Byte,  > short and Short,  > char and Character,  
            > String,  > enum values,
         > literals, enum constants, or final with case.
            private int getSortOrder(String firstName, final String lastName) {
               String middleName = "Patricia";
               final String suffix = "JR";
               int id = 0;
               switch(firstName) {
               case "Test":
               return 52;
               case middleName: // DOES NOT COMPILE- middleName not final
               id = 5;
               break;
               case suffix:
               id = 0;
               break;
               case lastName: // DOES NOT COMPILE- final, but not constant as it is passed to the function
               id = 8;
               break;
               case 5: // DOES NOT COMPILE- not String;
               id = 7;
               break;
               case 'J': // DOES NOT COMPILE- not String;
               id = 10;
               break;
               case java.time.DayOfWeek.SUNDAY: // DOES NOT COMPILE- enum value
               id=15;
               break;
               }
               return id;
            }
    - The while Statement 76
            > terminate with a boolean expression false, 
            > continue as long as the expression evaluates to true.
            > int x = 2;  int y = 5;  while(x < 10)  y++;
    - The do-while Statement 78
            > guarantees that the statement or block will be executed at least once.
            >terminate with a boolean expression, > continue as long as the expression evaluates to true.
            >for( ; ; ) {  System.out.println("Hello World");   } //Creating an Infinite Loop
    - The for Statement 80
            > for(long y = 0, x = 4; x < 5 && y < 10; x++, y++) {
            System.out.print(y + " ");
            }
            System.out.print(x); // DOES NOT COMPILE- Variables Outside the Loop
            >int x = 0;
            for(long y = 0, x = 4; x < 5 && y < 10; x++, y++) { // DOES NOT COMPILE
            System.out.print(x + " ");
            }
    - The for-each Statement 83
            > for(datatype instance : collection) { System.out.println(instance); }
    - Understanding Advanced Flow Control 86
    - Nested Loops 87
            >int[][] myComplexArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}};
            for(int[] mySimpleArray : myComplexArray) {
                  for(int i=0; i<mySimpleArray.length; i++) {
                  System.out.print(mySimpleArray[i]+"\t");
                  }
               System.out.println();
            }
    - Adding Optional Labels 87
            > A label is an optional pointer to the head of a statement that 
               allows the application flow to jump to it or break from it. 
               int[][] myComplexArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}};
               OUTER_LOOP: for(int[] mySimpleArray : myComplexArray) {
               INNER_LOOP: for(int i=0; i<mySimpleArray.length; i++) {
               System.out.print(mySimpleArray[i]+"\t");
               }
                  System.out.println();
               }
    - The break Statement 88
            > it will end the loop early( transfers control to the enclosing statement)
            > terminate the nearest inner loop it is currently in the process of executing. 
            The optional label parameter allows us to break out of a higher level outer loop.
            >optionalLabel: while(booleanExpression) {
               // Body
               // Somewhere in loop
               break optionalLabel;
            }

            PARENT_LOOP: for(int i=0; i<list.length; i++) {
               for(int j=0; j<list[i].length; j++) {
                  if(list[i][j]==searchValue) {
                     positionX = i;
                     positionY = j;
                  break PARENT_LOOP;
               }
            }

    - The continue Statement 90
            > it ends the current iteration of the loop.
            > boolean expression that determines if the loop should continue.
            > optionalLabel: while(booleanExpression) {
               // Body
               // Somewhere in loop
               continue optionalLabel;
            }
            int count = 0;
               ROW_LOOP: for(int row = 1; row <=3; row++)
                    for(int col = 1; col <=2 ; col++) {
                    if(row * col % 2 == 0) 
               continue ROW_LOOP;
                    count++;
               }
            System.out.println(count);
            Output: 1

    - Summary 92
    - Exam Essentials 92
    - Review Questions 94



############# Chapter 3 Core Java APIs 101 ##########################

     - Creating and Manipulating Strings 102
          > String fundamental class > with new without new
     - Concatenation 102
          > 1+2+"c"    > String s= "1"; s+="2"; s+=3; 
          > String s1= "1"; String s2= s1.concat("2");  s2.concat("3"); OUTPUT:12
     - Immutability 104
          > String is non-changeable, make non-larger or non-smaller
     - The String Pool 105
          > location in JVM that collect all strings 
          > garbage collectible 
     - Important String Methods 105
          01. charAt() 02. indexOf() 03. lastIndexOf() 04. substring()
          05. replace() 06. concat() 07. contains() 08. equals() 09. equalsIgnoreCase()
          10. startsWith()  11. endsWith()  12. toUpperCase() 13. toLowerCase()
          14. toCharArray()  15. valueOf()
     - Method Chaining 110
          > String a= "abc"; String b= a.toUpperCase(); b= b.replace("B", "2").replace('C', '3');
     - Using the StringBuilder Class 111
          > Mutable
          > StringBuilder sb = new StringBuilder("start"); sb.append("+middle"); 
          > StringBuilder same = sb.append("+end"); // "start+middle+end"
     - Mutability and Chaining 112
          > StringBuilder a = new StringBuilder("abc");
            StringBuilder b = a.append("de");
            b = b.append("f").append("g");
               System.out.println("a=" + a);
               System.out.println("b=" + b);
     - Creating a StringBuilder 113
          >StringBuilder sb1 = new StringBuilder(); 
          StringBuilder sb2 = new StringBuilder("animal"); 
          StringBuilder sb3 = new StringBuilder(10);
     - Important StringBuilder Methods 114
          01. charAt() 02. indexOf() 03. lastIndexOf() 04. substring()
          05. append() 06. insert() 07. delete() 08. deleteCharAt() 09. reverse() 10. toString()
     - StringBuilder vs. StringBuffer 117
          > newer-older >faster-slower
     - Understanding Equality 117
          > String x = "Hello World"; String z = " Hello World".trim(); 
          > System.out.println(x == z); // false > System.out.println(x.equals(z)); // true
     - Understanding Java Arrays 119
          > Special variable > store multiple same type of data
          > int [] numAnimals2; int numAnimals3[];
          > int[] numbers2 = new int[] {42, 55, 99};
     - Creating an Array of Primitives 119
          > int[] iA= new int[1];  //[tray icon, indicate an array]      
     - Creating an Array with Reference Variables 121
          > String [] bugs = { "cricket", "beetle", "ladybug" };
          > String [] alias = bugs;
          >System.out.println(bugs.equals(alias)); // true
          >System.out.println(bugs.toString()); // [Ljava.lang.String;@160bc7c0
          > Object[] objects= bugs;
          > String[] againStrings = (String[]) objects;
     - Using an Array 123
          > String[] birds = new String[6]; 
             System.out.println(birds.length); //print all 6 elements of the array are null.
     - Sorting 124
          > Unsorted array, A surprise—this result isn’t predictable
          > String[] strings = { "10", "9", "100" }; Arrays.sort(strings); //outputs 10 100 9.
     - Searching 125
          > int[] numbers = {2,4,6,8}; 
          > System.out.println(Arrays.binarySearch(numbers, 2)); // 0
          > System.out.println(Arrays.binarySearch(numbers, 1)); // -1
     - Varargs 126
          > variable argument
     - Multidimensional Arrays 126
          > int [][] args = new int[4][];
          > char[][] cA2= {{'A', 'B', 'C'}, {'D', 'E', 'F'}}; //table with 2 rows and 3 columns
          > char[][] cA= new char[no_of_rows][no_of_cols];
          > int[][][] building = new int[no_of_floors][no_of_rows][no_of_column/rooms]; 
     - Understanding an ArrayList 129
     - Creating an ArrayList 129
     - Using an ArrayList 130
          01. add()  02. get() 03.set() 04. size() and  isEmpty() 
          05. remove() 06. removeOf()  07. clear()  08. contains()  09. equals()
     - Wrapper Classes 134
          > Object representations of primitive data types
          > Each 8 primitive type has a wrapper class
          Example of constructing
               int -> Integer, double -> Double, char -> Character, boolean -> Boolean, 
               byte -> Byte, short -> Short, long -> Long,float -> Float
          > Converting String to primitive: Boolean.parseBoolean("true"); Byte.parseByte("1");
          > Converting String to  wrapper class:   Boolean.valueOf("TRUE"); Byte.valueOf("2");
     - Autoboxing 136
          >I type the primitive value and Java will convert it to the relevant wrapper class for me.
          >List<Integer> weights = new ArrayList<>();
          > weights.add(50); // [50.5]  > weights.add(new Double(60)); // [50.5, 60.0]
            weights.add(Integer.valueOf(50));  //the compiler translates it into Integer something like this
     - Converting Between array and List 136
          >  String[] array = { "hawk", "robin" };  
               List<String> list = Arrays.asList(array); list.size();
     
          > List<String> list = new ArrayList<>();  list.add("hawk"); list.add("robin");
               > Object[] objectArray = list.toArray();  
               > String[] stringArray = list.toArray(new String[0]); //stringArray.length;
     
     - Sorting 138
          > List<Integer> numbers = new ArrayList<>(); numbers.add(99); numbers.add(5);
          > Collections.sort(numbers); Output:[5, 99]
     - Working with Dates and Times 138
     
     - Creating Dates and Times 138
          > LocalDate: Contains just a date 
          >LocalDateTime Contains both a date and time but no time zone.
          > System.out.println(LocalDate/LocalTime/LocalDateTime.now());
     - Manipulating Dates and Times 142
          > LocalDate date = LocalDate.now(); > System.out.println(date); // 2024-01-20
          > date = date.plusDays/Weeks/Months/Years(2); > System.out.println(date); // 2024-01-22
     - Working with Periods 145
          > LocalDate date = LocalDate.of(2015, 1, 20);  
          > Period period = Period.ofMonths(1); System.out.println(date.plus(period)); // 2015-02-20
          > LocalTime time = LocalTime.of(6, 15);  
          > LocalDateTime dateTime = LocalDateTime.of(date, time); 
             System.out.println(dateTime.plus(period)); // 2015-02-20T06:15
     
     - Formatting Dates and Times 148
          > LocalDate date = LocalDate.of(2020, Month.JANUARY, 20); 
          > LocalTime time = LocalTime.of(11, 12, 34);
          > LocalDateTime dateTime = LocalDateTime.of(date, time);
          > DateTimeFormatter f = DateTimeFormatter.ofPattern("MMMM dd, yyyy, hh:mm"); 
              System.out.println(dateTime.format(f)); // January 20, 2020, 11:12
     - Parsing Dates and Times 151
          > DateTimeFormatter f = DateTimeFormatter.ofPattern("MM dd yyyy");  
          > LocalDate date = LocalDate.parse("01 02 2015", f);
          > LocalTime time = LocalTime.parse("11:22");
               >System.out.println(date); // 2015-01-02
               >System.out.println(time); // 11:22
     
     - Summary 151
     - Exam Essentials 152
     - Review Questions 153


############# Chapter 4 Methods and Encapsulation 165 ##########################

    - Designing Methods 166
    - Optional Specifiers 168
       > static, abstract, final, synchronized, native, strictfp
    - Return Type 169
       > void return nothing but not restrict.
    - Method Name 170
       > start with _, &,  A-Z, a-z
    - Parameter List 171
    - Optional Exception List 171
    - Method Body 171
    - Working with Varargs 172
       > only parameter works these two ways: 01. walk1(int... nums) 02. walk2(int start, int... nums)
       > nums.length of walk2(1), walk2(1, 2), walk2(1,2,3), walk2(1, new int[] {4,5});
    - Applying Access Modifiers 173
       > private: only accessible within the same class
       > default(package-private): private and other classes in the same package
       > protected: default access and child classes
       > public: protected and classes in the other packages
    - Private Access 173
    - Default (Package Private) Access 175
       > Two different packages 1. Football and 2. Cricket, can access members to each other?
    - Protected Access 176
       > Two different packages 1.Football and 2.Cricket can access members creating subclass to each other?
    - Public Access 180
    - Designing Static Methods and Fields 181
        > public static int count = 0; // static variable
        > public static void main(String[] args) { // static method}
        > Koala.main(new String[0]); // call static method
        > count (vearible is very common)
    - Calling a Static Variable or Method 182
        >Koala.count = 4;
        Koala koala1 = new Koala();
        Koala koala2 = new Koala();
        koala1.count = 6;
        koala2.count = 5;
        System.out.println(Koala.count);
          Answer 5. All the Koala variables(4,6) are just distractions. 
    - Static vs. Instance 183
       > static works inside instance block, does not work opposite
    - Static Variables 185
    - Static Initialization 186
        > private static int one;
          private static final int two;
          private static final int three = 3;
          private static final int four; // DOES NOT COMPILE
               static {
               one = 1;  
               two = 2;
               three = 3; // DOES NOT COMPILE
               two = 4; // DOES NOT COMPILE
               }
    - Static Imports 187
          >import static java.util.Arrays.asList;
    - Passing Data Among Methods 188
       > pass-by-value with example  > pass-by-reference with example stringBuilder() 
    - Overloading Methods 191
       > Everything other than the method signature/name can vary. example:(access modifiers, return type, parameter, exception).
       > must have a different type/no./sequence of parameters
       > varargs: fly(int... length) ex: fly(1,2,3) vs fly(int[] length) ex: fly(new int[] {1,2,3})
       > Autoboxing > Reference Types > Primitives
       > autoboxing and varargs come last when Java looks at overloaded methods.
    
    - Creating Constructors 196
       > special method, name as class name > no return type >when use this?
    - Default Constructor 197
       > included by java automatically but when?
    - Overloading Constructors 199
       > must have a different type/no./sequence of parameters
    - Final Fields 202
       > set value exactly once > while declaring or constructor
    - Order of Initialization 202
       > 4 rules(Super, Static(Variable, Block), Instance(Variable, Block), Constructor)
       > static method/object instantiate into instance block

    - Encapsulating Data 205
       > bundling data into the method  > making uncontrolled changes to my class
       > private data(properties) >public method( is(), get(), set(), update())
    - Creating Immutable Classes 207
       > another common technique like encapsulation
       > making classes immutable so they can not be changed at all
       > omit the setters, not getter  > constuctor  >only when object is constructed 
       > issue with stringBuilder() and how to stop get reference too > toString() example

    - Writing Simple Lambdas 208
       > functional programming(interfaces with a single abstract method)(SAM) 
       > anonymous method > data type 'boolean'
    - Lambda Example 209
       > find negative/positive number > String startwith NOT 'h' > age of panda greater 5years > animal can swim. (Code>Lambda_Code)
    - Lambda Syntax 211
       > (Animal a)-> {return a.canHop();} vs  a-> a.canHop();
       > print(()->true) 
       > print(a->a.startsWtih("test"));      > print((String a)->a.startsWtih("test"));
       > print((a,b)-> a.startsWith("test")); > print((String a, Sring b)-> a.startsWith("test"));
       > print((a,b)-> { int c =0; return 5; }

    - Predicates 214
       > what & why > functional interface > data type boolean > generics
       > Interface Predicate<T>{boolean test(T t);} > removeIf() >Arraylist<>()
         Class{           
               print(animals, a -> a.canHop());
               }
                private static void print(List<Animal> animals, Predicate<Animal> checker) {
                for (Animal animal : animals) {
                if (checker.test(animal))
                System.out.print(animal + " ");
                }               
                }

    - Summary 215
    - Exam Essentials 216
    - Review Questions 218


############# Chapter 5 Class Design 233 ##########################

    - Introducing Class Inheritance 234
        > why >what Single/Multiple > No. of times extends a class
    - Extending a Class 235
        > how to Stop extending
    - Applying Class Access Modifiers 237
        > role of Default(package-private) in a file
    - Creating Java Objects 237
        > Object as Super Class/Object 
    - Defining Constructors 238
        > this() vs super() > default constructor > overloading 
        > understand compiler enhancement
        > non-argument/argument constructor in parent and child (Yes Vs Yes, No vs No, Yes vs No, No vs Yes)
        > reviewing 5-rules (
            1. The first statement of every constructor is a call to another constructor within the class
            using this(), or a call to a constructor in the direct parent class using super().
            2. The super() call may not be used after the first statement of the constructor.
            3. If no super() call is declared in a constructor, Java will insert a no-argument super()
            as the first statement of the constructor.
            4. If the parent doesn’t have a no-argument constructor and the child doesn’t define any
            constructors, the compiler will throw an error and try to insert a default no-argument
            constructor into the child class.
            5. If the parent doesn’t have a no-argument constructor, the compiler requires an explicit
            call to a parent constructor in each child constructor.
             
        Example:
         04. class Parent {
           public Parent(String name) { // Parent has only a parameterized constructor
           System.out.println("Parent constructor called with name: " + name);
           }
           }
           
           class Child extends Parent { 
           // No constructor defined in the child class
           }
           
           public class NoArgumentConstructorError {
           public static void main(String[] args) {
           Child child = new Child(); // This will cause a compile-time error 
          }
         }
         05. class Parent {
                  public Parent(String name) {  // Only a constructor with a parameter
                      System.out.println("Parent constructor called with name: " + name);
                  }
                  }
                  
                  class Child extends Parent {
                  public Child(String name) {
                      super(name); // Explicit call to the parent constructor is REQUIRED
                      System.out.println("Child constructor called");
                  }
                  }
                  
                  public class ExplicitParentConstructorCall {
                  public static void main(String[] args) {
                      Child child = new Child("John"); 
                  }
                  } 
                 
    - Calling Inherited Class Members 244
        > directly/(optional)this(current and parent) vs super
    - Inheriting Methods 246
        > overriding and 4-rules for nonprivate method(Access Modifier(Same/Broader), Return type(Same/Coveriant), Signature(Same), Parameter(Same), Exception(No/Narrower/not-new)
        > Overloading vs overriding  > redeclaring private methods > hiding static method > overriding vs hiding > final keyword
         Q: What is/are the true statement(s)?  
            public class Rodent {
                protected static Integer chew() throws Exception {
                System.out.println("Rodent is chewing");
                return 1;
                }
             }
             public class Beaver extends Rodent {
                public Number chew() throws RuntimeException {
                System.out.println("Beaver is chewing on wood");
                return 2;
                }
            }
                 A. It will compile without issue.
                 B. It fails to compile because the type of the exception the method throws is a subclass of
                 the type of exception the parent method throws.
                 C. It fails to compile because the return types are not covariant.
                 D. It fails to compile because the method is protected in the parent class and public in
                 the subclass.
                 E. It fails to compile because of a static modifier mismatch between the two methods.
         
                Ans: C,E
    - Inheriting Variables 257
        > hidding 
    - Creating Abstract Classes 259
        > why? 
    - Defining an Abstract Class 260
        > can have only abstract method? > final, private, abstract keyword with method.
    - Creating a Concrete Class 262
    - Extending an Abstract Class 263
        > 5-rules for definition Abs. class ( cannot be instantiated, any number, including zero, of abstract and nonabstract methods, 
           not private/final,  inherits all of its abstract methods as its own abstract methods, first concrete class implements all abstract(also if inherited any) methods.)
        > 4-rules for definition Abs. method(defined in abstract classes only, non-private/no-final, not method body/implementation, same rules for overriding a method )
    - Implementing Interfaces 266
        > Special type of class > may contain Abastract, Default and Static Method and only public final static variable 
    - Defining an Interface 267
        > 5-rules(cannot be instantiated, not required to have any methods,  not final, assumed to have public or default access, non-default methods are assumed abstract and public )
    - Inheriting an Interface 269
        > 2-rules(interface extends another interface, first concrete class must provide an implementation for all of the inherited abstract methods) 
        > class, interfaces and keywords
        > abstract methods and multiple interface
          ( method name = same, or same/different params/return type)
    - Interface Variables 273
        > assume always what?
    - Default Interface Methods 274
        > why?
        > 4-rules( only be declared within an interface ,must be marked with the default keyword,  not assumed to be static, final, or abstract, default method is assumed to be public)
        > default methods and multiple inheritance
             ( method name = same, or same/different params/return type
    - Static Interface Methods 278
        > 2-rules(static method is assumed to be public,  reference to the name of the interface must be used)
    - Understanding Polymorphism 279
        > defination & why?
        > A method that takes a parameter with type java.lang.Object will take any reference.
        > If a method takes a superclass of three objects, then any of those classes may be passed as a parameter to the method.
            public class Reptile {
             public String getName() {return "Reptile"; }
            }
            public class Alligator extends Reptile {
             public String getName() {return "Alligator";}
            }
            public class Crocodile extends Reptile {
             public String getName() {return "Crocodile";}
            }

             public class ZooWorker {
               public static void feed(Reptile reptile) { 
                      System.out.println("Feeding reptile "+reptile.getName());
               }
               public static void main(String[] args) {
                feed(new Alligator());  feed(new Crocodile()); feed(new Reptile());
               }
             }
            output: Feeding: Alligator, Feeding: Crocodile, Feeding: Reptile
         Q_01: Which of the following statements can be inserted in the blank line so that the code will compile successfully? 
              Can access brothers' property? (Choose all that apply)
         public interface CanHop {}
         public class BrazilianHornedFrog extends Frog {}
         public class TurtleFrog extends Frog {}
         public class Frog implements CanHop {
           public static void main(String[] args) {
             ________ frog = new TurtleFrog();
            }

    - Object vs. Reference 281
        > 2-rules(object(properties exist within the object in memory.), reference(methods and variables areaccessible to the Java program)) 
        > parents' members also store in memory as obj?
    - Casting Objects 282
        > Grandparent, parent and child's property-access
        > 4-rules(super2sub explicite, sub2super, not-related compilation error, or exemption runtime, ) 
        > 2 examples of rule 4
    - Virtual Methods 284
    - Polymorphic Parameters 285
        > what,why and how with example? 
        > casting > creating method in parent/child/unrelated class
    - Polymorphism and Method Overriding 287

    - Summary 288
    - Exam Essentials 289
    - Review Questions 291


############# Chapter 6 Exceptions 299 ##########################

    - Understanding Exceptions 300
        > coding mistakes 
        > Others are completely beyond your control(errors)
        > Internet connection goes down
        - The Role of Exceptions 300
        > baby stand up itself > need help to stand up
    - Understanding Exception Types 302
        > object > throwable 
        > Exception(checked), uncheck(Runtime Exception)  > Error
    - Throwing an Exception 304
        > declare and throw      > throws vs throw
        > I can declare all types of exceptions
          public void ohNo() throws Exception {
            throw new Exception();
           }
    - Using a try Statement 305
        > {} bracket is must 
    - Adding a finally Block 307
        > finally always execute  
        > try-catch-finally this sequence is important
    - Catching Various Types of Exceptions 309
        > parent-child sequence
    - Throwing a Second Exception 311
        > parameter > free to declare any type
            public static void main(String[] args) {
                FileReader reader = null;
                    try {
                    reader = read();
                    } catch (IOException e) {
                    try {
                    if (reader != null) reader.close();
                    } catch (IOException inner) {
                    }
                    }
            }
            private static FileReader read() throws IOException {
            // CODE GOES HERE
            }
    - Recognizing Common Exception Types 313
    - Runtime Exceptions 314
        They don’t have to be handled or declared.
        They can be thrown by the programmer or by the JVM. Common runtime exceptions include the following:
        > ArithmeticException Thrown by the JVM when code attempts to divide by zero 
                int answer = 11 / 0; Or int answer = 0 / 0;
        > ArrayIndexOutOfBoundsException Thrown by the JVM when code uses an illegal index to access an array
                int[] countsOfMoose = new int[3];   System.out.println(countsOfMoose[-1]);
        > ClassCastException Thrown by the JVM when an attempt is made to cast an exception to a subclass of which it is not an instance
                String type = "moose";   Object obj = type;   Integer number = (Integer) obj;
        > IllegalArgumentException Thrown by the programmer to indicate that a method has been passed an illegal or inappropriate argument
                if (numberEggs < 0) throw new IllegalArgumentException("# eggs must not be negative"); this.numberEggs = numberEggs;
        > NullPointerException Thrown by the JVM when there is a null reference where an object is required
                Object x = null;  x.toString(); x.length();
        > NumberFormatException Thrown by the programmer when an attempt is made to convert a string to a numeric type but the string doesn’t have an appropriate format
                public String name;   int x = Integer.parseInt(name);
       
    - Checked Exceptions 317
        > compile-time must handled > program can catch must be handled or declared. 
        They can be thrown by the programmer or by the JVM.
    
        > FileNotFoundException Thrown programmatically when code tries to reference a file that does not exist
        > IOException Thrown programmatically when there’s a problem reading or writing a fi le
        > SQLException
    - Errors 317
        > 3 example by JVM > program can not catch
            Errors are rare, Thrown by the JVM but you might see these:
        > ExceptionInInitializerError: when a static initializer throws an exception and doesn’t handle it
        > StackOverflowError: when a method calls itself too many times
        (this is called infinite recursion because the method typically calls itself without an end)
        > NoClassDefFoundError: when a class that the code uses is available  at compile time but not runtime
    - Calling Methods That Throw Exceptions 318
            public class Bunny {
                public static void main(String[] args) {
                eatCarrot();// DOES NOT COMPILE
                }
                private static void eatCarrot() throws NoMoreCarrotsException {
                }
            }

           Ans:   main() throws NoMoreCarrotsException
    - Subclasses 319    
        > unreachable (if parent exception comes first OR Exception/subclass of it, comes first before RuntimeException)
            Both A and B  are 0
             try {
             return a / b;
             }catch (RuntimeException e) {
             return -1;
             }catch (ArithmeticException e) {
             return 0;
             }
        > It’s okay to declare new runtime exceptions in a subclass method is that  the declaration is redundant. 
        > Methods are free to throw any runtime exceptions they want without mentioning them in the method declaration.

        Which of the following can be inserted into Lion to make this code compile? (Choose all that apply)
            class HasSoreThroatException extends Exception {}
            class TiredException extends RuntimeException {}
            interface Roar {
            void roar() throws HasSoreThroatException;
            }
            class Lion implements Roar {// INSERT CODE HERE
            }
                A. public void roar(){}
                B. public void roar() throws Exception{}
                C. public void roar() throws HasSoreThroatException{}
                D. public void roar() throws IllegalArgumentException{}
                E. public void roar() throws TiredException{}

                Ans: A,C,D,E
    - Printing an Exception 321
      > e > e.getMessage() > e.printStackTrace()
      > Which of the following can be inserted in the blank to make the code compile? (Choose all that apply)?
         A.Exception  B.IOException  C. IllegalArgumentException  D.RuntimeException E.StackOverflowError
       public static void main(String[] args) {
            try {
            System.out.println("work real hard");
            } catch ( e) {
            } catch (RuntimeException e) {
            }
       }
    Ans: -IllegalArgumentException & 
         -StackOverflowError (because it isn’t in the same inheritance tree as RuntimeException)

     >Q_02: What does the output of the following contain? (Choose all that apply)            
                 System.out.print("a");
                 try {
                 System.out.print("b");
                 throw new IllegalArgumentException();
                 } catch (IllegalArgumentException e) {
                 System.out.print("c");
                 throw new RuntimeException("1");
                 }finally {
                 System.out.print("e");
                 throw new RuntimeException("3");
                 }

       Ans: abce & An exception with the message set to "3"
    Q_03: Why  NumberFormatException does not thrown by JVM?
          > it is thrown programmatically by the wrapper classes of java.lang.
    Q_04: What is the role of "throw e"  and what does System.exit(0);
             String name=null;
           try {System.out.print("2");
               name.toString();
              System.out.print("3");
           }catch (NullPointerException e) {
            System.out.print("4");
            throw e;
           }
       Ans: > through exception again; 
            >System.exit(0) exit out immediatly form the program.
       

    - Exception as return type of a method.
        public class ExceptionReturnExample {
            public static Exception createException() {
                Exception myException = new Exception("This is a sample exception.");
                return myException; // Returning the Exception object
            }    
            public static void main(String[] args) {
                Exception returnedException = createException(); 
                System.out.println(returnedException.getMessage()); // Accessing the exception message
            }
        }



    - Summary 323
    - Exam Essentials 324
    - Review Questions 325
    - Appendix A Answers to Review Questions 333
